[{"id":"696c711dc425c21ecfe6691bc40887b7","title":"JUC","content":"一、线程基础1、Java多线程相关概念1、进程是程序的⼀次执⾏，是系统进⾏资源分配和调度的独⽴单位，每⼀个进程都有它⾃⼰的内存空间和系统资源\n进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。\n进程具有的特征：\n\n动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的\n并发性：任何进程都可以同其他进行一起并发执行\n独立性：进程是系统进行资源分配和调度的一个独立单位\n结构性：进程由程序，数据和进程控制块三部分组成\n\n我们经常使用windows系统，经常会看见.exe后缀的文件，双击这个.exe文件的时候，这个文件中的指令就会被系统加载，那么我们就能得到一个关于这个.exe程序的进程。进程是“活”的，或者说是正在被执行的。\n2、线程在同一个进程内又可以执⾏多个任务，这每一个任务我们就可以看做是一个线程 一个进程会有1个或多个线程的。线程是轻量级的进程，是程序执行的最小单元，使用多线程而不是多进程去进行并发程序的设计，是因为线程间的切换和调度的成本远远小于进程。3、进程与线程的一个简单解释进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。\n假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。\n\n进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。\n\n一个车间里，可以有很多工人。他们协同完成一个任务。\n\n线程就好比车间里的工人。一个进程可以包括多个线程。\n\n车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。\n\n可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。\n\n一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。\n\n还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。\n\n这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。\n操作系统的设计，因此可以归结为三点：（1）以多进程形式，允许多个任务同时运行；（2）以多线程形式，允许单个任务分成不同的部分运行；（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。\n4、管程Monitor(监视器)，也就是我们平时所说的锁\n// Monitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。\n// JVM中同步是基于进入和退出监视器对象(Monitor,管程对象)来实现的，每个对象实例都会有一个Monitor对象，\nObject o = new Object();\nnew Thread(() -> &#123;\n    synchronized (o)\n    &#123;\n    &#125;\n&#125;,\"t1\").start();\n// Monitor对象会和Java对象一同创建并销毁，它底层是由C++语言来实现的。\n\n\n5、线程状态？// Thread.State\npublic enum State &#123;\n    NEW,(新建)\n    RUNNABLE,（准备就绪）\n    BLOCKED,（阻塞）\n    WAITING,（不见不散）\n    TIMED_WAITING,（过时不候）\n    TERMINATED;(终结)\n&#125;\n\n线程几个状态的介绍：\n\nNew：表示刚刚创建的线程，这种线程还没有开始执行\nRUNNABLE：运行状态，线程的start()方法调用后，线程会处于这种状态\nBLOCKED：阻塞状态。当线程在执行的过程中遇到了synchronized同步块，但这个同步块被其他线程已获取还未释放时，当前线程将进入阻塞状态，会暂停执行，直到获取到锁。当线程获取到锁之后，又会进入到运行状态（RUNNABLE）\nWAITING：等待状态。和TIME_WAITING都表示等待状态，区别是WAITING会进入一个无时间限制的等，而TIME_WAITING会进入一个有限的时间等待，那么等待的线程究竟在等什么呢？一般来说，WAITING的线程正式在等待一些特殊的事件，比如，通过wait()方法等待的线程在等待notify()方法，而通过join()方法等待的线程则会等待目标线程的终止。一旦等到期望的事件，线程就会再次进入RUNNABLE运行状态。\nTERMINATED：表示结束状态，线程执行完毕之后进入结束状态。\n\n注意：从NEW状态出发后，线程不能在回到NEW状态，同理，处理TERMINATED状态的线程也不能在回到RUNNABLE状态\n6、wait&#x2F;sleep的区别？功能都是当前线程暂停，有什么区别？\nwait放开手去睡，放开手里的锁\nsleep握紧手去睡，醒了手里还有锁\n2、线程的基本操作1、新建线程新建线程很简单。只需要使用new关键字创建一个线程对象，然后调用它的start()启动线程即可。\nThread thread1 = new Thread1();\nt1.start();\n\n那么线程start()之后，会干什么呢？线程有个run()方法，start()会创建一个新的线程并让这个线程执行run()方法。\n这里需要注意，下面代码也能通过编译，也能正常执行。但是，却不能新建一个线程，而是在当前线程中调用run()方法，将run方法只是作为一个普通的方法调用。\nThread thread = new Thread1();\nthread1.run();\n\n所以，希望大家注意，调用start方法和直接调用run方法的区别。\nstart方法是启动一个线程，run方法只会在垫钱线程中串行的执行run方法中的代码。\n默认情况下， 线程的run方法什么都没有，启动一个线程之后马上就结束了，所以如果你需要线程做点什么，需要把您的代码写到run方法中，所以必须重写run方法。\nThread thread1 &#x3D; new Thread() &#123;            @Override            public void run() &#123;                System.out.println(&quot;hello,我是一个线程!&quot;);            &#125;        &#125;;thread1.start();\n\n上面是使用匿名内部类实现的，重写了Thread的run方法，并且打印了一条信息。我们可以通过继承Thread类，然后重写run方法，来自定义一个线程。但考虑java是单继承的，从扩展性上来说，我们实现一个接口来自定义一个线程更好一些，java中刚好提供了Runnable接口来自定义一个线程。\n@FunctionalInterfacepublic interface Runnable &#123;    public abstract void run();&#125;\n\nThread类有一个非常重要的构造方法：\npublic Thread(Runnable target)\n\n我们在看一下Thread的run方法：\npublic void run() &#123;        if (target !&#x3D; null) &#123;            target.run();        &#125;    &#125;\n\n当我们启动线程的start方法之后，线程会执行run方法，run方法中会调用Thread构造方法传入的target的run方法。\n实现Runnable接口是比较常见的做法，也是推荐的做法。\n2、终止线程一般来说线程执行完毕就会结束，无需手动关闭。但是如果我们想关闭一个正在运行的线程，有什么方法呢？可以看一下Thread类中提供了一个stop()方法，调用这个方法，就可以立即将一个线程终止，非常方便。\nimport lombok.extern.slf4j.Slf4j;\nimport java.util.concurrent.TimeUnit;\n\n@Slf4j\npublic class Demo01 &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        Thread thread1 = new Thread() &#123;\n            @Override\n            public void run() &#123;\n                log.info(\"start\");\n                boolean flag = true;\n                while (flag) &#123;\n                    ;\n                &#125;\n                log.info(\"end\");\n            &#125;\n        &#125;;\n        thread1.setName(\"thread1\");\n        thread1.start();\n        //当前线程休眠1秒\n        TimeUnit.SECONDS.sleep(1);\n        //关闭线程thread1\n        thread1.stop();\n        //输出线程thread1的状态\n        log.info(\"&#123;&#125;\", thread1.getState());\n        //当前线程休眠1秒\n        TimeUnit.SECONDS.sleep(1);\n        //输出线程thread1的状态\n        log.info(\"&#123;&#125;\", thread1.getState());\n    &#125;\n&#125;\n\n运行代码，输出：\n18:02:15.312 [thread1] INFO com.itsoku.chat01.Demo01 - start\n18:02:16.311 [main] INFO com.itsoku.chat01.Demo01 - RUNNABLE\n18:02:17.313 [main] INFO com.itsoku.chat01.Demo01 - TERMINATED\n\n代码中有个死循环，调用stop方法之后，线程thread1的状态变为TERMINATED（结束状态），线程停止了。\n我们使用idea或者eclipse的时候，会发现这个方法是一个废弃的方法，也就是说，在将来，jdk可能就会移除该方法。\nstop方法为何会被废弃而不推荐使用？stop方法过于暴力，强制把正在执行的方法停止了。\n大家是否遇到过这样的场景：电力系统需要维修，此时咱们正在写代码，维修人员直接将电源关闭了，代码还没保存的，是不是很崩溃，这种方式就像直接调用线程的stop方法类似。线程正在运行过程中，被强制结束了，可能会导致一些意想不到的后果。可以给大家发送一个通知，告诉大家保存一下手头的工作，将电脑关闭。\n3、线程中断在java中，线程中断是一种重要的线程写作机制，从表面上理解，中断就是让目标线程停止执行的意思，实际上并非完全如此。在上面中，我们已经详细讨论了stop方法停止线程的坏处，jdk中提供了更好的中断线程的方法。严格的说，线程中断并不会使线程立即退出，而是给线程发送一个通知，告知目标线程，有人希望你退出了！至于目标线程接收到通知之后如何处理，则完全由目标线程自己决定，这点很重要，如果中断后，线程立即无条件退出，我们又会到stop方法的老问题。\nThread提供了3个与线程中断有关的方法，这3个方法容易混淆，大家注意下：\npublic void interrupt() //中断线程\npublic boolean isInterrupted() //判断线程是否被中断\npublic static boolean interrupted()  //判断线程是否被中断，并清除当前中断状态\n\ninterrupt()方法是一个实例方法，它通知目标线程中断，也就是设置中断标志位为true，中断标志位表示当前线程已经被中断了。isInterrupted()方法也是一个实例方法，它判断当前线程是否被中断（通过检查中断标志位）。最后一个方法interrupted()是一个静态方法，返回boolean类型，也是用来判断当前线程是否被中断，但是同时会清除当前线程的中断标志位的状态。\nwhile (true) &#123;\n            if (this.isInterrupted()) &#123;\n                System.out.println(\"我要退出了!\");\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;;\nthread1.setName(\"thread1\");\nthread1.start();\nTimeUnit.SECONDS.sleep(1);\nthread1.interrupt();\n\n上面代码中有个死循环，interrupt()方法被调用之后，线程的中断标志将被置为true，循环体中通过检查线程的中断标志是否为ture（this.isInterrupted()）来判断线程是否需要退出了。\n再看一种中断的方法：\nstatic volatile boolean isStop = false;\npublic static void main(String[] args) throws InterruptedException &#123;\n    Thread thread1 = new Thread() &#123;\n        @Override\n        public void run() &#123;\n            while (true) &#123;\n                if (isStop) &#123;\n                    System.out.println(\"我要退出了!\");\n                    break;\n                &#125;\n            &#125;\n        &#125;\n    &#125;;\n    thread1.setName(\"thread1\");\n    thread1.start();\n    TimeUnit.SECONDS.sleep(1);\n    isStop = true;\n&#125;\n\n\n代码中通过一个变量isStop来控制线程是否停止。\n通过变量控制和线程自带的interrupt方法来中断线程有什么区别呢？\n如果一个线程调用了sleep方法，一直处于休眠状态，通过变量控制，还可以中断线程么？大家可以思考一下。\n此时只能使用线程提供的interrupt方法来中断线程了。\npublic static void main(String[] args) throws InterruptedException &#123;\n    Thread thread1 = new Thread() &#123;\n        @Override\n        public void run() &#123;\n            while (true) &#123;\n                //休眠100秒\n                try &#123;\n                    TimeUnit.SECONDS.sleep(100);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                System.out.println(\"我要退出了!\");\n                break;\n            &#125;\n        &#125;\n    &#125;;\n    thread1.setName(\"thread1\");\n    thread1.start();\n    TimeUnit.SECONDS.sleep(1);\n    thread1.interrupt();\n&#125;\n\n调用interrupt()方法之后，线程的sleep方法将会抛出InterruptedException异常。\nThread thread1 = new Thread() &#123;\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            //休眠100秒\n            try &#123;\n                TimeUnit.SECONDS.sleep(100);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            if (this.isInterrupted()) &#123;\n                System.out.println(\"我要退出了!\");\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;;\n\n运行上面的代码，发现程序无法终止。为什么？\n代码需要改为：\nThread thread1 = new Thread() &#123;\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            //休眠100秒\n            try &#123;\n                TimeUnit.SECONDS.sleep(100);\n            &#125; catch (InterruptedException e) &#123;\n                this.interrupt();\n                e.printStackTrace();\n            &#125;\n            if (this.isInterrupted()) &#123;\n                System.out.println(\"我要退出了!\");\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;;\n\n上面代码可以终止。\n注意：sleep方法由于中断而抛出异常之后，线程的中断标志会被清除（置为false），所以在异常中需要执行this.interrupt()方法，将中断标志位置为true\n4、等待（wait）和通知（notify）为了支持多线程之间的协作，JDK提供了两个非常重要的方法：等待wait()方法和通知notify()方法。这2个方法并不是在Thread类中的，而是在Object类中定义的。这意味着所有的对象都可以调用者两个方法。\npublic final void wait() throws InterruptedException;\npublic final native void notify();\n\n当在一个对象实例上调用wait()方法后，当前线程就会在这个对象上等待。这是什么意思？比如在线程A中，调用了obj.wait()方法，那么线程A就会停止继续执行，转为等待状态。等待到什么时候结束呢？线程A会一直等到其他线程调用obj.notify()方法为止，这时，obj对象成为了多个线程之间的有效通信手段。\n那么wait()方法和notify()方法是如何工作的呢？如图2.5展示了两者的工作过程。如果一个线程调用了object.wait()方法，那么它就会进出object对象的等待队列。这个队列中，可能会有多个线程，因为系统可能运行多个线程同时等待某一个对象。当object.notify()方法被调用时，它就会从这个队列中随机选择一个线程，并将其唤醒。这里希望大家注意一下，这个选择是不公平的，并不是先等待线程就会优先被选择，这个选择完全是随机的。\n\n除notify()方法外，Object独享还有一个nofiyAll()方法，它和notify()方法的功能类似，不同的是，它会唤醒在这个等待队列中所有等待的线程，而不是随机选择一个。\n这里强调一点，Object.wait()方法并不能随便调用。它必须包含在对应的synchronize语句汇总，无论是wait()方法或者notify()方法都需要首先获取目标独享的一个监视器。图2.6显示了wait()方法和nofiy()方法的工作流程细节。其中T1和T2表示两个线程。T1在正确执行wait()方法钱，必须获得object对象的监视器。而wait()方法在执行后，会释放这个监视器。这样做的目的是使其他等待在object对象上的线程不至于因为T1的休眠而全部无法正常执行。\n线程T2在notify()方法调用前，也必须获得object对象的监视器。所幸，此时T1已经释放了这个监视器，因此，T2可以顺利获得object对象的监视器。接着，T2执行了notify()方法尝试唤醒一个等待线程，这里假设唤醒了T1。T1在被唤醒后，要做的第一件事并不是执行后续代码，而是要尝试重新获得object对象的监视器，而这个监视器也正是T1在wait()方法执行前所持有的那个。如果暂时无法获得，则T1还必须等待这个监视器。当监视器顺利获得后，T1才可以在真正意义上继续执行。\n给大家上个例子：\npublic class Demo06 &#123;\n    static Object object = new Object();\n    public static class T1 extends Thread &#123;\n        @Override\n        public void run() &#123;\n            synchronized (object) &#123;\n                System.out.println(System.currentTimeMillis() + \":T1 start!\");\n                try &#123;\n                    System.out.println(System.currentTimeMillis() + \":T1 wait for object\");\n                    object.wait();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                System.out.println(System.currentTimeMillis() + \":T1 end!\");\n            &#125;\n        &#125;\n    &#125;\n    public static class T2 extends Thread &#123;\n        @Override\n        public void run() &#123;\n            synchronized (object) &#123;\n                System.out.println(System.currentTimeMillis() + \":T2 start，notify one thread! \");\n                object.notify();\n                System.out.println(System.currentTimeMillis() + \":T2 end!\");\n                try &#123;\n                    Thread.sleep(2000);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        new T1().start();\n        new T2().start();\n    &#125;\n&#125;\n\n运行结果：\n1562934497212:T1 start!\n1562934497212:T1 wait for object\n1562934497212:T2 start，notify one thread!\n1562934497212:T2 end!\n1562934499213:T1 end!\n\n注意下打印结果，T2调用notify方法之后，T1并不能立即继续执行，而是要等待T2释放objec投递锁之后，T1重新成功获取锁后，才能继续执行。因此最后2行日志相差了2秒（因为T2调用notify方法后休眠了2秒）。\n注意：Object.wait()方法和Thread.sleep()方法都可以让现场等待若干时间。除wait()方法可以被唤醒外，另外一个主要的区别就是wait()方法会释放目标对象的锁，而Thread.sleep()方法不会释放锁。\n再给大家讲解一下wait()，notify()，notifyAll()，加深一下理解：\n可以这么理解，obj对象上有2个队列，如图1，q1：等待队列，q2：准备获取锁的队列；两个队列都为空。\n\nobj.wait()过程：\nsynchronize(obj)&#123;\n    obj.wait();\n&#125;\n\n假如有3个线程，t1、t2、t3同时执行上面代码，t1、t2、t3会进入q2队列，如图2，进入q2的队列的这些线程才有资格去争抢obj的锁，假设t1争抢到了，那么t2、t3机型在q2中等待着获取锁，t1进入代码块执行wait()方法，此时t1会进入q1队列，然后系统会通知q2队列中的t2、t3去争抢obj的锁，抢到之后过程如t1的过程。最后t1、t2、t3都进入了q1队列，如图3。\n\n\n上面过程之后，又来了线程t4执行了notify()方法，如下：**\nsynchronize(obj)&#123;\n    obj.notify();\n&#125;\n\nt4会获取到obj的锁，然后执行notify()方法，系统会从q1队列中随机取一个线程，将其加入到q2队列，假如t2运气比较好，被随机到了，然后t2进入了q2队列，如图4，进入q2的队列的锁才有资格争抢obj的锁，t4线程执行完毕之后，会释放obj的锁，此时队列q2中的t2会获取到obj的锁，然后继续执行，执行完毕之后，q1中包含t1、t3，q2队列为空，如图5\n\n\n接着又来了个t5队列，执行了notifyAll()方法，如下：\nsynchronize(obj)&#123;\n    obj.notifyAll();\n&#125;\n\n2.调用obj.wait()方法，当前线程会加入队列queue1，然后会释放obj对象的锁\nt5会获取到obj的锁，然后执行notifyAll()方法，系统会将队列q1中的线程都移到q2中，如图6，t5线程执行完毕之后，会释放obj的锁，此时队列q2中的t1、t3会争抢obj的锁，争抢到的继续执行，未增强到的带锁释放之后，系统会通知q2中的线程继续争抢索，然后继续执行，最后两个队列中都为空了。\n\n5、挂起（suspend）和继续执行（resume）线程Thread类中还有2个方法，即**线程挂起(suspend)和继续执行(resume)**，这2个操作是一对相反的操作，被挂起的线程，必须要等到resume()方法操作后，才能继续执行。系统中已经标注着2个方法过时了，不推荐使用。\n系统不推荐使用suspend()方法去挂起线程是因为suspend()方法导致线程暂停的同时，并不会释放任何锁资源。此时，其他任何线程想要访问被它占用的锁时，都会被牵连，导致无法正常运行（如图2.7所示）。直到在对应的线程上进行了resume()方法操作，被挂起的线程才能继续，从而其他所有阻塞在相关锁上的线程也可以继续执行。但是，如果resume()方法操作意外地在suspend()方法前就被执行了，那么被挂起的线程可能很难有机会被继续执行了。并且，更严重的是：它所占用的锁不会被释放，因此可能会导致整个系统工作不正常。而且，对于被挂起的线程，从它线程的状态上看，居然还是Runnable状态，这也会影响我们队系统当前状态的判断。\n上个例子：\npublic class Demo07 &#123;\n    static Object object = new Object();\n    public static class T1 extends Thread &#123;\n        public T1(String name) &#123;\n            super(name);\n        &#125;\n        @Override\n        public void run() &#123;\n            synchronized (object) &#123;\n                System.out.println(\"in \" + this.getName());\n                Thread.currentThread().suspend();\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        T1 t1 = new T1(\"t1\");\n        t1.start();\n        Thread.sleep(100);\n        T1 t2 = new T1(\"t2\");\n        t2.start();\n        t1.resume();\n        t2.resume();\n        t1.join();\n        t2.join();\n    &#125;\n&#125;\n\n运行代码输出：\nin t1\nin t2\n\n我们会发现程序不会结束，线程t2被挂起了，导致程序无法结束，使用jstack命令查看线程堆栈信息可以看到：\n\"t2\" #13 prio=5 os_prio=0 tid=0x000000002796c000 nid=0xa3c runnable [0x000000002867f000]\n   java.lang.Thread.State: RUNNABLE\n        at java.lang.Thread.suspend0(Native Method)\n        at java.lang.Thread.suspend(Thread.java:1029)\n        at com.itsoku.chat01.Demo07$T1.run(Demo07.java:20)\n        - locked &lt;0x0000000717372fc0> (a java.lang.Object)\n\n发现t2线程在suspend0处被挂起了，t2的状态竟然还是RUNNABLE状态，线程明明被挂起了，状态还是运行中容易导致我们队当前系统进行误判，代码中已经调用resume()方法了，但是由于时间先后顺序的缘故，resume并没有生效，这导致了t2永远滴被挂起了，并且永远占用了object的锁，这对于系统来说可能是致命的。\n6、等待线程结束（join）和谦让（yeild）很多时候，一个线程的输入可能非常依赖于另外一个或者多个线程的输出，此时，这个线程就需要等待依赖的线程执行完毕，才能继续执行。jdk提供了join()操作来实现这个功能。如下所示，显示了2个join()方法：\npublic final void join() throws InterruptedException;\npublic final synchronized void join(long millis) throws InterruptedException;\n\n第1个方法表示无限等待，它会一直只是当前线程。知道目标线程执行完毕。\n第2个方法有个参数，用于指定等待时间，如果超过了给定的时间目标线程还在执行，当前线程也会停止等待，而继续往下执行。\n比如：线程T1需要等待T2、T3完成之后才能继续执行，那么在T1线程中需要分别调用T2和T3的join()方法。\n上个示例：\npublic class Demo08 &#123;\n    static int num = 0;\n    public static class T1 extends Thread &#123;\n        public T1(String name) &#123;\n            super(name);\n        &#125;\n        @Override\n        public void run() &#123;\n            System.out.println(System.currentTimeMillis() + \",start \" + this.getName());\n            for (int i = 0; i &lt; 10; i++) &#123;\n                num++;\n                try &#123;\n                    Thread.sleep(200);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            System.out.println(System.currentTimeMillis() + \",end \" + this.getName());\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        T1 t1 = new T1(\"t1\");\n        t1.start();\n        t1.join();\n        System.out.println(System.currentTimeMillis() + \",num = \" + num);\n    &#125;\n&#125;\n\n执行结果：\n1562939889129,start t1\n1562939891134,end t1\n1562939891134,num = 10\n\nnum的结果为10，1、3行的时间戳相差2秒左右，说明主线程等待t1完成之后才继续执行的。\n看一下jdk1.8中Thread.join()方法的实现：\npublic final synchronized void join(long millis) throws InterruptedException &#123;\n    long base = System.currentTimeMillis();\n    long now = 0;\n    if (millis &lt; 0) &#123;\n        throw new IllegalArgumentException(\"timeout value is negative\");\n    &#125;\n    if (millis == 0) &#123;\n        while (isAlive()) &#123;\n            wait(0);\n        &#125;\n    &#125; else &#123;\n        while (isAlive()) &#123;\n            long delay = millis - now;\n            if (delay &lt;= 0) &#123;\n                break;\n            &#125;\n            wait(delay);\n            now = System.currentTimeMillis() - base;\n        &#125;\n    &#125;\n&#125;\n\n从join的代码中可以看出，在被等待的线程上使用了synchronize，调用了它的wait()方法，线程最后执行完毕之后，系统会自动调用它的notifyAll()方法，唤醒所有在此线程上等待的其他线程。\n注意：被等待的线程执行完毕之后，系统自动会调用该线程的notifyAll()方法。所以一般情况下，我们不要去在线程对象上使用wait()、notify()、notifyAll()方法。\n另外一个方法是**Thread.yield()**，他的定义如下：\npublic static native void yield();\n\nyield是谦让的意思，这是一个静态方法，一旦执行，它会让当前线程出让CPU，但需要注意的是，出让CPU并不是说不让当前线程执行了，当前线程在出让CPU后，还会进行CPU资源的争夺，但是能否再抢到CPU的执行权就不一定了。因此，对Thread.yield()方法的调用好像就是在说：我已经完成了一些主要的工作，我可以休息一下了，可以让CPU给其他线程一些工作机会了。\n如果觉得一个线程不太重要，或者优先级比较低，而又担心此线程会过多的占用CPU资源，那么可以在适当的时候调用一下Thread.yield()方法，给与其他线程更多的机会。\n7、总结\n创建线程的2中方式：继承Thread类；实现Runnable接口\n启动线程：调用线程的start()方法\n终止线程：调用线程的stop()方法，方法已过时，建议不要使用\n线程中断相关的方法：调用线程实例interrupt()方法将中断标志置为true；使用**线程实例方法isInterrupted()获取中断标志；调用Thread的静态方法interrupted()**获取线程是否被中断，此方法调用之后会清除中断标志（将中断标志置为false了）\nwait、notify、notifyAll方法，这块比较难理解，可以回过头去再理理\n线程挂起使用**线程实例方法suspend()，恢复线程使用线程实例方法resume()**，这2个方法都过时了，不建议使用\n等待线程结束：调用线程实例方法join()\n出让cpu资源：调用线程静态方法yeild()\n\n2、为什么多线程极其重要？？？\n硬件方面 - 摩尔定律失效\n\n摩尔定律：它是由英特尔创始人之一Gordon Moore(戈登·摩尔)提出来的。其内容为：当价格不变时，集成电路上可容纳的元器件的数目约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度。\n可是从2003年开始CPU主频已经不再翻倍，而是采用多核而不是更快的主频。\n摩尔定律失效。\n在主频不再提高且核数在不断增加的情况下，要想让程序更快就要用到并行或并发编程。\n\n软件方面\n\n高并发系统，异步+回调等生产需求\n3、从start一个线程说起// Java线程理解以及openjdk中的实现\nprivate native void start0();\n// Java语言本身底层就是C++语言\n\n\n\n\n\n\n\n\n\n\nOpenJDK源码网址:http://openjdk.java.net/\nopenjdk8\\hotspot\\src\\share\\vm\\runtime\n\n更加底层的C++源码解读\nopenjdk8\\jdk\\src\\share\\native\\java\\lang   thread.c\njava线程是通过start的方法启动执行的，主要内容在native方法start0中，Openjdk的写JNI一般是一一对应的，Thread.java对应的就是Thread.c start0其实就是JVM_StartThread。此时查看源代码可以看到在jvm.h中找到了声明，jvm.cpp中有实现。    \n\n\nopenjdk8\\hotspot\\src\\share\\vm\\prims  jvm.cpp\n\n\n\nopenjdk8\\hotspot\\src\\share\\vm\\runtime  thread.cpp\n\n\n4、用户线程和守护线程Java线程分为用户线程和守护线程，线程的daemon属性为true表示是守护线程，false表示是用户线程\n守护线程是一种特殊的线程，在后台默默地完成一些系统性的服务，比如垃圾回收线程\n用户线程是系统的工作线程，它会完成这个程序需要完成的业务操作\npublic class DaemonDemo &#123;\n\n    public static void main(String[] args) &#123;\n        Thread t1 = new Thread(() -> &#123;\n            System.out.println(Thread.currentThread().getName() + \"\\t 开始运行，\" + (Thread.currentThread().isDaemon() ? \"守护线程\" : \"用户线程\"));\n            while (true) &#123;\n\n            &#125;\n        &#125;, \"t1\");\n\n        //线程的daemon属性为true表示是守护线程，false表示是用户线程\n        t1.setDaemon(true);\n        t1.start();\n\n        //3秒钟后主线程再运行\n        try &#123;\n            TimeUnit.SECONDS.sleep(3);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(\"----------main线程运行完毕\");\n    &#125;\n\n&#125;\n\n重点当程序中所有用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出\n如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以当系统只剩下守护进程的时候，java虚拟机会自动退出\n设置守护线程，需要在start()方法之前进行\n5、获得多线程的方法几种？\n传统的是\n\n继承thread类\n实现runnable接口，\n\n\njava5以后\n\n实现callable接口\njava的线程池获得\n\n\n\n6、Callable接口1、与runnable对比// 创建新类MyThread实现runnable接口\nclass MyThread implements Runnable&#123;\n @Override\n public void run() &#123;\n \n &#125;\n&#125;\n// 新类MyThread2实现callable接口\nclass MyThread2 implements Callable&lt;Integer>&#123;\n @Override\n public Integer call() throws Exception &#123;\n  return 200;\n &#125; \n&#125;\n// 面试题:callable接口与runnable接口的区别？\n \n// 答：（1）是否有返回值\n//     （2）是否抛异常\n//    （3）落地方法不一样，一个是run，一个是call\n\n2、怎么用直接替换runnable是否可行？\n\n不可行，因为：thread类的构造方法根本没有Callable\n\n认识不同的人找中间人\n\npublic static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n  FutureTask futureTask = new FutureTask(new MyThread2());\n  new Thread(futureTask,\"AA\").start();\n&#125;\n\n运行成功后如何获得返回值？\n\npublic static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n  FutureTask futureTask = new FutureTask(new MyThread2());\n  new Thread(futureTask,\"AA\").start();\n  System.out.println(futureTask.get());\n&#125;\n\n\n\n二、线程池1、什么是线程池大家用jdbc操作过数据库应该知道，操作数据库需要和数据库建立连接，拿到连接之后才能操作数据库，用完之后销毁。数据库连接的创建和销毁其实是比较耗时的，真正和业务相关的操作耗时是比较短的。每个数据库操作之前都需要创建连接，为了提升系统性能，后来出现了数据库连接池，系统启动的时候，先创建很多连接放在池子里面，使用的时候，直接从连接池中获取一个，使用完毕之后返回到池子里面，继续给其他需要者使用，这其中就省去创建连接的时间，从而提升了系统整体的性能。\n线程池和数据库连接池的原理也差不多，创建线程去处理业务，可能创建线程的时间比处理业务的时间还长一些，如果系统能够提前为我们创建好线程，我们需要的时候直接拿来使用，用完之后不是直接将其关闭，而是将其返回到线程中中，给其他需要这使用，这样直接节省了创建和销毁的时间，提升了系统的性能。\n简单的说，在使用了线程池之后，创建线程变成了从线程池中获取一个空闲的线程，然后使用，关闭线程变成了将线程归还到线程池。\n2、为什么用线程池线程池的优势：\n​\t\t线程池做的工作主要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。\n它的主要特点为：线程复用;控制最大并发数;管理线程。\n第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。\n第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。\n第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控\n3、线程池的使用1、Executors.newFixedThreadPool(int)​\t\tnewFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的是LinkedBlockingQueue执行长期任务性能好，创建一个线程池，一池有N个固定的线程，有固定线程数的线程\npublic static ExecutorService newFixedThreadPool(int nThreads) &#123;\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue&lt;Runnable>());\n&#125;\n\n2、Executors.newSingleThreadExecutor()​\t\tnewSingleThreadExecutor 创建的线程池corePoolSize和maximumPoolSize值都是1，它使用的是LinkedBlockingQueue一个任务一个任务的执行，一池一线程\npublic static ExecutorService newSingleThreadExecutor() &#123;\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue&lt;Runnable>()));\n&#125;\n\n3、Executors.newCachedThreadPool()​\t\tnewCachedThreadPool创建的线程池将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，它使用的是SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。\n执行很多短期异步任务，线程池根据需要创建新线程，但在先前构建的线程可用时将重用它们。可扩容，遇强则强\npublic static ExecutorService newCachedThreadPool() &#123;\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue&lt;Runnable>());\n&#125;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n/**\n * 线程池\n * Arrays\n * Collections\n * Executors\n */\npublic class MyThreadPoolDemo &#123;\n\n    public static void main(String[] args) &#123;\n        //List list = new ArrayList();\n        //List list = Arrays.asList(\"a\",\"b\");\n        //固定数的线程池，一池五线程\n\n//       ExecutorService threadPool =  Executors.newFixedThreadPool(5); //一个银行网点，5个受理业务的窗口\n//       ExecutorService threadPool =  Executors.newSingleThreadExecutor(); //一个银行网点，1个受理业务的窗口\n       ExecutorService threadPool =  Executors.newCachedThreadPool(); //一个银行网点，可扩展受理业务的窗口\n\n        //10个顾客请求\n        try &#123;\n            for (int i = 1; i &lt;=10; i++) &#123;\n                threadPool.execute(()->&#123;\n                    System.out.println(Thread.currentThread().getName()+\"\\t 办理业务\");\n                &#125;);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            threadPool.shutdown();\n        &#125;\n\n    &#125;\n&#125;\n\n4、ThreadPoolExecutor底层原理\n举个例子，加深理解：\n咱们作为开发者，上面都有开发主管，主管下面带领几个小弟干活，CTO给主管授权说，你可以招聘5个小弟干活，新来任务，如果小弟还不到吴哥，立即去招聘一个来干这个新来的任务，当5个小弟都招来了，再来任务之后，将任务记录到一个表格中，表格中最多记录100个，小弟们会主动去表格中获取任务执行，如果5个小弟都在干活，并且表格中也记录满了，那你可以将小弟扩充到20个，如果20个小弟都在干活，并且存放任务的表也满了，产品经理再来任务后，是直接拒绝，还是让产品自己干，这个由你自己决定，小弟们都尽心尽力在干活，任务都被处理完了，突然公司业绩下滑，几个员工没事干，打酱油，为了节约成本，CTO主管把小弟控制到5人，其他15个人直接被干掉了。所以作为小弟们，别让自己闲着，多干活。\n原理：先找几个人干活，大家都忙于干活，任务太多可以排期，排期的任务太多了，再招一些人来干活，最后干活的和排期都达到上层领导要求的上限了，那需要采取一些其他策略进行处理了。对于长时间不干活的人，考虑将其开掉，节约资源和成本。\n\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue&lt;Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) &#123;\n    if (corePoolSize &lt; 0 ||\n        maximumPoolSize &lt;= 0 ||\n        maximumPoolSize &lt; corePoolSize ||\n        keepAliveTime &lt; 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.corePoolSize = corePoolSize;\n    this.maximumPoolSize = maximumPoolSize;\n    this.workQueue = workQueue;\n    this.keepAliveTime = unit.toNanos(keepAliveTime);\n    this.threadFactory = threadFactory;\n    this.handler = handler;\n&#125;\n\n\ncorePoolSize：核心线程大小，当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使有其他空闲线程可以处理任务也会创新线程，等到工作的线程数大于核心线程数时就不会在创建了。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前把核心线程都创造好，并启动\n\nmaximumPoolSize：线程池允许创建的最大线程数，此值必须大于等于1。如果队列满了，并且以创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果我们使用了无界队列，那么所有的任务会加入队列，这个参数就没有什么效果了\n\nkeepAliveTime：多余的空闲线程的存活时间,当前池中线程数量超过corePoolSize时，当空闲时间,达到keepAliveTime时，多余线程会被销毁直到只剩下corePoolSize个线程为止，如果任务很多，并且每个任务的执行时间比较短，避免线程重复创建和回收，可以调大这个时间，提高线程的利用率\n\nunit：keepAliveTIme的时间单位，可以选择的单位有天、小时、分钟、毫秒、微妙、千分之一毫秒和纳秒。类型是一个枚举java.util.concurrent.TimeUnit，这个枚举也经常使用\n\nworkQueue：任务队列，被提交但尚未被执行的任务，用于缓存待处理任务的阻塞队列\n\nthreadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程，一般默认的即可，可以通过线程工厂给每个创建出来的线程设置更有意义的名字\n\nhandler：拒绝策略，表示当队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略\n\n\n\n\n调用线程池的execute方法处理任务，执行execute方法的过程：\n\n判断线程池中运行的线程数是否小于corepoolsize，是：则创建新的线程来处理任务，否：执行下一步\n试图将任务添加到workQueue指定的队列中，如果无法添加到队列，进入下一步\n判断线程池中运行的线程数是否小于maximumPoolSize，是：则新增线程处理当前传入的任务，否：将任务传递给handler对象rejectedExecution方法处理\n\n1、在创建了线程池后，开始等待请求。\n2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断：\n  2.1如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；\n  2.2如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；\n  2.3如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；\n  2.4如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。\n3、当一个线程完成任务时，它会从队列中取下一个任务来执行。\n4、当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：\n    如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。\n    所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。\n\n5、拒绝策略？生产中如设置合理参数1、线程池的拒绝策略​\t\t等待队列已经排满了，再也塞不下新任务了，同时，线程池中的max线程也达到了，无法继续为新任务服务。这个是时候我们就需要拒绝策略机制合理的处理这个问题。\n2、JDK内置的拒绝策略AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行\nCallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。\nDiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。\nDiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略。\n以上内置拒绝策略均实现了RejectedExecutionHandle接口\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class Demo5 &#123;\n    static class Task implements Runnable &#123;\n        String name;\n        public Task(String name) &#123;\n            this.name = name;\n        &#125;\n        @Override\n        public void run() &#123;\n            System.out.println(Thread.currentThread().getName() + \"处理\" + this.name);\n            try &#123;\n                TimeUnit.SECONDS.sleep(5);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        @Override\n        public String toString() &#123;\n            return \"Task&#123;\" +\n                    \"name='\" + name + '\\'' +\n                    '&#125;';\n        &#125;\n    &#125;\n    public static void main(String[] args) &#123;\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(1,\n                1,\n                60L,\n                TimeUnit.SECONDS,\n                new ArrayBlockingQueue&lt;Runnable>(1),\n                Executors.defaultThreadFactory(),\n                (r, executors) -> &#123;\n                    //自定义饱和策略\n                    //记录一下无法处理的任务\n                    System.out.println(\"无法处理的任务：\" + r.toString());\n                &#125;);\n        for (int i = 0; i &lt; 5; i++) &#123;\n            executor.execute(new Task(\"任务-\" + i));\n        &#125;\n        executor.shutdown();\n    &#125;\n&#125;\n\n无法处理的任务：Task&#123;name='任务-2'&#125;\n无法处理的任务：Task&#123;name='任务-3'&#125;\npool-1-thread-1处理任务-0\n无法处理的任务：Task&#123;name='任务-4'&#125;\npool-1-thread-1处理任务-1\n\n输出结果中可以看到有3个任务进入了饱和策略中，记录了任务的日志，对于无法处理多任务，我们最好能够记录一下，让开发人员能够知道。任务进入了饱和策略，说明线程池的配置可能不是太合理，或者机器的性能有限，需要做一些优化调整。\n3、生产中合理的设置参数要想合理的配置线程池，需要先分析任务的特性，可以从以下几个角度分析：\n\n任务的性质：CPU密集型任务、IO密集型任务和混合型任务\n任务的优先级：高、中、低\n任务的执行时间：长、中、短\n任务的依赖性：是否依赖其他的系统资源，如数据库连接。\n\n性质不同任务可以用不同规模的线程池分开处理。CPU密集型任务应该尽可能小的线程，如配置cpu数量+1个线程的线程池。由于IO密集型任务并不是一直在执行任务，不能让cpu闲着，则应配置尽可能多的线程，如：cup数量*2。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这2个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。可以通过Runtime.getRuntime().availableProcessors()方法获取cpu数量。优先级不同任务可以对线程池采用优先级队列来处理，让优先级高的先执行。\n使用队列的时候建议使用有界队列，有界队列增加了系统的稳定性，如果采用无解队列，任务太多的时候可能导致系统OOM，直接让系统宕机。\n线程池汇总线程大小对系统的性能有一定的影响，我们的目标是希望系统能够发挥最好的性能，过多或者过小的线程数量无法有消息的使用机器的性能。咋Java Concurrency inPractice书中给出了估算线程池大小的公式：\nNcpu = CUP的数量\nUcpu = 目标CPU的使用率，0&lt;=Ucpu&lt;=1\nW/C = 等待时间与计算时间的比例\n为保存处理器达到期望的使用率，最有的线程池的大小等于：\nNthreads = Ncpu × Ucpu × (1+W/C)\n\n\nCPU密集型\n// 查看CPU核数\nSystem. out .println(Runtime. getRuntime ().availableProcessors());\n\n￼\n\nIO密集型\n\n由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如CPU核数 * 2 。\n\n\n\n\n看公司业务是CPU密集型还是IO密集型的，这两种不一样，来决定线程池线程数的最佳合理配置数。\n6、超级大坑 在工作中单一的&#x2F;固定数的&#x2F;可变的三种创建线程池的方法哪个用的多？答案是一个都不用，我们工作中只能使用自定义的\n\n7、自定义线程池import java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.*;\n\n/**\n * 线程池\n * Arrays\n * Collections\n * Executors\n */\npublic class MyThreadPoolDemo &#123;\n\n    public static void main(String[] args) &#123;\n        ExecutorService threadPool = new ThreadPoolExecutor(\n                2,\n                5,\n                2L,\n                TimeUnit.SECONDS,\n                new ArrayBlockingQueue&lt;Runnable>(3),\n                Executors.defaultThreadFactory(),\n                //new ThreadPoolExecutor.AbortPolicy()\n                //new ThreadPoolExecutor.CallerRunsPolicy()\n                //new ThreadPoolExecutor.DiscardOldestPolicy()\n                new ThreadPoolExecutor.DiscardPolicy()\n        );\n        //10个顾客请求\n        try &#123;\n            for (int i = 1; i &lt;= 10; i++) &#123;\n                threadPool.execute(() -> &#123;\n                    System.out.println(Thread.currentThread().getName() + \"\\t 办理业务\");\n                &#125;);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            threadPool.shutdown();\n        &#125;\n\n    &#125;\n\n    private static void threadPool() &#123;\n        //List list = new ArrayList();\n        //List list = Arrays.asList(\"a\",\"b\");\n        //固定数的线程池，一池五线程\n\n//       ExecutorService threadPool =  Executors.newFixedThreadPool(5); //一个银行网点，5个受理业务的窗口\n//       ExecutorService threadPool =  Executors.newSingleThreadExecutor(); //一个银行网点，1个受理业务的窗口\n        ExecutorService threadPool = Executors.newCachedThreadPool(); //一个银行网点，可扩展受理业务的窗口\n\n        //10个顾客请求\n        try &#123;\n            for (int i = 1; i &lt;= 10; i++) &#123;\n                threadPool.execute(() -> &#123;\n                    System.out.println(Thread.currentThread().getName() + \"\\t 办理业务\");\n                &#125;);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            threadPool.shutdown();\n        &#125;\n    &#125;\n&#125;\n\n8、线程池中的2个关闭方法线程池提供了2个关闭方法：shutdown和shutdownNow，当调用者两个方法之后，线程池会遍历内部的工作线程，然后调用每个工作线程的interrrupt方法给线程发送中断信号，内部如果无法响应中断信号的可能永远无法终止，所以如果内部有无线循环的，最好在循环内部检测一下线程的中断信号，合理的退出。调用者两个方法中任意一个，线程池的isShutdown方法就会返回true，当所有的任务线程都关闭之后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。\n调用shutdown方法之后，线程池将不再接口新任务，内部会将所有已提交的任务处理完毕，处理完毕之后，工作线程自动退出。\n而调用shutdownNow方法后，线程池会将还未处理的（在队里等待处理的任务）任务移除，将正在处理中的处理完毕之后，工作线程自动退出。\n至于调用哪个方法来关闭线程，应该由提交到线程池的任务特性决定，多数情况下调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。\n9、BlockingQueue阻塞队列1、栈与队列栈：先进后出，后进先出\n队列：先进先出\n2、阻塞队列阻塞：必须要阻塞&#x2F;不得不阻塞 \n\n线程1往阻塞队列里添加元素，线程2从阻塞队列里移除元素\n当队列是空的，从队列中获取元素的操作将会被阻塞\n当队列是满的，从队列中添加元素的操作将会被阻塞\n试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素\n试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增\n\n3、种类分析ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按照先进先出原则对元素进行排序\nLinkedBlockingQueue：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列，此队列按照先进先出排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool使用了这个队列。\nPriorityBlockingQueue：支持优先级排序的无界阻塞队列。\nDelayQueue：使用优先级队列实现的延迟无界阻塞队列。\nSynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列,每个插入操作必须等到另外一个线程调用移除操作，否则插入操作一直处理阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用这个队列\nLinkedTransferQueue：由链表组成的无界阻塞队列。\nLinkedBlockingDeque：由链表组成的双向阻塞队列。\nimport java.util.concurrent.*;\n\npublic class Demo2 &#123;\n    public static void main(String[] args) &#123;\n        ExecutorService executor = Executors.newCachedThreadPool();\n        for (int i = 0; i &lt; 50; i++) &#123;\n            int j = i;\n            String taskName = \"任务\" + j;\n            executor.execute(() -> &#123;\n                System.out.println(Thread.currentThread().getName() + \"处理\" + taskName);\n                //模拟任务内部处理耗时\n                try &#123;\n                    TimeUnit.SECONDS.sleep(1);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;);\n        &#125;\n        executor.shutdown();\n    &#125;\n&#125;\n\n代码中使用Executors.newCachedThreadPool()创建线程池，看一下的源码：\npublic static ExecutorService newCachedThreadPool() &#123;\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue&lt;Runnable>());\n    &#125;\n\n从输出中可以看出，系统创建了50个线程处理任务，代码中使用了SynchronousQueue同步队列，这种队列比较特殊，放入元素必须要有另外一个线程去获取这个元素，否则放入元素会失败或者一直阻塞在那里直到有线程取走，示例中任务处理休眠了指定的时间，导致已创建的工作线程都忙于处理任务，所以新来任务之后，将任务丢入同步队列会失败，丢入队列失败之后，会尝试新建线程处理任务。使用上面的方式创建线程池需要注意，如果需要处理的任务比较耗时，会导致新来的任务都会创建新的线程进行处理，可能会导致创建非常多的线程，最终耗尽系统资源，触发OOM。\nPriorityBlockingQueue优先级队列的线程池\nimport java.util.concurrent.*;\n\npublic class Demo3 &#123;\n    static class Task implements Runnable, Comparable&lt;Task> &#123;\n        private int i;\n        private String name;\n        public Task(int i, String name) &#123;\n            this.i = i;\n            this.name = name;\n        &#125;\n        @Override\n        public void run() &#123;\n            System.out.println(Thread.currentThread().getName() + \"处理\" + this.name);\n        &#125;\n        @Override\n        public int compareTo(Task o) &#123;\n            return Integer.compare(o.i, this.i);\n        &#125;\n    &#125;\n    public static void main(String[] args) &#123;\n        ExecutorService executor = new ThreadPoolExecutor(1, 1,\n                60L, TimeUnit.SECONDS,\n                new PriorityBlockingQueue());\n        for (int i = 0; i &lt; 10; i++) &#123;\n            String taskName = \"任务\" + i;\n            executor.execute(new Task(i, taskName));\n        &#125;\n        for (int i = 100; i >= 90; i--) &#123;\n            String taskName = \"任务\" + i;\n            executor.execute(new Task(i, taskName));\n        &#125;\n        executor.shutdown();\n    &#125;\n&#125;\n\n输出中，除了第一个任务，其他任务按照优先级高低按顺序处理。原因在于：创建线程池的时候使用了优先级队列，进入队列中的任务会进行排序，任务的先后顺序由Task中的i变量决定。向PriorityBlockingQueue加入元素的时候，内部会调用代码中Task的compareTo方法决定元素的先后顺序。\n4、BlockingQueue核心方法\n\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 阻塞队列\n */\npublic class BlockingQueueDemo &#123;\n\n    public static void main(String[] args) throws InterruptedException &#123;\n\n//        List list = new ArrayList();\n\n        BlockingQueue&lt;String> blockingQueue = new ArrayBlockingQueue&lt;>(3);\n        //第一组\n//        System.out.println(blockingQueue.add(\"a\"));\n//        System.out.println(blockingQueue.add(\"b\"));\n//        System.out.println(blockingQueue.add(\"c\"));\n//        System.out.println(blockingQueue.element());\n\n        //System.out.println(blockingQueue.add(\"x\"));\n//        System.out.println(blockingQueue.remove());\n//        System.out.println(blockingQueue.remove());\n//        System.out.println(blockingQueue.remove());\n//        System.out.println(blockingQueue.remove());\n//    第二组\n//        System.out.println(blockingQueue.offer(\"a\"));\n//        System.out.println(blockingQueue.offer(\"b\"));\n//        System.out.println(blockingQueue.offer(\"c\"));\n//        System.out.println(blockingQueue.offer(\"x\"));\n//        System.out.println(blockingQueue.poll());\n//        System.out.println(blockingQueue.poll());\n//        System.out.println(blockingQueue.poll());\n//        System.out.println(blockingQueue.poll());\n//    第三组        \n//         blockingQueue.put(\"a\");\n//         blockingQueue.put(\"b\");\n//         blockingQueue.put(\"c\");\n//         //blockingQueue.put(\"x\");\n//        System.out.println(blockingQueue.take());\n//        System.out.println(blockingQueue.take());\n//        System.out.println(blockingQueue.take());\n//        System.out.println(blockingQueue.take());\n        \n//    第四组        \n        System.out.println(blockingQueue.offer(\"a\"));\n        System.out.println(blockingQueue.offer(\"b\"));\n        System.out.println(blockingQueue.offer(\"c\"));\n        System.out.println(blockingQueue.offer(\"a\",3L, TimeUnit.SECONDS));\n\n    &#125;\n&#125;\n\n10、扩展线程池虽然jdk提供了ThreadPoolExecutor这个高性能线程池，但是如果我们自己想在这个线程池上面做一些扩展，比如，监控每个任务执行的开始时间，结束时间，或者一些其他自定义的功能，我们应该怎么办？\n这个jdk已经帮我们想到了，ThreadPoolExecutor内部提供了几个方法beforeExecute、afterExecute、terminated，可以由开发人员自己去这些方法。看一下线程池内部的源码：\ntry &#123;\n    beforeExecute(wt, task);//任务执行之前调用的方法\n    Throwable thrown = null;\n    try &#123;\n        task.run();\n    &#125; catch (RuntimeException x) &#123;\n        thrown = x;\n        throw x;\n    &#125; catch (Error x) &#123;\n        thrown = x;\n        throw x;\n    &#125; catch (Throwable x) &#123;\n        thrown = x;\n        throw new Error(x);\n    &#125; finally &#123;\n        afterExecute(task, thrown);//任务执行完毕之后调用的方法\n    &#125;\n&#125; finally &#123;\n    task = null;\n    w.completedTasks++;\n    w.unlock();\n&#125;\n\nbeforeExecute：任务执行之前调用的方法，有2个参数，第1个参数是执行任务的线程，第2个参数是任务\nprotected void beforeExecute(Thread t, Runnable r) &#123; &#125;\n\nafterExecute：任务执行完成之后调用的方法，2个参数，第1个参数表示任务，第2个参数表示任务执行时的异常信息，如果无异常，第二个参数为null\nprotected void afterExecute(Runnable r, Throwable t) &#123; &#125;\n\nterminated：线程池最终关闭之后调用的方法。所有的工作线程都退出了，最终线程池会退出，退出时调用该方法\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class Demo6 &#123;\n    static class Task implements Runnable &#123;\n        String name;\n        public Task(String name) &#123;\n            this.name = name;\n        &#125;\n        @Override\n        public void run() &#123;\n            System.out.println(Thread.currentThread().getName() + \"处理\" + this.name);\n            try &#123;\n                TimeUnit.SECONDS.sleep(2);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        @Override\n        public String toString() &#123;\n            return \"Task&#123;\" +\n                    \"name='\" + name + '\\'' +\n                    '&#125;';\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(10,\n                10,\n                60L,\n                TimeUnit.SECONDS,\n                new ArrayBlockingQueue&lt;Runnable>(1),\n                Executors.defaultThreadFactory(),\n                (r, executors) -> &#123;\n                    //自定义饱和策略\n                    //记录一下无法处理的任务\n                    System.out.println(\"无法处理的任务：\" + r.toString());\n                &#125;) &#123;\n            @Override\n            protected void beforeExecute(Thread t, Runnable r) &#123;\n                System.out.println(System.currentTimeMillis() + \",\" + t.getName() + \",开始执行任务:\" + r.toString());\n            &#125;\n            @Override\n            protected void afterExecute(Runnable r, Throwable t) &#123;\n                System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \",任务:\" + r.toString() + \"，执行完毕!\");\n            &#125;\n            @Override\n            protected void terminated() &#123;\n                System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \"，关闭线程池!\");\n            &#125;\n        &#125;;\n        for (int i = 0; i &lt; 10; i++) &#123;\n            executor.execute(new Task(\"任务-\" + i));\n        &#125;\n        TimeUnit.SECONDS.sleep(1);\n        executor.shutdown();\n    &#125;\n&#125;\n\n1564324574847,pool-1-thread-1,开始执行任务:Task&#123;name='任务-0'&#125;\n1564324574850,pool-1-thread-3,开始执行任务:Task&#123;name='任务-2'&#125;\npool-1-thread-3处理任务-2\n1564324574849,pool-1-thread-2,开始执行任务:Task&#123;name='任务-1'&#125;\npool-1-thread-2处理任务-1\n1564324574848,pool-1-thread-5,开始执行任务:Task&#123;name='任务-4'&#125;\npool-1-thread-5处理任务-4\n1564324574848,pool-1-thread-4,开始执行任务:Task&#123;name='任务-3'&#125;\npool-1-thread-4处理任务-3\n1564324574850,pool-1-thread-7,开始执行任务:Task&#123;name='任务-6'&#125;\npool-1-thread-7处理任务-6\n1564324574850,pool-1-thread-6,开始执行任务:Task&#123;name='任务-5'&#125;\n1564324574851,pool-1-thread-8,开始执行任务:Task&#123;name='任务-7'&#125;\npool-1-thread-8处理任务-7\npool-1-thread-1处理任务-0\npool-1-thread-6处理任务-5\n1564324574851,pool-1-thread-10,开始执行任务:Task&#123;name='任务-9'&#125;\npool-1-thread-10处理任务-9\n1564324574852,pool-1-thread-9,开始执行任务:Task&#123;name='任务-8'&#125;\npool-1-thread-9处理任务-8\n1564324576851,pool-1-thread-2,任务:Task&#123;name='任务-1'&#125;，执行完毕!\n1564324576851,pool-1-thread-3,任务:Task&#123;name='任务-2'&#125;，执行完毕!\n1564324576852,pool-1-thread-1,任务:Task&#123;name='任务-0'&#125;，执行完毕!\n1564324576852,pool-1-thread-4,任务:Task&#123;name='任务-3'&#125;，执行完毕!\n1564324576852,pool-1-thread-8,任务:Task&#123;name='任务-7'&#125;，执行完毕!\n1564324576852,pool-1-thread-7,任务:Task&#123;name='任务-6'&#125;，执行完毕!\n1564324576852,pool-1-thread-5,任务:Task&#123;name='任务-4'&#125;，执行完毕!\n1564324576853,pool-1-thread-6,任务:Task&#123;name='任务-5'&#125;，执行完毕!\n1564324576853,pool-1-thread-10,任务:Task&#123;name='任务-9'&#125;，执行完毕!\n1564324576853,pool-1-thread-9,任务:Task&#123;name='任务-8'&#125;，执行完毕!\n1564324576853,pool-1-thread-9，关闭线程池!\n\n从输出结果中可以看到，每个需要执行的任务打印了3行日志，执行前由线程池的beforeExecute打印，执行时会调用任务的run方法，任务执行完毕之后，会调用线程池的afterExecute方法，从每个任务的首尾2条日志中可以看到每个任务耗时2秒左右。线程池最终关闭之后调用了terminated方法。\n三、CompletableFuture1、Future和Callable接口Future接口定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。\n\nCallable接口中定义了需要有返回的任务需要实现的方法\n比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，过了一会才去获取子任务的执行结果。\n2、从之前的FutureTask开始Future接口相关架构\n\n\ncode1public class CompletableFutureDemo&#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException&#123;\n        FutureTask&lt;String> futureTask = new FutureTask&lt;>(() -> &#123;\n            System.out.println(\"-----come in FutureTask\");\n            try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            return ThreadLocalRandom.current().nextInt(100);\n        &#125;);\n\n        Thread t1 = new Thread(futureTask,\"t1\");\n        t1.start();\n\n        //3秒钟后才出来结果，还没有计算你提前来拿(只要一调用get方法，对于结果就是不见不散，会导致阻塞)\n        //System.out.println(Thread.currentThread().getName()+\"\\t\"+futureTask.get());\n\n        //3秒钟后才出来结果，我只想等待1秒钟，过时不候\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+futureTask.get(1L,TimeUnit.SECONDS));\n\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\" run... here\");\n\n    &#125;\n&#125;\n\n\nget()阻塞   一旦调用get()方法，不管是否计算完成都会导致阻塞\n\ncode2public class CompletableFutureDemo2 &#123;\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        FutureTask&lt;String> futureTask = new FutureTask&lt;>(() -> &#123;\n            System.out.println(\"-----come in FutureTask\");\n            try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            return \"\"+ ThreadLocalRandom.current().nextInt(100);\n        &#125;);\n\n        new Thread(futureTask,\"t1\").start();\n\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\"线程完成任务\");\n\n        /**\n         * 用于阻塞式获取结果,如果想要异步获取结果,通常都会以轮询的方式去获取结果\n         */\n        while (true)&#123;\n            if(futureTask.isDone())&#123;\n                System.out.println(futureTask.get());\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nisDone()轮询\n轮询的方式会耗费无谓的CPU资源，而且也不见得能及时地得到计算结果.\n如果想要异步获取结果,通常都会以轮询的方式去获取结果尽量不要阻塞\n不见不散 – 过时不候 – 轮询\n3、对Future的改进1、类CompletableFuture\n\n\n2、接口CompletionStage\n代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段，有些类似Linux系统的管道分隔符传参数。\n4、核心的四个静态方法1、runAsync 无 返回值public static CompletableFuture&lt;Void> runAsync(Runnable runnable)\npublic static CompletableFuture&lt;Void> runAsync(Runnable runnable,Executor executor)  \n\n2、supplyAsync 有 返回值public static &lt;U> CompletableFuture&lt;U> supplyAsync(Supplier&lt;U> supplier)\npublic static &lt;U> CompletableFuture&lt;U> supplyAsync(Supplier&lt;U> supplier,Executor executor)\n\n上述Executor executor参数说明\n没有指定Executor的方法，直接使用默认的ForkJoinPool.commonPool() 作为它的线程池执行异步代码。\n如果指定线程池，则使用我们自定义的或者特别指定的线程池执行异步代码\n3、Code 无 返回值public class CompletableFutureDemo3&#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException&#123;\n        CompletableFuture&lt;Void> future = CompletableFuture.runAsync(() -> &#123;\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\"-----come in\");\n            //暂停几秒钟线程\n            try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            System.out.println(\"-----task is over\");\n        &#125;);\n        System.out.println(future.get());\n    &#125;\n&#125;\n\n\n4、Code 有 返回值public class CompletableFutureDemo3&#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException&#123;\n        CompletableFuture&lt;Integer> completableFuture = CompletableFuture.supplyAsync(() -> &#123;\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + \"-----come in\");\n            //暂停几秒钟线程\n            try &#123;\n                TimeUnit.SECONDS.sleep(1);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            return ThreadLocalRandom.current().nextInt(100);\n        &#125;);\n\n        System.out.println(completableFuture.get());\n    &#125;\n&#125;\n\n5、Code 减少阻塞和轮询从Java8开始引入了CompletableFuture，它是Future的功能增强版，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法\npublic class CompletableFutureDemo3&#123;\n    public static void main(String[] args) throws Exception&#123;\n        CompletableFuture&lt;Integer> completableFuture = CompletableFuture.supplyAsync(() -> &#123;\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + \"-----come in\");\n            int result = ThreadLocalRandom.current().nextInt(10);\n            //暂停几秒钟线程\n            try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            System.out.println(\"-----计算结束耗时1秒钟，result： \"+result);\n            if(result > 6)&#123;\n                int age = 10/0;\n            &#125;\n            return result;\n        &#125;).whenComplete((v,e) ->&#123;\n            if(e == null)&#123;\n                System.out.println(\"-----result: \"+v);\n            &#125;\n        &#125;).exceptionally(e -> &#123;\n            System.out.println(\"-----exception: \"+e.getCause()+\"\\t\"+e.getMessage());\n            return -44;\n        &#125;);\n\n        //主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:暂停3秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n    &#125;\n&#125;\n\n\n6、CompletableFuture的优点异步任务结束时，会自动回调某个对象的方法；\n异步任务出错时，会自动回调某个对象的方法；\n主线程设置好回调后，不再关心异步任务的执行，异步任务之间可以顺序执行\n5、join和get对比get会抛出异常，join不需要\n6、案例精讲-从电商网站的比价需求说开去切记，功能→性能\n​\t\t经常出现在等待某条 SQL 执行完成后，再继续执行下一条 SQL ，而这两条 SQL 本身是并无关系的，可以同时进行执行的。我们希望能够两条 SQL 同时进行处理，而不是等待其中的某一条 SQL 完成后，再继续下一条。同理，对于分布式微服务的调用，按照实际业务，如果是无关联step by step的业务，可以尝试是否可以多箭齐发，同时调用。我们去比同一个商品在各个平台上的价格，要求获得一个清单列表，1 step by step，查完京东查淘宝，查完淘宝查天猫……\n2 all   一口气同时查询。。。。。\nimport lombok.Getter;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\n\npublic class T1&#123;\n    static List&lt;NetMall> list = Arrays.asList(\n            new NetMall(\"jd\"),\n            new NetMall(\"tmall\"),\n            new NetMall(\"pdd\"),\n            new NetMall(\"mi\")\n    );\n\n    public static List&lt;String> findPriceSync(List&lt;NetMall> list,String productName)&#123;\n        return list.stream().map(mall -> String.format(productName+\" %s price is %.2f\",mall.getNetMallName(),mall.getPriceByName(productName))).collect(Collectors.toList());\n    &#125;\n\n    public static List&lt;String> findPriceASync(List&lt;NetMall> list,String productName)&#123;\n        return list.stream().map(mall -> CompletableFuture.supplyAsync(() -> String.format(productName + \" %s price is %.2f\", mall.getNetMallName(), mall.getPriceByName(productName)))).collect(Collectors.toList()).stream().map(CompletableFuture::join).collect(Collectors.toList());\n    &#125;\n\n\n    public static void main(String[] args)&#123;\n        long startTime = System.currentTimeMillis();\n        List&lt;String> list1 = findPriceSync(list, \"thinking in java\");\n        for (String element : list1) &#123;\n            System.out.println(element);\n        &#125;\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"----costTime: \"+(endTime - startTime) +\" 毫秒\");\n\n        long startTime2 = System.currentTimeMillis();\n        List&lt;String> list2 = findPriceASync(list, \"thinking in java\");\n        for (String element : list2) &#123;\n            System.out.println(element);\n        &#125;\n        long endTime2 = System.currentTimeMillis();\n        System.out.println(\"----costTime: \"+(endTime2 - startTime2) +\" 毫秒\");\n    &#125;\n&#125;\n\nclass NetMall&#123;\n    @Getter\n    private String netMallName;\n\n    public NetMall(String netMallName)&#123;\n        this.netMallName = netMallName;\n    &#125;\n\n    public double getPriceByName(String productName)&#123;\n        return calcPrice(productName);\n    &#125;\n\n    private double calcPrice(String productName)&#123;\n        try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n        return ThreadLocalRandom.current().nextDouble() + productName.charAt(0);\n    &#125;\n&#125;\n\n7、CompletableFuture常用方法1、获得结果和触发计算获取结果\n// 不见不散\npublic T get()\n    \n// 过时不候\npublic T get(long timeout, TimeUnit unit)\n    \n// 没有计算完成的情况下，给我一个替代结果 \n// 立即获取结果不阻塞 计算完，返回计算完成后的结果  没算完，返回设定的valueIfAbsent值\npublic T getNow(T valueIfAbsent)\n  \npublic class CompletableFutureDemo2&#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException&#123;\n        CompletableFuture&lt;Integer> completableFuture = CompletableFuture.supplyAsync(() -> &#123;\n            try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            return 533;\n        &#125;);\n\n        //去掉注释上面计算没有完成，返回444\n        //开启注释上满计算完成，返回计算结果\n        try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        System.out.println(completableFuture.getNow(444));\n    &#125;\n&#125;\n\npublic T join()\npublic class CompletableFutureDemo2&#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException&#123;\n        System.out.println(CompletableFuture.supplyAsync(() -> \"abc\").thenApply(r -> r + \"123\").join());\n    &#125;\n&#125;   \n\n主动触发计算\n// 是否打断get方法立即返回括号值\npublic boolean complete(T value)\n  \npublic class CompletableFutureDemo4&#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException&#123;\n        CompletableFuture&lt;Integer> completableFuture = CompletableFuture.supplyAsync(() -> &#123;\n            try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            return 533;\n        &#125;);\n\n        //注释掉暂停线程，get还没有算完只能返回complete方法设置的444；暂停2秒钟线程，异步线程能够计算完成返回get\n        try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        //当调用CompletableFuture.get()被阻塞的时候,complete方法就是结束阻塞并get()获取设置的complete里面的值.\n        System.out.println(completableFuture.complete(444)+\"\\t\"+completableFuture.get());\n    &#125;\n&#125;   \n\n2、对计算结果进行处理thenApply\n// 计算结果存在依赖关系，这两个线程串行化\n// 由于存在依赖关系(当前步错，不走下一步)，当前步骤有异常的话就叫停。\npublic class CompletableFutureDemo4&#123;\n\tpublic static void main(String[] args) throws ExecutionException, InterruptedException&#123;\n        //当一个线程依赖另一个线程时用 thenApply 方法来把这两个线程串行化,\n        CompletableFuture.supplyAsync(() -> &#123;\n            //暂停几秒钟线程\n            try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            System.out.println(\"111\");\n            return 1024;\n        &#125;).thenApply(f -> &#123;\n            System.out.println(\"222\");\n            return f + 1;\n        &#125;).thenApply(f -> &#123;\n            //int age = 10/0; // 异常情况：那步出错就停在那步。\n            System.out.println(\"333\");\n            return f + 1;\n        &#125;).whenCompleteAsync((v,e) -> &#123;\n            System.out.println(\"*****v: \"+v);\n        &#125;).exceptionally(e -> &#123;\n            e.printStackTrace();\n            return null;\n        &#125;);\n\n    \tSystem.out.println(\"-----主线程结束，END\");\n\n        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:\n        try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\t&#125;   \n&#125;  \n\nhandle\n// 有异常也可以往下一步走，根据带的异常参数可以进一步处理\npublic class CompletableFutureDemo4&#123;\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException&#123;\n        //当一个线程依赖另一个线程时用 handle 方法来把这两个线程串行化,\n        // 异常情况：有异常也可以往下一步走，根据带的异常参数可以进一步处理\n        CompletableFuture.supplyAsync(() -> &#123;\n            //暂停几秒钟线程\n            try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            System.out.println(\"111\");\n            return 1024;\n        &#125;).handle((f,e) -> &#123;\n            int age = 10/0;\n            System.out.println(\"222\");\n            return f + 1;\n        &#125;).handle((f,e) -> &#123;\n            System.out.println(\"333\");\n            return f + 1;\n        &#125;).whenCompleteAsync((v,e) -> &#123;\n            System.out.println(\"*****v: \"+v);\n        &#125;).exceptionally(e -> &#123;\n            e.printStackTrace();\n            return null;\n        &#125;);\n\n        System.out.println(\"-----主线程结束，END\");\n\n        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:\n        try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n    &#125;\n&#125;   \n\n\n\n3、对计算结果进行消费接收任务的处理结果，并消费处理，无返回结果\n//thenAccept\npublic static void main(String[] args) throws ExecutionException, InterruptedException&#123;\n    CompletableFuture.supplyAsync(() -> &#123;\n        return 1;\n    &#125;).thenApply(f -> &#123;\n        return f + 2;\n    &#125;).thenApply(f -> &#123;\n        return f + 3;\n    &#125;).thenApply(f -> &#123;\n        return f + 4;\n    &#125;).thenAccept(r -> System.out.println(r));\n&#125;  \n\nCode之任务之间的顺序执行\nthenRun\nthenRun(Runnable runnable)\n// 任务 A 执行完执行 B，并且 B 不需要 A 的结果\n    \nthenAccept\nthenAccept(Consumer action)\n// 任务 A 执行完执行 B，B 需要 A 的结果，但是任务 B 无返回值\n  \nthenApply\nthenApply(Function fn)\n// 任务 A 执行完执行 B，B 需要 A 的结果，同时任务 B 有返回值\n \nSystem.out.println(CompletableFuture.supplyAsync(() -> \"resultA\").thenRun(() -> &#123;&#125;).join());\nSystem.out.println(CompletableFuture.supplyAsync(() -> \"resultA\").thenAccept(resultA -> &#123;&#125;).join());\nSystem.out.println(CompletableFuture.supplyAsync(() -> \"resultA\").thenApply(resultA -> resultA + \" resultB\").join());\n\n4、对计算速度进行选用谁快用谁\napplyToEither\npublic class CompletableFutureDemo5&#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException&#123;\n        CompletableFuture&lt;Integer> completableFuture1 = CompletableFuture.supplyAsync(() -> &#123;\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in \");\n            //暂停几秒钟线程\n            try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            return 10;\n        &#125;);\n\n        CompletableFuture&lt;Integer> completableFuture2 = CompletableFuture.supplyAsync(() -> &#123;\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in \");\n            try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            return 20;\n        &#125;);\n\n        CompletableFuture&lt;Integer> thenCombineResult = completableFuture1.applyToEither(completableFuture2,f -> &#123;\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in \");\n            return f + 1;\n        &#125;);\n\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + thenCombineResult.get());\n    &#125;\n&#125;\n\n5、对计算结果进行合并两个CompletionStage任务都完成后，最终能把两个任务的结果一起交给thenCombine 来处理\n先完成的先等着，等待其它分支任务\nthenCombine\ncode标准版，好理解先拆分\npublic class CompletableFutureDemo2&#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException&#123;\n        CompletableFuture&lt;Integer> completableFuture1 = CompletableFuture.supplyAsync(() -> &#123;\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in \");\n            return 10;\n        &#125;);\n\n        CompletableFuture&lt;Integer> completableFuture2 = CompletableFuture.supplyAsync(() -> &#123;\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in \");\n            return 20;\n        &#125;);\n\n        CompletableFuture&lt;Integer> thenCombineResult = completableFuture1.thenCombine(completableFuture2, (x, y) -> &#123;\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in \");\n            return x + y;\n        &#125;);\n        \n        System.out.println(thenCombineResult.get());\n    &#125;\n&#125;\n\ncode表达式\npublic class CompletableFutureDemo6&#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException&#123;\n        CompletableFuture&lt;Integer> thenCombineResult = CompletableFuture.supplyAsync(() -> &#123;\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in 1\");\n            return 10;\n        &#125;).thenCombine(CompletableFuture.supplyAsync(() -> &#123;\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in 2\");\n            return 20;\n        &#125;), (x,y) -> &#123;\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in 3\");\n            return x + y;\n        &#125;).thenCombine(CompletableFuture.supplyAsync(() -> &#123;\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in 4\");\n            return 30;\n        &#125;),(a,b) -> &#123;\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + \"---come in 5\");\n            return a + b;\n        &#125;);\n        System.out.println(\"-----主线程结束，END\");\n        System.out.println(thenCombineResult.get());\n\n\n        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:\n        try &#123; TimeUnit.SECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n    &#125;\n&#125;\n\n8、分支合并框架Fork：把一个复杂任务进行分拆，大事化小\nJoin：把分拆任务的结果进行合并\n\n1、相关类1、ForkJoinPool\n2、ForkJoinTask\n3、RecursiveTask\n// 递归任务：继承后可以实现递归(自己调自己)调用的任务\n class Fibonacci extends RecursiveTask&lt;Integer> &#123;\n   final int n;\n   Fibonacci(int n) &#123; this.n = n; &#125;\n   Integer compute() &#123;\n     if (n &lt;= 1)\n       return n;\n     Fibonacci f1 = new Fibonacci(n - 1);\n     f1.fork();\n     Fibonacci f2 = new Fibonacci(n - 2);\n     return f2.compute() + f1.join();\n   &#125;\n &#125;\n\n2、示例import java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ForkJoinTask;\nimport java.util.concurrent.RecursiveTask;\n\nclass MyTask extends RecursiveTask&lt;Integer>&#123;\n    private static final Integer ADJUST_VALUE = 10;\n    private int begin;\n    private int end;\n    private int result;\n\n    public MyTask(int begin, int end) &#123;\n        this.begin = begin;\n        this.end = end;\n    &#125;\n\n    @Override\n    protected Integer compute() &#123;\n        if((end - begin)&lt;=ADJUST_VALUE)&#123;\n           for(int i =begin;i &lt;= end;i++)&#123;\n                result = result + i;\n           &#125;\n        &#125;else&#123;\n            int middle = (begin + end)/2;\n            MyTask task01 = new MyTask(begin,middle);\n            MyTask task02 = new MyTask(middle+1,end);\n            task01.fork();\n            task02.fork();\n            result =  task01.join() + task02.join();\n        &#125;\n\n\n        return result;\n    &#125;\n&#125;\n\n\n/**\n * 分支合并例子\n * ForkJoinPool\n * ForkJoinTask\n * RecursiveTask\n */\npublic class ForkJoinDemo &#123;\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n\n        MyTask myTask = new MyTask(0,100);\n        ForkJoinPool forkJoinPool = new ForkJoinPool();\n        ForkJoinTask&lt;Integer> forkJoinTask = forkJoinPool.submit(myTask);\n\n        System.out.println(forkJoinTask.get());\n\n        forkJoinPool.shutdown();\n    &#125;\n&#125;\n\n\n\n\n\n四、Java“锁”事1、Lock\n// Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more flexible structuring, may have quite different properties, and may support multiple associated Condition objects.\n\n// 锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象\n\n2、synchronized与Lock的区别\n首先synchronized是java内置关键字，在jvm层面，Lock是个java类；\nsynchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；\nsynchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；\n用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；\nsynchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）\nLock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。\n\n3、synchronized\n修饰实例方法，作用于当前实例，进入同步代码前需要先获取实例的锁\n修饰静态方法，作用于类的Class对象，进入修饰的静态方法前需要先获取类的Class对象的锁\n修饰代码块，需要指定加锁对象(记做lockobj)，在进入同步代码块前需要先获取lockobj的锁\n\n1、synchronized作用于实例对象所谓实例对象锁就是用synchronized修饰实例对象的实例方法，注意是实例方法，不是静态方法，如：\npublic class Demo2 &#123;\n    int num = 0;\n    public synchronized void add() &#123;\n        num++;\n    &#125;\n    public static class T extends Thread &#123;\n        private Demo2 demo2;\n        public T(Demo2 demo2) &#123;\n            this.demo2 = demo2;\n        &#125;\n        @Override\n        public void run() &#123;\n            for (int i = 0; i &lt; 10000; i++) &#123;\n                this.demo2.add();\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        Demo2 demo2 = new Demo2();\n        T t1 = new T(demo2);\n        T t2 = new T(demo2);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        System.out.println(demo2.num);\n    &#125;\n&#125;\n\nmain()方法中创建了一个对象demo2和2个线程t1、t2，t1、t2中调用demo2的add()方法10000次，add()方法中执行了num++，num++实际上是分3步，获取num，然后将num+1，然后将结果赋值给num，如果t2在t1读取num和num+1之间获取了num的值，那么t1和t2会读取到同样的值，然后执行num++，两次操作之后num是相同的值，最终和期望的结果不一致，造成了线程安全失败，因此我们对add方法加了synchronized来保证线程安全。\n注意：m1()方法是实例方法，两个线程操作m1()时，需要先获取demo2的锁，没有获取到锁的，将等待，直到其他线程释放锁为止。\nsynchronize作用于实例方法需要注意：\n\n实例方法上加synchronized，线程安全的前提是，多个线程操作的是同一个实例，如果多个线程作用于不同的实例，那么线程安全是无法保证的\n同一个实例的多个实例方法上有synchronized，这些方法都是互斥的，同一时间只允许一个线程操作同一个实例的其中的一个synchronized方法\n\n2、synchronized作用于静态方法当synchronized作用于静态方法时，锁的对象就是当前类的Class对象。如：\npublic class Demo3 &#123;\n    static int num = 0;\n    public static synchronized void m1() &#123;\n        for (int i = 0; i &lt; 10000; i++) &#123;\n            num++;\n        &#125;\n    &#125;\n    public static class T1 extends Thread &#123;\n        @Override\n        public void run() &#123;\n            Demo3.m1();\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        T1 t1 = new T1();\n        T1 t2 = new T1();\n        T1 t3 = new T1();\n        t1.start();\n        t2.start();\n        t3.start();\n        //等待3个线程结束打印num\n        t1.join();\n        t2.join();\n        t3.join();\n        System.out.println(Demo3.num);\n        /**\n         * 打印结果：\n         * 30000\n         */\n    &#125;\n&#125;\n\n上面代码打印30000，和期望结果一致。m1()方法是静态方法，有synchronized修饰，锁用于与Demo3.class对象，和下面的写法类似：\npublic static void m1() &#123;\n    synchronized (Demo4.class) &#123;\n        for (int i = 0; i &lt; 10000; i++) &#123;\n            num++;\n        &#125;\n    &#125;\n&#125;\n\n3、synchronized同步代码块除了使用关键字修饰实例方法和静态方法外，还可以使用同步代码块，在某些情况下，我们编写的方法体可能比较大，同时存在一些比较耗时的操作，而需要同步的代码又只有一小部分，如果直接对整个方法进行同步操作，可能会得不偿失，此时我们可以使用同步代码块的方式对需要同步的代码进行包裹，这样就无需对整个方法进行同步操作了，同步代码块的使用示例如下：\npublic class Demo5 implements Runnable &#123;\n    static Demo5 instance = new Demo5();\n    static int i = 0;\n    @Override\n    public void run() &#123;\n        //省略其他耗时操作....\n        //使用同步代码块对变量i进行同步操作,锁对象为instance\n        synchronized (instance) &#123;\n            for (int j = 0; j &lt; 10000; j++) &#123;\n                i++;\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        Thread t1 = new Thread(instance);\n        Thread t2 = new Thread(instance);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        System.out.println(i);\n    &#125;\n&#125;\n\n从代码看出，将synchronized作用于一个给定的实例对象instance，即当前实例对象就是锁对象，每次当线程进入synchronized包裹的代码块时就会要求当前线程持有instance实例对象锁，如果当前有其他线程正持有该对象锁，那么新到的线程就必须等待，这样也就保证了每次只有一个线程执行i++;操作。当然除了instance作为对象外，我们还可以使用this对象(代表当前实例)或者当前类的class对象作为锁，如下代码：\n//this,当前实例对象锁\nsynchronized(this)&#123;\n    for(int j=0;j&lt;1000000;j++)&#123;\n        i++;\n    &#125;\n&#125;\n//class对象锁\nsynchronized(Demo5.class)&#123;\n    for(int j=0;j&lt;1000000;j++)&#123;\n        i++;\n    &#125;\n&#125;\n\n分析代码是否互斥的方法，先找出synchronized作用的对象是谁，如果多个线程操作的方法中synchronized作用的锁对象一样，那么这些线程同时异步执行这些方法就是互斥的。如下代码:\npublic class Demo6 &#123;\n    //作用于当前类的实例对象\n    public synchronized void m1() &#123;\n    &#125;\n    //作用于当前类的实例对象\n    public synchronized void m2() &#123;\n    &#125;\n    //作用于当前类的实例对象\n    public void m3() &#123;\n        synchronized (this) &#123;\n        &#125;\n    &#125;\n    //作用于当前类Class对象\n    public static synchronized void m4() &#123;\n    &#125;\n    //作用于当前类Class对象\n    public static void m5() &#123;\n        synchronized (Demo6.class) &#123;\n        &#125;\n    &#125;\n    public static class T extends Thread&#123;\n        Demo6 demo6;\n        public T(Demo6 demo6) &#123;\n            this.demo6 = demo6;\n        &#125;\n        @Override\n        public void run() &#123;\n            super.run();\n        &#125;\n    &#125;\n    public static void main(String[] args) &#123;\n        Demo6 d1 = new Demo6();\n        Thread t1 = new Thread(() -> &#123;\n            d1.m1();\n        &#125;);\n        t1.start();\n        Thread t2 = new Thread(() -> &#123;\n            d1.m2();\n        &#125;);\n        t2.start();\n        Thread t3 = new Thread(() -> &#123;\n            d1.m2();\n        &#125;);\n        t3.start();\n        Demo6 d2 = new Demo6();\n        Thread t4 = new Thread(() -> &#123;\n            d2.m2();\n        &#125;);\n        t4.start();\n        Thread t5 = new Thread(() -> &#123;\n            Demo6.m4();\n        &#125;);\n        t5.start();\n        Thread t6 = new Thread(() -> &#123;\n            Demo6.m5();\n        &#125;);\n        t6.start();\n    &#125;\n&#125;\n\n分析上面代码：\n\n线程t1、t2、t3中调用的方法都需要获取d1的锁，所以他们是互斥的\nt1&#x2F;t2&#x2F;t3这3个线程和t4不互斥，他们可以同时运行，因为前面三个线程依赖于d1的锁，t4依赖于d2的锁\nt5、t6都作用于当前类的Class对象锁，所以这两个线程是互斥的，和其他几个线程不互斥\n\n4、ReentrantLockReentrantLock是Lock的默认实现，在聊ReentranLock之前，我们需要先弄清楚一些概念：\n\n可重入锁：可重入锁是指同一个线程可以多次获得同一把锁；ReentrantLock和关键字Synchronized都是可重入锁\n可中断锁：可中断锁时子线程在获取锁的过程中，是否可以相应线程中断操作。synchronized是不可中断的，ReentrantLock是可中断的\n公平锁和非公平锁：公平锁是指多个线程尝试获取同一把锁的时候，获取锁的顺序按照线程到达的先后顺序获取，而不是随机插队的方式获取。synchronized是非公平锁，而ReentrantLock是两种都可以实现，不过默认是非公平锁\n\n1、synchronized的局限性synchronized是java内置的关键字，它提供了一种独占的加锁方式。synchronized的获取和释放锁由jvm实现，用户不需要显示的释放锁，非常方便，然而synchronized也有一定的局限性，例如：\n\n当线程尝试获取锁的时候，如果获取不到锁会一直阻塞，这个阻塞的过程，用户无法控制\n如果获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待\n\nJDK1.5之后发布，加入了Doug Lea实现的java.util.concurrent包。包内提供了Lock类，用来提供更多扩展的加锁功能。Lock弥补了synchronized的局限，提供了更加细粒度的加锁功能。\n2、ReentrantLock基本使用我们使用3个线程来对一个共享变量++操作，先使用synchronized实现，然后使用ReentrantLock实现。\nsynchronized方式：\npublic class Demo2 &#123;\n    private static int num = 0;\n    private static synchronized void add() &#123;\n        num++;\n    &#125;\n    public static class T extends Thread &#123;\n        @Override\n        public void run() &#123;\n            for (int i = 0; i &lt; 10000; i++) &#123;\n                Demo2.add();\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        T t1 = new T();\n        T t2 = new T();\n        T t3 = new T();\n        t1.start();\n        t2.start();\n        t3.start();\n        t1.join();\n        t2.join();\n        t3.join();\n        System.out.println(Demo2.num);\n    &#125;\n&#125;\n\nReentrantLock方式：\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Demo3 &#123;\n    private static int num = 0;\n    private static ReentrantLock lock = new ReentrantLock();\n    private static void add() &#123;\n        lock.lock();\n        try &#123;\n            num++;\n        &#125; finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n    public static class T extends Thread &#123;\n        @Override\n        public void run() &#123;\n            for (int i = 0; i &lt; 10000; i++) &#123;\n                Demo3.add();\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        T t1 = new T();\n        T t2 = new T();\n        T t3 = new T();\n        t1.start();\n        t2.start();\n        t3.start();\n        t1.join();\n        t2.join();\n        t3.join();\n        System.out.println(Demo3.num);\n    &#125;\n&#125;\n\nReentrantLock的使用过程：\n\n创建锁：ReentrantLock lock &#x3D; new ReentrantLock();\n获取锁：lock.lock()\n释放锁：lock.unlock();\n\n对比上面的代码，与关键字synchronized相比，ReentrantLock锁有明显的操作过程，开发人员必须手动的指定何时加锁，何时释放锁，正是因为这样手动控制，ReentrantLock对逻辑控制的灵活度要远远胜于关键字synchronized，上面代码需要注意**lock.unlock()**一定要放在finally中，否则，若程序出现了异常，锁没有释放，那么其他线程就再也没有机会获取这个锁了。\n3、ReentrantLock获取锁的过程是可中断的对于synchronized关键字，如果一个线程在等待获取锁，最终只有2种结果：\n\n要么获取到锁然后继续后面的操作\n要么一直等待，直到其他线程释放锁为止\n\n而ReentrantLock提供了另外一种可能，就是在等待获取锁的过程中（发起获取锁请求到还未获取到锁这段时间内）是可以被中断的，也就是说在等待锁的过程中，程序可以根据需要取消获取锁的请求。有些使用这个操作是非常有必要的。比如：你和好朋友越好一起去打球，如果你等了半小时朋友还没到，突然你接到一个电话，朋友由于突发状况，不能来了，那么你一定达到回府。中断操作正是提供了一套类似的机制，如果一个线程正在等待获取锁，那么它依然可以收到一个通知，被告知无需等待，可以停止工作了。\n示例代码：\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Demo6 &#123;\n    private static ReentrantLock lock1 = new ReentrantLock(false);\n    private static ReentrantLock lock2 = new ReentrantLock(false);\n    public static class T extends Thread &#123;\n        int lock;\n        public T(String name, int lock) &#123;\n            super(name);\n            this.lock = lock;\n        &#125;\n        @Override\n        public void run() &#123;\n            try &#123;\n                if (this.lock == 1) &#123;\n                    lock1.lockInterruptibly();\n                    TimeUnit.SECONDS.sleep(1);\n                    lock2.lockInterruptibly();\n                &#125; else &#123;\n                    lock2.lockInterruptibly();\n                    TimeUnit.SECONDS.sleep(1);\n                    lock1.lockInterruptibly();\n                &#125;\n            &#125; catch (InterruptedException e) &#123;\n                System.out.println(\"中断标志:\" + this.isInterrupted());\n                e.printStackTrace();\n            &#125; finally &#123;\n                if (lock1.isHeldByCurrentThread()) &#123;\n                    lock1.unlock();\n                &#125;\n                if (lock2.isHeldByCurrentThread()) &#123;\n                    lock2.unlock();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        T t1 = new T(\"t1\", 1);\n        T t2 = new T(\"t2\", 2);\n        t1.start();\n        t2.start();\n    &#125;\n&#125;\n\n先运行一下上面代码，发现程序无法结束，使用jstack查看线程堆栈信息，发现2个线程死锁了。\nFound one Java-level deadlock:\n=============================\n\"t2\":\n  waiting for ownable synchronizer 0x0000000717380c20, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),\n  which is held by \"t1\"\n\"t1\":\n  waiting for ownable synchronizer 0x0000000717380c50, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),\n  which is held by \"t2\n\nlock1被线程t1占用，lock2被线程t2占用，线程t1在等待获取lock2，线程t2在等待获取lock1，都在相互等待获取对方持有的锁，最终产生了死锁，如果是在synchronized关键字情况下发生了死锁现象，程序是无法结束的。\n我们对上面代码改造一下，线程t2一直无法获取到lock1，那么等待5秒之后，我们中断获取锁的操作。主要修改一下main方法，如下：\nT t1 = new T(\"t1\", 1);\nT t2 = new T(\"t2\", 2);\nt1.start();\nt2.start();\nTimeUnit.SECONDS.sleep(5);\nt2.interrupt();\n\n新增了2行代码TimeUnit.SECONDS.sleep(5);t2.interrupt();，程序可以结束了，运行结果：\njava.lang.InterruptedException\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898)\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)\n    at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)\n    at com.itsoku.chat06.Demo6$T.run(Demo6.java:31)\n中断标志:false\n\n从上面信息中可以看出，代码的31行触发了异常，中断标志输出：false\n\nt2在31行一直获取不到lock1的锁，主线程中等待了5秒之后，t2线程调用了interrupt()方法，将线程的中断标志置为true，此时31行会触发InterruptedException异常，然后线程t2可以继续向下执行，释放了lock2的锁，然后线程t1可以正常获取锁，程序得以继续进行。线程发送中断信号触发InterruptedException异常之后，中断标志将被清空。\n关于获取锁的过程中被中断，注意几点:\n\nReentrankLock中必须使用实例方法lockInterruptibly()获取锁时，在线程调用interrupt()方法之后，才会引发InterruptedException异常\n线程调用interrupt()之后，线程的中断标志会被置为true\n触发InterruptedException异常之后，线程的中断标志会被清空，即置为false\n所以当线程调用interrupt()引发InterruptedException异常，中断标志的变化是:false-&gt;true-&gt;false\n\n4、ReentrantLock锁申请等待限时申请锁等待限时是什么意思？一般情况下，获取锁的时间我们是不知道的，synchronized关键字获取锁的过程中，只能等待其他线程把锁释放之后才能够有机会获取到锁。所以获取锁的时间有长有短。如果获取锁的时间能够设置超时时间，那就非常好了。\nReentrantLock刚好提供了这样功能，给我们提供了获取锁限时等待的方法tryLock()，可以选择传入时间参数，表示等待指定的时间，无参则表示立即返回锁申请的结果：true表示获取锁成功，false表示获取锁失败。\ntryLock无参方法\n看一下源码中tryLock方法：\npublic boolean tryLock()\n\n返回boolean类型的值，此方法会立即返回，结果表示获取锁是否成功，示例：\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Demo8 &#123;\n    private static ReentrantLock lock1 = new ReentrantLock(false);\n    public static class T extends Thread &#123;\n        public T(String name) &#123;\n            super(name);\n        &#125;\n        @Override\n        public void run() &#123;\n            try &#123;\n                System.out.println(System.currentTimeMillis() + \":\" + this.getName() + \"开始获取锁!\");\n                //获取锁超时时间设置为3秒，3秒内是否能否获取锁都会返回\n                if (lock1.tryLock()) &#123;\n                    System.out.println(System.currentTimeMillis() + \":\" + this.getName() + \"获取到了锁!\");\n                    //获取到锁之后，休眠5秒\n                    TimeUnit.SECONDS.sleep(5);\n                &#125; else &#123;\n                    System.out.println(System.currentTimeMillis() + \":\" + this.getName() + \"未能获取到锁!\");\n                &#125;\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; finally &#123;\n                if (lock1.isHeldByCurrentThread()) &#123;\n                    lock1.unlock();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        T t1 = new T(\"t1\");\n        T t2 = new T(\"t2\");\n        t1.start();\n        t2.start();\n    &#125;\n&#125;\n\n代码中获取锁成功之后，休眠5秒，会导致另外一个线程获取锁失败，运行代码，输出：\n1563356291081:t2开始获取锁!\n1563356291081:t2获取到了锁!\n1563356291081:t1开始获取锁!\n1563356291081:t1未能获取到锁!\n\ntryLock有参方法\n可以明确设置获取锁的超时时间，该方法签名：\npublic boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException\n\n该方法在指定的时间内不管是否可以获取锁，都会返回结果，返回true，表示获取锁成功，返回false表示获取失败。此方法有2个参数，第一个参数是时间类型，是一个枚举，可以表示时、分、秒、毫秒等待，使用比较方便，第1个参数表示在时间类型上的时间长短。此方法在执行的过程中，如果调用了线程的中断interrupt()方法，会触发InterruptedException异常。\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Demo7 &#123;\n    private static ReentrantLock lock1 = new ReentrantLock(false);\n    public static class T extends Thread &#123;\n        public T(String name) &#123;\n            super(name);\n        &#125;\n        @Override\n        public void run() &#123;\n            try &#123;\n                System.out.println(System.currentTimeMillis() + \":\" + this.getName() + \"开始获取锁!\");\n                //获取锁超时时间设置为3秒，3秒内是否能否获取锁都会返回\n                if (lock1.tryLock(3, TimeUnit.SECONDS)) &#123;\n                    System.out.println(System.currentTimeMillis() + \":\" + this.getName() + \"获取到了锁!\");\n                    //获取到锁之后，休眠5秒\n                    TimeUnit.SECONDS.sleep(5);\n                &#125; else &#123;\n                    System.out.println(System.currentTimeMillis() + \":\" + this.getName() + \"未能获取到锁!\");\n                &#125;\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; finally &#123;\n                if (lock1.isHeldByCurrentThread()) &#123;\n                    lock1.unlock();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        T t1 = new T(\"t1\");\n        T t2 = new T(\"t2\");\n        t1.start();\n        t2.start();\n    &#125;\n&#125;\n\n程序中调用了ReentrantLock的实例方法tryLock(3, TimeUnit.SECONDS)，表示获取锁的超时时间是3秒，3秒后不管是否能否获取锁，该方法都会有返回值，获取到锁之后，内部休眠了5秒，会导致另外一个线程获取锁失败。\n运行程序，输出：\n1563355512901:t2开始获取锁!\n1563355512901:t1开始获取锁!\n1563355512902:t2获取到了锁!\n1563355515904:t1未能获取到锁!\n\n输出结果中分析，t2获取到锁了，然后休眠了5秒，t1获取锁失败，t1打印了2条信息，时间相差3秒左右。\n关于tryLock()方法和tryLock(long timeout, TimeUnit unit)方法，说明一下：\n\n都会返回boolean值，结果表示获取锁是否成功\ntryLock()方法，不管是否获取成功，都会立即返回；而有参的tryLock方法会尝试在指定的时间内去获取锁，中间会阻塞的现象，在指定的时间之后会不管是否能够获取锁都会返回结果\ntryLock()方法不会响应线程的中断方法；而有参的tryLock方法会响应线程的中断方法，而触发InterruptedException异常，这个从2个方法的声明上可以可以看出来\n\n5、ReentrantLock其他常用的方法\nisHeldByCurrentThread：实例方法，判断当前线程是否持有ReentrantLock的锁，上面代码中有使用过。\n\n获取锁的4种方法对比\n\n\n\n获取锁的方法\n是否立即响应(不会阻塞)\n是否响应中断\n\n\n\nlock()\n×\n×\n\n\nlockInterruptibly()\n×\n√\n\n\ntryLock()\n√\n×\n\n\ntryLock(long timeout, TimeUnit unit)\n×\n√\n\n\n6、总结\nReentrantLock可以实现公平锁和非公平锁\nReentrantLock默认实现的是非公平锁\nReentrantLock的获取锁和释放锁必须成对出现，锁了几次，也要释放几次\n释放锁的操作必须放在finally中执行\nlockInterruptibly()实例方法可以相应线程的中断方法，调用线程的interrupt()方法时，lockInterruptibly()方法会触发InterruptedException异常\n关于InterruptedException异常说一下，看到方法声明上带有 throws InterruptedException，表示该方法可以相应线程中断，调用线程的interrupt()方法时，这些方法会触发InterruptedException异常，触发InterruptedException时，线程的中断中断状态会被清除。所以如果程序由于调用interrupt()方法而触发InterruptedException异常，线程的标志由默认的false变为ture，然后又变为false\n实例方法tryLock()会尝试获取锁，会立即返回，返回值表示是否获取成功\n实例方法tryLock(long timeout, TimeUnit unit)会在指定的时间内尝试获取锁，指定的时间内是否能够获取锁，都会返回，返回值表示是否获取锁成功，该方法会响应线程的中断\n\n5、悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。\nsynchronized关键字和Lock的实现类都是悲观锁\n适合写操作多的场景，先加锁可以保证写操作时数据正确。\n显式的锁定之后再操作同步资源\n//=============悲观锁的调用方式\npublic synchronized void m1()\n&#123;\n    //加锁后的业务逻辑......\n&#125;\n\n// 保证多个线程使用的是同一个lock对象的前提下\nReentrantLock lock = new ReentrantLock();\npublic void m2() &#123;\n    lock.lock();\n    try &#123;\n        // 操作同步资源\n    &#125;finally &#123;\n        lock.unlock();\n    &#125;\n&#125;\n\n6、乐观锁//=============乐观锁的调用方式\n// 保证多个线程使用的是同一个AtomicInteger\nprivate AtomicInteger atomicInteger = new AtomicInteger();\natomicInteger.incrementAndGet();\n\n​\t\t乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。\n如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作\n乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。\n适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。\n乐观锁则直接去操作同步资源，是一种无锁算法，得之我幸不得我命，再抢\n乐观锁一般有两种实现方式：\n\n采用版本号机制\nCAS（Compare-and-Swap，即比较并替换）算法实现\n\n7、八锁案例1、JDK源码(notify方法)\n2、8种锁的案例实际体现在3个地方\n作用于实例方法，当前实例加锁，进入同步代码前要获得当前实例的锁；\n作用于代码块，对括号里配置的对象加锁。\n作用于静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁；\n\n1、标准访问有ab两个线程，请问先打印邮件还是短信class Phone &#x2F;&#x2F;资源类\n&#123;\n    public synchronized void sendEmail()\n    &#123;\n        System.out.println(&quot;-------sendEmail&quot;);\n    &#125;\n\n    public synchronized void sendSMS()\n    &#123;\n        System.out.println(&quot;-------sendSMS&quot;);\n    &#125;\n&#125;\n\npublic class Lock8Demo\n&#123;\n    public static void main(String[] args)&#x2F;&#x2F;一切程序的入口，主线程\n    &#123;\n        Phone phone &#x3D; new Phone();&#x2F;&#x2F;资源类1\n\n        new Thread(() -&gt; &#123;\n            phone.sendEmail();\n        &#125;,&quot;a&quot;).start();\n\n        &#x2F;&#x2F;暂停毫秒\n        try &#123; TimeUnit.MILLISECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -&gt; &#123;\n            phone.sendSMS();\n        &#125;,&quot;b&quot;).start();\n\n    &#125;\n&#125;\n\n-------sendEmail\n-------sendSMS\n\n2、sendEmail方法暂停3秒钟，请问先打印邮件还是短信class Phone //资源类\n&#123;\n    public synchronized void sendEmail()\n    &#123;\n        //暂停几秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n        System.out.println(\"-------sendEmail\");\n    &#125;\n\n    public synchronized void sendSMS()\n    &#123;\n        System.out.println(\"-------sendSMS\");\n    &#125;\n&#125;\n\npublic class Lock8Demo\n&#123;\n    public static void main(String[] args)//一切程序的入口，主线程\n    &#123;\n        Phone phone = new Phone();//资源类1\n\n        new Thread(() -> &#123;\n            phone.sendEmail();\n        &#125;,\"a\").start();\n\n        //暂停毫秒\n        try &#123; TimeUnit.MILLISECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            phone.sendSMS();\n        &#125;,\"b\").start();\n\n    &#125;\n&#125;\n\n-------sendEmail\n-------sendSMS\n\n1-2结论一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，\n其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一的一个线程去访问这些synchronized方法\n锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法\n\n3、新增一个普通的hello方法，请问先打印邮件还是helloclass Phone //资源类\n&#123;\n    public synchronized void sendEmail()\n    &#123;\n        //暂停几秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n        System.out.println(\"-------sendEmail\");\n    &#125;\n\n    public synchronized void sendSMS()\n    &#123;\n        System.out.println(\"-------sendSMS\");\n    &#125;\n\n    public void hello()\n    &#123;\n        System.out.println(\"-------hello\");\n    &#125;\n&#125;\n\npublic class Lock8Demo\n&#123;\n    public static void main(String[] args)//一切程序的入口，主线程\n    &#123;\n        Phone phone = new Phone();//资源类1\n\n        new Thread(() -> &#123;\n            phone.sendEmail();\n        &#125;,\"a\").start();\n\n        //暂停毫秒\n        try &#123; TimeUnit.MILLISECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            phone.hello();\n        &#125;,\"b\").start();\n\n    &#125;\n&#125;\n\n-------hello\n-------sendEmail\n\n4、有两部手机，请问先打印邮件还是短信class Phone //资源类\n&#123;\n    public synchronized void sendEmail()\n    &#123;\n        //暂停几秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n        System.out.println(\"-------sendEmail\");\n    &#125;\n\n    public synchronized void sendSMS()\n    &#123;\n        System.out.println(\"-------sendSMS\");\n    &#125;\n\n    public void hello()\n    &#123;\n        System.out.println(\"-------hello\");\n    &#125;\n&#125;\n\npublic class Lock8Demo\n&#123;\n    public static void main(String[] args)//一切程序的入口，主线程\n    &#123;\n        Phone phone = new Phone();//资源类1\n        Phone phone2 = new Phone();//资源类2\n\n        new Thread(() -> &#123;\n            phone.sendEmail();\n        &#125;,\"a\").start();\n\n        //暂停毫秒\n        try &#123; TimeUnit.MILLISECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            phone2.sendSMS();\n        &#125;,\"b\").start();\n    &#125;\n&#125;\n\n-------sendSMS\n-------sendEmail\n\n3-4结论加个普通方法后发现和同步锁无关,hello\n换成两个对象后，不是同一把锁了，情况立刻变化。\n\n5、两个静态同步方法，同1部手机，请问先打印邮件还是短信class Phone //资源类\n&#123;\n    public static synchronized void sendEmail()\n    &#123;\n        //暂停几秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n        System.out.println(\"-------sendEmail\");\n    &#125;\n\n    public static synchronized void sendSMS()\n    &#123;\n        System.out.println(\"-------sendSMS\");\n    &#125;\n\n    public void hello()\n    &#123;\n        System.out.println(\"-------hello\");\n    &#125;\n&#125;\n\npublic class Lock8Demo\n&#123;\n    public static void main(String[] args)//一切程序的入口，主线程\n    &#123;\n        Phone phone = new Phone();//资源类1\n\n        new Thread(() -> &#123;\n            phone.sendEmail();\n        &#125;,\"a\").start();\n\n        //暂停毫秒\n        try &#123; TimeUnit.MILLISECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            phone.sendSMS();\n        &#125;,\"b\").start();\n    &#125;\n&#125;\n\n-------sendEmail\n-------sendSMS\n\n6、两个静态同步方法， 2部手机，请问先打印邮件还是短信class Phone //资源类\n&#123;\n    public static synchronized void sendEmail()\n    &#123;\n        //暂停几秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n        System.out.println(\"-------sendEmail\");\n    &#125;\n\n    public static synchronized void sendSMS()\n    &#123;\n        System.out.println(\"-------sendSMS\");\n    &#125;\n\n    public void hello()\n    &#123;\n        System.out.println(\"-------hello\");\n    &#125;\n&#125;\n\npublic class Lock8Demo\n&#123;\n    public static void main(String[] args)//一切程序的入口，主线程\n    &#123;\n        Phone phone = new Phone();//资源类1\n        Phone phone2 = new Phone();//资源类2\n\n        new Thread(() -> &#123;\n            phone.sendEmail();\n        &#125;,\"a\").start();\n\n        //暂停毫秒\n        try &#123; TimeUnit.MILLISECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            phone2.sendSMS();\n        &#125;,\"b\").start();\n    &#125;\n&#125;\n\n-------sendEmail\n-------sendSMS\n\n5-6结论都换成静态同步方法后，情况又变化\n三种 synchronized 锁的内容有一些差别:\n对于普通同步方法，锁的是当前实例对象，通常指this,具体的一部部手机,所有的普通同步方法用的都是同一把锁——实例对象本身，\n对于静态同步方法，锁的是当前类的Class对象，如Phone.class唯一的一个模板\n对于同步方法块，锁的是 synchronized 括号内的对象\n\n7、1个静态同步方法，1个普通同步方法,同1部手机，请问先打印邮件还是短信class Phone //资源类\n&#123;\n    public static synchronized void sendEmail()\n    &#123;\n        //暂停几秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n        System.out.println(\"-------sendEmail\");\n    &#125;\n\n    public synchronized void sendSMS()\n    &#123;\n        System.out.println(\"-------sendSMS\");\n    &#125;\n\n    public void hello()\n    &#123;\n        System.out.println(\"-------hello\");\n    &#125;\n&#125;\n\npublic class Lock8Demo\n&#123;\n    public static void main(String[] args)//一切程序的入口，主线程\n    &#123;\n        Phone phone = new Phone();//资源类1\n\n        new Thread(() -> &#123;\n            phone.sendEmail();\n        &#125;,\"a\").start();\n\n        //暂停毫秒\n        try &#123; TimeUnit.MILLISECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            phone.sendSMS();\n        &#125;,\"b\").start();\n    &#125;\n&#125;\n\n-------sendSMS\n-------sendEmail\n\n8、1个静态同步方法，1个普通同步方法,2部手机，请问先打印邮件还是短信class Phone //资源类\n&#123;\n    public static synchronized void sendEmail()\n    &#123;\n        //暂停几秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n        System.out.println(\"-------sendEmail\");\n    &#125;\n\n    public synchronized void sendSMS()\n    &#123;\n        System.out.println(\"-------sendSMS\");\n    &#125;\n\n    public void hello()\n    &#123;\n        System.out.println(\"-------hello\");\n    &#125;\n&#125;\n\npublic class Lock8Demo\n&#123;\n    public static void main(String[] args)//一切程序的入口，主线程\n    &#123;\n        Phone phone = new Phone();//资源类1\n        Phone phone2 = new Phone();//资源类2\n\n        new Thread(() -> &#123;\n            phone.sendEmail();\n        &#125;,\"a\").start();\n\n        //暂停毫秒\n        try &#123; TimeUnit.MILLISECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            phone2.sendSMS();\n        &#125;,\"b\").start();\n    &#125;\n&#125;\n\n-------sendSMS\n-------sendEmail\n\n7-8结论当一个线程试图访问同步代码时它首先必须得到锁，退出或抛出异常时必须释放锁。\n\n所有的普通同步方法用的都是同一把锁——实例对象本身，就是new出来的具体实例对象本身,本类this\n也就是说如果一个实例对象的普通同步方法获取锁后，该实例对象的其他普通同步方法必须等待获取锁的方法释放锁后才能获取锁。\n\n所有的静态同步方法用的也是同一把锁——类对象本身，就是我们说过的唯一模板Class\n具体实例对象this和唯一模板Class，这两把锁是两个不同的对象，所以静态同步方法与普通同步方法之间是不会有竞态条件的\n但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁。\n\n8、公平锁和非公平锁在大多数情况下，锁的申请都是非公平的，也就是说，线程1首先请求锁A，接着线程2也请求了锁A。那么当锁A可用时，是线程1可获得锁还是线程2可获得锁呢？这是不一定的，系统只是会从这个锁的等待队列中随机挑选一个，因此不能保证其公平性。这就好比买票不排队，大家都围在售票窗口前，售票员忙的焦头烂额，也顾及不上谁先谁后，随便找个人出票就完事了，最终导致的结果是，有些人可能一直买不到票。而公平锁，则不是这样，它会按照到达的先后顺序获得资源。公平锁的一大特点是：它不会产生饥饿现象，只要你排队，最终还是可以等到资源的；synchronized关键字默认是有jvm内部实现控制的，是非公平锁。而ReentrantLock运行开发者自己设置锁的公平性。\n看一下jdk中ReentrantLock的源码，2个构造方法：\npublic ReentrantLock() &#123;\n    sync = new NonfairSync();\n&#125;\npublic ReentrantLock(boolean fair) &#123;\n    sync = fair ? new FairSync() : new NonfairSync();\n&#125;\n\n默认构造方法创建的是非公平锁。\n第2个构造方法，有个fair参数，当fair为true的时候创建的是公平锁，公平锁看起来很不错，不过要实现公平锁，系统内部肯定需要维护一个有序队列，因此公平锁的实现成本比较高，性能相对于非公平锁来说相对低一些。因此，在默认情况下，锁是非公平的，如果没有特别要求，则不建议使用公平锁。\n公平锁和非公平锁在程序调度上是很不一样，来一个公平锁示例看一下：\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Demo5 &#123;\n    private static int num = 0;\n    private static ReentrantLock fairLock = new ReentrantLock(true);\n    public static class T extends Thread &#123;\n        public T(String name) &#123;\n            super(name);\n        &#125;\n        @Override\n        public void run() &#123;\n            for (int i = 0; i &lt; 5; i++) &#123;\n                fairLock.lock();\n                try &#123;\n                    System.out.println(this.getName() + \"获得锁!\");\n                &#125; finally &#123;\n                    fairLock.unlock();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        T t1 = new T(\"t1\");\n        T t2 = new T(\"t2\");\n        T t3 = new T(\"t3\");\n        t1.start();\n        t2.start();\n        t3.start();\n        t1.join();\n        t2.join();\n        t3.join();\n    &#125;\n&#125;\n\n看一下输出的结果，锁是按照先后顺序获得的。\n修改一下上面代码，改为非公平锁试试，如下：\nReentrantLock fairLock = new ReentrantLock(false);\n\n从ReentrantLock卖票编码演示公平和非公平现象\nimport java.util.concurrent.locks.ReentrantLock;\n\nclass Ticket\n&#123;\n    private int number = 30;\n    ReentrantLock lock = new ReentrantLock();\n\n    public void sale()\n    &#123;\n        lock.lock();\n        try\n        &#123;\n            if(number > 0)\n            &#123;\n                System.out.println(Thread.currentThread().getName()+\"卖出第：\\t\"+(number--)+\"\\t 还剩下:\"+number);\n            &#125;\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n&#125;\n\npublic class SaleTicketDemo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Ticket ticket = new Ticket();\n\n        new Thread(() -> &#123; for (int i = 0; i &lt;35; i++)  ticket.sale(); &#125;,\"a\").start();\n        new Thread(() -> &#123; for (int i = 0; i &lt;35; i++)  ticket.sale(); &#125;,\"b\").start();\n        new Thread(() -> &#123; for (int i = 0; i &lt;35; i++)  ticket.sale(); &#125;,\"c\").start();\n    &#125;\n&#125;\n\n生活中，排队讲求先来后到视为公平。程序中的公平性也是符合请求锁的绝对时间的，其实就是 FIFO，否则视为不公平\n1、源码解读​\t\t按序排队公平锁，就是判断同步队列是否还有先驱节点的存在(我前面还有人吗?)，如果没有先驱节点才能获取锁；先占先得非公平锁，是不管这个事的，只要能抢获到同步状态就可以\n\n2、为什么会有公平锁&#x2F;非公平锁的设计为什么默认非公平？\n恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分的利用CPU 的时间片，尽量减少 CPU 空闲状态时间。\n使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，当1个线程请求锁获取同步状态，然后释放同步状态，因为不需要考虑是否还有前驱节点，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销。\n\n3、使⽤公平锁会有什么问题公平锁保证了排队的公平性，非公平锁霸气的忽视这个规则，所以就有可能导致排队的长时间在排队，也没有机会获取到锁，这就是传说中的 “锁饥饿”\n4、什么时候用公平？什么时候用非公平？如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省很多线程切换时间，吞吐量自然就上去了；否则那就用公平锁，大家公平使用。\n9、可重入锁(又名递归锁)是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。\n如果是1个有 synchronized 修饰的递归调用方法，程序第2次进入被自己阻塞了岂不是天大的笑话，出现了作茧自缚。所以Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。\n1、“可重入锁”这四个字分开来解释：可：可以。\n重：再次。\n入：进入。\n锁：同步锁。\n\n进入什么:进入同步域（即同步代码块&#x2F;方法或显式锁锁定的代码）\n一句话:一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入。\n自己可以获取自己的内部锁\n\n2、可重入锁种类1、隐式锁（即synchronized关键字使用的锁）默认是可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。\n简单的来说就是：在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的\n\n与可重入锁相反，不可重入锁不可递归调用，递归调用就发生死锁。\n\n同步块\npublic class ReEntryLockDemo&#123;\n    public static void main(String[] args)&#123;\n        final Object objectLockA = new Object();\n\n        new Thread(() -> &#123;\n            synchronized (objectLockA)&#123;\n                System.out.println(\"-----外层调用\");\n                synchronized (objectLockA)&#123;\n                    System.out.println(\"-----中层调用\");\n                    synchronized (objectLockA)&#123;\n                        System.out.println(\"-----内层调用\");\n                    &#125;\n                &#125;\n            &#125;\n        &#125;,\"a\").start();\n    &#125;\n&#125;\n\n同步方法\npublic class ReEntryLockDemo&#123;\n    public synchronized void m1()&#123;\n        System.out.println(\"-----m1\");\n        m2();\n    &#125;\n    public synchronized void m2()&#123;\n        System.out.println(\"-----m2\");\n        m3();\n    &#125;\n    public synchronized void m3()&#123;\n        System.out.println(\"-----m3\");\n    &#125;\n\n    public static void main(String[] args)&#123;\n        ReEntryLockDemo reEntryLockDemo = new ReEntryLockDemo();\n\n        reEntryLockDemo.m1();\n    &#125;\n&#125;\n\n2、显式锁（即Lock）也有ReentrantLock这样的可重入锁。public class Demo4 &#123;\n    private static int num = 0;\n    private static ReentrantLock lock = new ReentrantLock();\n    private static void add() &#123;\n        lock.lock();\n        lock.lock();\n        try &#123;\n            num++;\n        &#125; finally &#123;\n            lock.unlock();\n            lock.unlock();\n        &#125;\n    &#125;\n    public static class T extends Thread &#123;\n        @Override\n        public void run() &#123;\n            for (int i = 0; i &lt; 10000; i++) &#123;\n                Demo4.add();\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        T t1 = new T();\n        T t2 = new T();\n        T t3 = new T();\n        t1.start();\n        t2.start();\n        t3.start();\n        t1.join();\n        t2.join();\n        t3.join();\n        System.out.println(Demo4.num);\n    &#125;\n&#125;\n\n上面代码中add()方法中，当一个线程进入的时候，会执行2次获取锁的操作，运行程序可以正常结束，并输出和期望值一样的30000，假如ReentrantLock是不可重入的锁，那么同一个线程第2次获取锁的时候由于前面的锁还未释放而导致死锁，程序是无法正常结束的。ReentrantLock命名也挺好的Re entrant Lock，和其名字一样，可重入锁。\n代码中还有几点需要注意：\n\nlock()方法和unlock()方法需要成对出现，锁了几次，也要释放几次，否则后面的线程无法获取锁了；可以将add中的unlock删除一个事实，上面代码运行将无法结束\nunlock()方法放在finally中执行，保证不管程序是否有异常，锁必定会释放\n\n/**\n * @create 2020-05-14 11:59\n * 在一个Synchronized修饰的方法或代码块的内部调用本类的其他Synchronized修饰的方法或代码块时，是永远可以得到锁的\n */\npublic class ReEntryLockDemo&#123;\n    static Lock lock = new ReentrantLock();\n\n    public static void main(String[] args)&#123;\n        new Thread(() -> &#123;\n            lock.lock();\n            try\n            &#123;\n                System.out.println(\"----外层调用lock\");\n                lock.lock();\n                try\n                &#123;\n                    System.out.println(\"----内层调用lock\");\n                &#125;finally &#123;\n                    // 这里故意注释，实现加锁次数和释放次数不一样\n                    // 由于加锁次数和释放次数不一样，第二个线程始终无法获取到锁，导致一直在等待。\n                    lock.unlock(); // 正常情况，加锁几次就要解锁几次\n                &#125;\n            &#125;finally &#123;\n                lock.unlock();\n            &#125;\n        &#125;,\"a\").start();\n\n        new Thread(() -> &#123;\n            lock.lock();\n            try\n            &#123;\n                System.out.println(\"b thread----外层调用lock\");\n            &#125;finally &#123;\n                lock.unlock();\n            &#125;\n        &#125;,\"b\").start();\n\n    &#125;\n&#125;\n\n\n\n3、Synchronized的重入的实现机理​\t\t每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。\n​\t\t当执行monitorenter时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。\n​\t\t在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么 Java 虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。\n​\t\t当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。\n10、死锁​\t\t死锁是指两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。\n\n1、产生死锁主要原因\n系统资源不足\n进程运行推进的顺序不合适\n资源分配不当\n\npublic class DeadLockDemo&#123;\n    public static void main(String[] args)&#123;\n        final Object objectLockA = new Object();\n        final Object objectLockB = new Object();\n\n        new Thread(() -> &#123;\n            synchronized (objectLockA)&#123;\n                System.out.println(Thread.currentThread().getName()+\"\\t\"+\"自己持有A，希望获得B\");\n                //暂停几秒钟线程\n                try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n                synchronized (objectLockB)\n                &#123;\n                    System.out.println(Thread.currentThread().getName()+\"\\t\"+\"A-------已经获得B\");\n                &#125;\n            &#125;\n        &#125;,\"A\").start();\n\n        new Thread(() -> &#123;\n            synchronized (objectLockB)&#123;\n                System.out.println(Thread.currentThread().getName()+\"\\t\"+\"自己持有B，希望获得A\");\n                //暂停几秒钟线程\n                try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n                synchronized (objectLockA)&#123;\n                    System.out.println(Thread.currentThread().getName()+\"\\t\"+\"B-------已经获得A\");\n                &#125;\n            &#125;\n        &#125;,\"B\").start();\n\n    &#125;\n&#125;\n\n2、如何排查死锁\n纯命令\n\njps -l\njstack 进程编号\n\n\n图形化\n\njconsole\n\n五、线程间通信1、面试题：两个线程打印两个线程，一个线程打印1-52，另一个打印字母A-Z打印顺序为12A34B…5152Z\n1、synchronized实现package com.xue.thread;\n \nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n \n \n \nclass ShareDataOne//资源类&#123;\n  private int number = 0;//初始值为零的一个变量\n \n  public synchronized void increment() throws InterruptedException &#123;\n     //1判断\n     if(number !=0 ) &#123;\n       this.wait();\n     &#125;\n     //2干活\n     ++number;\n     System.out.println(Thread.currentThread().getName()+\"\\t\"+number);\n     //3通知\n     this.notifyAll();\n  &#125;\n  \n  public synchronized void decrement() throws InterruptedException &#123;\n     // 1判断\n     if (number == 0) &#123;\n       this.wait();\n     &#125;\n     // 2干活\n     --number;\n     System.out.println(Thread.currentThread().getName() + \"\\t\" + number);\n     // 3通知\n     this.notifyAll();\n  &#125;\n&#125;\n \n/**\n * \n * @Description:\n *现在两个线程，\n * 可以操作初始值为零的一个变量，\n * 实现一个线程对该变量加1，一个线程对该变量减1，\n * 交替，来10轮。 \n * @author xialei\n *\n *  * 笔记：Java里面如何进行工程级别的多线程编写\n * 1 多线程变成模板（套路）-----上\n *     1.1  线程    操作    资源类  \n *     1.2  高内聚  低耦合\n * 2 多线程变成模板（套路）-----下\n *     2.1  判断\n *     2.2  干活\n *     2.3  通知\n \n */\npublic class NotifyWaitDemoOne&#123;\n  public static void main(String[] args)&#123;\n     ShareDataOne sd = new ShareDataOne();\n     new Thread(() -> &#123;\n       for (int i = 1; i &lt; 10; i++) &#123;\n          try &#123;\n            sd.increment();\n          &#125; catch (InterruptedException e) &#123;\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          &#125;\n       &#125;\n     &#125;, \"A\").start();\n     new Thread(() -> &#123;\n       for (int i = 1; i &lt; 10; i++) &#123;\n          try &#123;\n            sd.decrement();\n          &#125; catch (InterruptedException e) &#123;\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          &#125;\n       &#125;\n     &#125;, \"B\").start();\n  &#125;\n&#125;\n/*\n * * \n * 2 多线程变成模板（套路）-----下\n *     2.1  判断\n *     2.2  干活\n *     2.3  通知\n * 3 防止虚假唤醒用while\n * \n * \n * */\n\n2、换成4个线程​\t\t换成4个线程会导致错误，虚假唤醒\n​\t\t原因：在java多线程判断时，不能用if，程序出事出在了判断上面，\n突然有一添加的线程进到if了，突然中断了交出控制权，\n没有进行验证，而是直接走下去了，加了两次，甚至多次\n3、4个线程解决方案解决虚假唤醒：查看API，java.lang.Object\n\n中断和虚假唤醒是可能产生的，所以要用loop循环，if只判断一次，while是只要唤醒就要拉回来再判断一次。if换成while\n4、java8新版实现\nclass BoundedBuffer &#123;\n   final Lock lock = new ReentrantLock();\n   final Condition notFull  = lock.newCondition(); \n   final Condition notEmpty = lock.newCondition(); \n \n   final Object[] items = new Object[100];\n   int putptr, takeptr, count;\n \n   public void put(Object x) throws InterruptedException &#123;\n     lock.lock();\n     try &#123;\n       while (count == items.length)\n         notFull.await();\n       items[putptr] = x;\n       if (++putptr == items.length) putptr = 0;\n       ++count;\n       notEmpty.signal();\n     &#125; finally &#123;\n       lock.unlock();\n     &#125;\n   &#125;\n\npackage com.xue.thread;\n \nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n \nimport org.omg.IOP.Codec;\n \n \nclass ShareData//资源类\n&#123;\n  private int number = 0;//初始值为零的一个变量\n \n  private Lock lock = new ReentrantLock();\n  private Condition condition  = lock.newCondition(); \n   \n  public  void increment() throws InterruptedException \n  &#123;\n     \n      lock.lock();\n         try &#123;\n          //判断\n          while(number!=0) &#123;\n            condition.await();\n          &#125;\n          //干活\n          ++number;\n          System.out.println(Thread.currentThread().getName()+\" \\t \"+number);\n          //通知\n          condition.signalAll();\n     &#125; catch (Exception e) &#123;\n       e.printStackTrace();\n     &#125; finally &#123;\n       lock.unlock();\n     &#125;\n     \n  &#125;\n  \n  \n  public  void decrement() throws InterruptedException \n  &#123;\n      \n      lock.lock();\n         try &#123;\n          //判断\n          while(number!=1) &#123;\n            condition.await();\n          &#125;\n          //干活\n          --number;\n          System.out.println(Thread.currentThread().getName()+\" \\t \"+number);\n          //通知\n          condition.signalAll();\n     &#125; catch (Exception e) &#123;\n       e.printStackTrace();\n     &#125; finally &#123;\n       lock.unlock();\n     &#125;\n     \n  &#125;\n  \n  /*public synchronized void increment() throws InterruptedException \n  &#123;\n     //判断\n     while(number!=0) &#123;\n       this.wait();\n     &#125;\n     //干活\n     ++number;\n     System.out.println(Thread.currentThread().getName()+\" \\t \"+number);\n     //通知\n     this.notifyAll();;\n  &#125;\n  \n  public synchronized void decrement() throws InterruptedException \n  &#123;\n     //判断\n     while(number!=1) &#123;\n       this.wait();\n     &#125;\n     //干活\n     --number;\n     System.out.println(Thread.currentThread().getName()+\" \\t \"+number);\n     //通知\n     this.notifyAll();\n  &#125;*/\n&#125;\n \n/**\n * \n * @Description:\n *现在两个线程，\n * 可以操作初始值为零的一个变量，\n * 实现一个线程对该变量加1，一个线程对该变量减1，\n * 交替，来10轮。 \n *\n *  * 笔记：Java里面如何进行工程级别的多线程编写\n * 1 多线程变成模板（套路）-----上\n *     1.1  线程    操作    资源类  \n *     1.2  高内聚  低耦合\n * 2 多线程变成模板（套路）-----下\n *     2.1  判断\n *     2.2  干活\n *     2.3  通知\n \n */\npublic class NotifyWaitDemo\n&#123;\n  public static void main(String[] args)\n  &#123;\n     ShareData sd = new ShareData();\n     new Thread(() -> &#123;\n \n       for (int i = 1; i &lt;= 10; i++) &#123;\n          try &#123;\n            sd.increment();\n          &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n          &#125;\n       &#125;\n     &#125;, \"A\").start();\n     \n     new Thread(() -> &#123;\n \n       for (int i = 1; i &lt;= 10; i++) &#123;\n          try &#123;\n            sd.decrement();\n          &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n          &#125;\n       &#125;\n     &#125;, \"B\").start();\n     new Thread(() -> &#123;\n \n       for (int i = 1; i &lt;= 10; i++) &#123;\n          try &#123;\n            sd.increment();\n          &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n          &#125;\n       &#125;\n     &#125;, \"C\").start();\n     new Thread(() -> &#123;\n \n       for (int i = 1; i &lt;= 10; i++) &#123;\n          try &#123;\n            sd.decrement();\n          &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n          &#125;\n       &#125;\n     &#125;, \"D\").start();\n     \n  &#125;\n&#125;\n\n/*\n * * \n * 2 多线程变成模板（套路）-----下\n *     2.1  判断\n *     2.2  干活\n *     2.3  通知\n * 3 防止虚假唤醒用while\n * \n * \n * */\n\n2、线程间定制化调用通信1、有顺序通知，需要有标识位\n2、有一个锁Lock，3把钥匙Condition\n3、判断标志位\n4、输出线程名+第几次+第几轮\n5、修改标志位，通知下一个\npackage com.xue.thread;\n \nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n \n \nclass ShareResource\n&#123;\n  private int number = 1;//1:A 2:B 3:C \n  private Lock lock = new ReentrantLock();\n  private Condition c1 = lock.newCondition();\n  private Condition c2 = lock.newCondition();\n  private Condition c3 = lock.newCondition();\n \n  public void print5(int totalLoopNumber)\n  &#123;\n     lock.lock();\n     try \n     &#123;\n       //1 判断\n       while(number != 1)\n       &#123;\n          //A 就要停止\n          c1.await();\n       &#125;\n       //2 干活\n       for (int i = 1; i &lt;=5; i++) \n       &#123;\n          System.out.println(Thread.currentThread().getName()+\"\\t\"+i+\"\\t totalLoopNumber: \"+totalLoopNumber);\n       &#125;\n       //3 通知\n       number = 2;\n       c2.signal();\n     &#125; catch (Exception e) &#123;\n       e.printStackTrace();\n     &#125; finally &#123;\n       lock.unlock();\n     &#125;\n  &#125;\n  public void print10(int totalLoopNumber)\n  &#123;\n     lock.lock();\n     try \n     &#123;\n       //1 判断\n       while(number != 2)\n       &#123;\n          //A 就要停止\n          c2.await();\n       &#125;\n       //2 干活\n       for (int i = 1; i &lt;=10; i++) \n       &#123;\n          System.out.println(Thread.currentThread().getName()+\"\\t\"+i+\"\\t totalLoopNumber: \"+totalLoopNumber);\n       &#125;\n       //3 通知\n       number = 3;\n       c3.signal();\n     &#125; catch (Exception e) &#123;\n       e.printStackTrace();\n     &#125; finally &#123;\n       lock.unlock();\n     &#125;\n  &#125;  \n  \n  public void print15(int totalLoopNumber)\n  &#123;\n     lock.lock();\n     try \n     &#123;\n       //1 判断\n       while(number != 3)\n       &#123;\n          //A 就要停止\n          c3.await();\n       &#125;\n       //2 干活\n       for (int i = 1; i &lt;=15; i++) \n       &#123;\n          System.out.println(Thread.currentThread().getName()+\"\\t\"+i+\"\\t totalLoopNumber: \"+totalLoopNumber);\n       &#125;\n       //3 通知\n       number = 1;\n       c1.signal();\n     &#125; catch (Exception e) &#123;\n       e.printStackTrace();\n     &#125; finally &#123;\n       lock.unlock();\n     &#125;\n  &#125;  \n&#125;\n \n \n/**\n * \n * @Description: \n * 多线程之间按顺序调用，实现A->B->C\n * 三个线程启动，要求如下：\n * \n * AA打印5次，BB打印10次，CC打印15次\n * 接着\n * AA打印5次，BB打印10次，CC打印15次\n * ......来10轮  \n *\n */\npublic class ThreadOrderAccess\n&#123;\n  public static void main(String[] args)\n  &#123;\n     ShareResource sr = new ShareResource();\n     \n     new Thread(() -> &#123;\n       for (int i = 1; i &lt;=10; i++) \n       &#123;\n          sr.print5(i);\n       &#125;\n     &#125;, \"AA\").start();\n     new Thread(() -> &#123;\n       for (int i = 1; i &lt;=10; i++) \n       &#123;\n          sr.print10(i);\n       &#125;\n     &#125;, \"BB\").start();\n     new Thread(() -> &#123;\n       for (int i = 1; i &lt;=10; i++) \n       &#123;\n          sr.print15(i);\n       &#125;\n     &#125;, \"CC\").start();   \n  &#125;\n&#125;\n\n六、LockSupport与线程中断1、线程中断机制1、如何停止、中断一个运行中的线程？？\n2、什么是中断？首先        一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。所以，Thread.stop, Thread.suspend, Thread.resume 都已经被废弃了。\n其次        在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。因此，Java提供了一种用于停止线程的机制——中断。\n​\t\t中断只是一种协作机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。若要中断一个线程，你需要手动调用该线程的interrupt方法，该方法也仅仅是将线程对象的中断标识设成true；接着你需要自己写代码不断地检测当前线程的标识位，如果为true，表示别的线程要求这条线程中断，此时究竟该做什么需要你自己写代码实现。\n​\t\t每个线程对象中都有一个标识，用于表示线程是否被中断；该标识位为true表示中断，为false表示未中断；通过调用线程对象的interrupt方法将该线程的标识位设为true；可以在别的线程中调用，也可以在自己的线程中调用\n3、中断的相关API方法\n\n\npublic void interrupt()\n实例方法，实例方法interrupt()仅仅是设置线程的中断状态为true，不会停止线程\n\n\n\npublic static boolean interrupted()\n静态方法，Thread.interrupted();  判断线程是否被中断，并清除当前中断状态这个方法做了两件事：1 返回当前线程的中断状态2 将当前线程的中断状态设为false 这个方法有点不好理解，因为连续调用两次的结果可能不一样。\n\n\npublic boolean isInterrupted()\n实例方法，判断当前线程是否被中断（通过检查中断标志位）\n\n\n2、如何使用中断标识停止线程？在需要中断的线程中不断监听中断状态，一旦发生中断，就执行相应的中断处理业务逻辑。\n1、通过一个volatile变量实现public class InterruptDemo&#123;\n    \n\tpublic volatile static boolean exit = false;\n    \tpublic static class T extends Thread &#123;\n        @Override\n        public void run() &#123;\n            while (true) &#123;\n                //循环处理业务\n                if (exit) &#123;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    public static void setExit() &#123;\n        exit = true;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        T t = new T();\n        t.start();\n        TimeUnit.SECONDS.sleep(3);\n        setExit();\n    &#125;\n&#125;\n\n代码中启动了一个线程，线程的run方法中有个死循环，内部通过exit变量的值来控制是否退出。TimeUnit.SECONDS.sleep(3);让主线程休眠3秒，此处为什么使用TimeUnit？TimeUnit使用更方便一些，能够很清晰的控制休眠时间，底层还是转换为Thread.sleep实现的。程序有个重点：volatile关键字，exit变量必须通过这个修饰，如果把这个去掉，程序无法正常退出。volatile控制了变量在多线程中的可见性。\n2、通过AtomicBooleanpublic class StopThreadDemo\n&#123;\n    private final static AtomicBoolean atomicBoolean = new AtomicBoolean(true);\n\n    public static void main(String[] args)\n    &#123;\n        Thread t1 = new Thread(() -> &#123;\n            while(atomicBoolean.get())\n            &#123;\n                try &#123; TimeUnit.MILLISECONDS.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n                System.out.println(\"-----hello\");\n            &#125;\n        &#125;, \"t1\");\n        t1.start();\n\n        try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        atomicBoolean.set(false);\n    &#125;\n&#125;\n\n3、通过Thread类自带的中断api方法实现\n实例方法interrupt()，没有返回值\n\n\n\n\n\npublic void interrupt()\n实例方法，调用interrupt()方法仅仅是在当前线程中打了一个停止的标记，并不是真正立刻停止线程。\n\n\n\n\n\n\n实例方法isInterrupted，返回布尔值\n\n\n\n\n\npublic boolean isInterrupted()\n实例方法，获取中断标志位的当前值是什么，判断当前线程是否被中断（通过检查中断标志位），默认是false\n\n\n\n\npublic class InterruptDemo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Thread t1 = new Thread(() -> &#123;\n            while(true)\n            &#123;\n                if(Thread.currentThread().isInterrupted())\n                &#123;\n                    System.out.println(\"-----t1 线程被中断了，break，程序结束\");\n                    break;\n                &#125;\n                System.out.println(\"-----hello\");\n            &#125;\n        &#125;, \"t1\");\n        t1.start();\n\n        System.out.println(\"**************\"+t1.isInterrupted());\n        //暂停5毫秒\n        try &#123; TimeUnit.MILLISECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n        t1.interrupt();\n        System.out.println(\"**************\"+t1.isInterrupted());\n    &#125;\n&#125;\n\n运行上面的程序，程序可以正常结束。线程内部有个中断标志，当调用线程的interrupt()实例方法之后，线程的中断标志会被置为true，可以通过线程的实例方法isInterrupted()获取线程的中断标志。\n4、当前线程的中断标识为true，是不是就立刻停止？具体来说，当对一个线程，调用 interrupt() 时：\n①  如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。所以， interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。\n②  如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。\npublic class InterruptDemo2 &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        Thread t1 = new Thread(() -> &#123;\n            for (int i = 0; i &lt; 300; i++) &#123;\n                System.out.println(\"-------\" + i);\n            &#125;\n            System.out.println(\"after t1.interrupt()--第2次---: \" + Thread.currentThread().isInterrupted());\n        &#125;, \"t1\");\n        t1.start();\n\n        System.out.println(\"before t1.interrupt()----: \" + t1.isInterrupted());\n        //实例方法interrupt()仅仅是设置线程的中断状态位设置为true，不会停止线程\n        t1.interrupt();\n        //活动状态,t1线程还在执行中\n        try &#123;\n            TimeUnit.MILLISECONDS.sleep(3);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(\"after t1.interrupt()--第1次---: \" + t1.isInterrupted());\n        //非活动状态,t1线程不在执行中，已经结束执行了。\n        try &#123;\n            TimeUnit.MILLISECONDS.sleep(3000);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(\"after t1.interrupt()--第3次---: \" + t1.isInterrupted());\n    &#125;\n&#125;\n\n\n\n中断只是一种协同机制，修改中断标识位仅此而已，不是立刻stop打断\n5、静态方法Thread.interrupted()/**\n * 作用是测试当前线程是否被中断（检查中断标志），返回一个boolean并清除中断状态，\n * 第二次再调用时中断状态已经被清除，将返回一个false。\n */\npublic class InterruptDemo\n&#123;\n\n    public static void main(String[] args) throws InterruptedException\n    &#123;\n        System.out.println(Thread.currentThread().getName()+\"---\"+Thread.interrupted());\n        System.out.println(Thread.currentThread().getName()+\"---\"+Thread.interrupted());\n        System.out.println(\"111111\");\n        Thread.currentThread().interrupt();\n        System.out.println(\"222222\");\n        System.out.println(Thread.currentThread().getName()+\"---\"+Thread.interrupted());\n        System.out.println(Thread.currentThread().getName()+\"---\"+Thread.interrupted());\n    &#125;\n&#125;\n\n\n\n\npublic static boolean interrupted()\n静态方法，Thread.interrupted();  判断线程是否被中断，并清除当前中断状态，类似i++这个方法做了两件事：1 返回当前线程的中断状态2 将当前线程的中断状态设为false 这个方法有点不好理解，因为连续调用两次的结果可能不一样。\n\n\n\n\n都会返回中断状态，两者对比\n\n\n6、总结线程中断相关的方法：\ninterrupt()方法是一个实例方法        它通知目标线程中断，也就是设置目标线程的中断标志位为true，中断标志位表示当前线程已经被中断了。\nisInterrupted()方法也是一个实例方法        它判断当前线程是否被中断（通过检查中断标志位）并获取中断标志\nThread类的静态方法interrupted()        返回当前线程的中断状态(boolean类型)且将当前线程的中断状态设为false，此方法调用之后会清除当前线程的中断标志位的状态（将中断标志置为false了），返回当前值并清零置false\n3、LockSupport是什么LockSupport位于java.util.concurrent（简称juc）包中，算是juc中一个基础类，juc中很多地方都会使用LockSupport，非常重要，希望大家一定要掌握。\n关于线程等待&#x2F;唤醒的方法，前面的文章中我们已经讲过2种了：\n\n方式1：使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程\n方式2：使用juc包中Condition的await()方法让线程等待，使用signal()方法唤醒线程\n\n\n\n\nLockSupport是用来创建锁和其他同步类的基本线程阻塞原语。\n下面这句话，后面详细说LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程\n4、线程等待唤醒机制1、3种让线程等待和唤醒的方法\n使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程\n使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程\nLockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程\n\n2、Object类中的wait和notify方法实现线程等待和唤醒/**\n *\n * 要求：t1线程等待3秒钟，3秒钟后t2线程唤醒t1线程继续工作\n *\n * 1 正常程序演示\n *\n * 以下异常情况：\n * 2 wait方法和notify方法，两个都去掉同步代码块后看运行效果\n *   2.1 异常情况\n *   Exception in thread \"t1\" java.lang.IllegalMonitorStateException at java.lang.Object.wait(Native Method)\n *   Exception in thread \"t2\" java.lang.IllegalMonitorStateException at java.lang.Object.notify(Native Method)\n *   2.2 结论\n *   Object类中的wait、notify、notifyAll用于线程等待和唤醒的方法，都必须在synchronized内部执行（必须用到关键字synchronized）。\n *\n * 3 将notify放在wait方法前面\n *   3.1 程序一直无法结束\n *   3.2 结论\n *   先wait后notify、notifyall方法，等待中的线程才会被唤醒，否则无法唤醒\n */\npublic class LockSupportDemo\n&#123;\n\n    public static void main(String[] args)//main方法，主线程一切程序入口\n    &#123;\n        Object objectLock = new Object(); //同一把锁，类似资源类\n\n        new Thread(() -> &#123;\n            synchronized (objectLock) &#123;\n                try &#123;\n                    objectLock.wait();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\"被唤醒了\");\n        &#125;,\"t1\").start();\n\n        //暂停几秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(3L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            synchronized (objectLock) &#123;\n                objectLock.notify();\n            &#125;\n\n            //objectLock.notify();\n\n            /*synchronized (objectLock) &#123;\n                try &#123;\n                    objectLock.wait();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;*/\n        &#125;,\"t2\").start();\n    &#125;\n&#125;\n\n1、正常public class LockSupportDemo\n&#123;\n    public static void main(String[] args)//main方法，主线程一切程序入口\n    &#123;\n        Object objectLock = new Object(); //同一把锁，类似资源类\n\n        new Thread(() -> &#123;\n            synchronized (objectLock) &#123;\n                try &#123;\n                    objectLock.wait();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\"被唤醒了\");\n        &#125;,\"t1\").start();\n\n        //暂停几秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(3L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            synchronized (objectLock) &#123;\n                objectLock.notify();\n            &#125;\n        &#125;,\"t2\").start();\n    &#125;\n&#125;\n\n2、异常1/**\n * 要求：t1线程等待3秒钟，3秒钟后t2线程唤醒t1线程继续工作\n * 以下异常情况：\n * 2 wait方法和notify方法，两个都去掉同步代码块后看运行效果\n *   2.1 异常情况\n *   Exception in thread \"t1\" java.lang.IllegalMonitorStateException at java.lang.Object.wait(Native Method)\n *   Exception in thread \"t2\" java.lang.IllegalMonitorStateException at java.lang.Object.notify(Native Method)\n *   2.2 结论\n *   Object类中的wait、notify、notifyAll用于线程等待和唤醒的方法，都必须在synchronized内部执行（必须用到关键字synchronized）。\n */\npublic class LockSupportDemo\n&#123;\n\n    public static void main(String[] args)//main方法，主线程一切程序入口\n    &#123;\n        Object objectLock = new Object(); //同一把锁，类似资源类\n\n        new Thread(() -> &#123;\n                try &#123;\n                    objectLock.wait();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\"被唤醒了\");\n        &#125;,\"t1\").start();\n\n        //暂停几秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(3L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            objectLock.notify();\n        &#125;,\"t2\").start();\n    &#125;\n&#125;\n\nwait方法和notify方法，两个都去掉同步代码块\n\n3、异常2/**\n *\n * 要求：t1线程等待3秒钟，3秒钟后t2线程唤醒t1线程继续工作\n *\n * 3 将notify放在wait方法前先执行，t1先notify了，3秒钟后t2线程再执行wait方法\n *   3.1 程序一直无法结束\n *   3.2 结论\n *   先wait后notify、notifyall方法，等待中的线程才会被唤醒，否则无法唤醒\n */\npublic class LockSupportDemo\n&#123;\n\n    public static void main(String[] args)//main方法，主线程一切程序入口\n    &#123;\n        Object objectLock = new Object(); //同一把锁，类似资源类\n\n        new Thread(() -> &#123;\n            synchronized (objectLock) &#123;\n                objectLock.notify();\n            &#125;\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\"通知了\");\n        &#125;,\"t1\").start();\n\n        //t1先notify了，3秒钟后t2线程再执行wait方法\n        try &#123; TimeUnit.SECONDS.sleep(3L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            synchronized (objectLock) &#123;\n                try &#123;\n                    objectLock.wait();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\"被唤醒了\");\n        &#125;,\"t2\").start();\n    &#125;\n&#125;\n\n将notify放在wait方法前面\n程序无法执行，无法唤醒\n4、总结wait和notify方法必须要在同步块或者方法里面，且成对出现使用\n先wait后notify才OK\n3、Condition接口中的await后signal方法实现线程的等待和唤醒1、正常public class LockSupportDemo2\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Lock lock = new ReentrantLock();\n        Condition condition = lock.newCondition();\n\n        new Thread(() -> &#123;\n            lock.lock();\n            try\n            &#123;\n                System.out.println(Thread.currentThread().getName()+\"\\t\"+\"start\");\n                condition.await();\n                System.out.println(Thread.currentThread().getName()+\"\\t\"+\"被唤醒\");\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; finally &#123;\n                lock.unlock();\n            &#125;\n        &#125;,\"t1\").start();\n\n        //暂停几秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(3L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            lock.lock();\n            try\n            &#123;\n                condition.signal();\n            &#125; catch (Exception e) &#123;\n                e.printStackTrace();\n            &#125; finally &#123;\n                lock.unlock();\n            &#125;\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\"通知了\");\n        &#125;,\"t2\").start();\n\n    &#125;\n&#125;\n\n2、异常1/**\n * 异常：\n * condition.await();和condition.signal();都触发了IllegalMonitorStateException异常\n *\n * 原因：调用condition中线程等待和唤醒的方法的前提是，要在lock和unlock方法中,要有锁才能调用\n */\npublic class LockSupportDemo2\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Lock lock = new ReentrantLock();\n        Condition condition = lock.newCondition();\n\n        new Thread(() -> &#123;\n            try\n            &#123;\n                System.out.println(Thread.currentThread().getName()+\"\\t\"+\"start\");\n                condition.await();\n                System.out.println(Thread.currentThread().getName()+\"\\t\"+\"被唤醒\");\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;,\"t1\").start();\n\n        //暂停几秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(3L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            try\n            &#123;\n                condition.signal();\n            &#125; catch (Exception e) &#123;\n                e.printStackTrace();\n            &#125;\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\"通知了\");\n        &#125;,\"t2\").start();\n\n    &#125;\n&#125;\n\n去掉lock&#x2F;unlock\n\ncondition.await();和 condition.signal();都触发了 IllegalMonitorStateException异常。\n结论：lock、unlock对里面才能正确调用调用condition中线程等待和唤醒的方法\n3、异常2/**\n * 异常：\n * 程序无法运行\n *\n * 原因：先await()后signal才OK，否则线程无法被唤醒\n */\npublic class LockSupportDemo2\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Lock lock = new ReentrantLock();\n        Condition condition = lock.newCondition();\n\n        new Thread(() -> &#123;\n            lock.lock();\n            try\n            &#123;\n                condition.signal();\n                System.out.println(Thread.currentThread().getName()+\"\\t\"+\"signal\");\n            &#125; catch (Exception e) &#123;\n                e.printStackTrace();\n            &#125;finally &#123;\n                lock.unlock();\n            &#125;\n        &#125;,\"t1\").start();\n\n        //暂停几秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(3L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            lock.lock();\n            try\n            &#123;\n                System.out.println(Thread.currentThread().getName()+\"\\t\"+\"等待被唤醒\");\n                condition.await();\n                System.out.println(Thread.currentThread().getName()+\"\\t\"+\"被唤醒\");\n            &#125; catch (Exception e) &#123;\n                e.printStackTrace();\n            &#125;finally &#123;\n                lock.unlock();\n            &#125;\n        &#125;,\"t2\").start();\n\n    &#125;\n&#125;\n\n先signal后await\n4、总结Condtion中的线程等待和唤醒方法之前，需要先获取锁\n一定要先await后signal，不要反了\n4、Object和Condition使用的限制条件线程先要获得并持有锁，必须在锁块(synchronized或lock)中\n必须要先等待后唤醒，线程才能够被唤醒\n5、LockSupport类中的park等待和unpark唤醒通过park()和unpark(thread)方法来实现阻塞和唤醒线程的操作\n\nLockSupport是用来创建锁和其他同步类的基本线程阻塞原语。\n​\t\tLockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能， 每个线程都有一个许可(permit)，permit只有两个值1和零，默认是零。可以把许可看成是一种(0,1)信号量（Semaphore），但与 Semaphore 不同的是，许可的累加上限是1。\n1、主要方法\n阻塞\npark() &#x2F;park(Object blocker) \n\n阻塞当前线程&#x2F;阻塞传入的具体线程\n唤醒\nunpark(Thread thread) \n\n唤醒处于阻塞状态的指定线程\n2、代码正常+无锁块要求\npublic class LockSupportDemo3\n&#123;\n    public static void main(String[] args)\n    &#123;\n        //正常使用+不需要锁块\nThread t1 = new Thread(() -> &#123;\n    System.out.println(Thread.currentThread().getName()+\" \"+\"1111111111111\");\n    LockSupport.park();\n    System.out.println(Thread.currentThread().getName()+\" \"+\"2222222222222------end被唤醒\");\n&#125;,\"t1\");\nt1.start();\n\n//暂停几秒钟线程\ntry &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\nLockSupport.unpark(t1);\nSystem.out.println(Thread.currentThread().getName()+\"   -----LockSupport.unparrk() invoked over\");\n\n    &#125;\n&#125;\n\n之前错误的先唤醒后等待，LockSupport照样支持\npublic class T1\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Thread t1 = new Thread(() -> &#123;\n            try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+System.currentTimeMillis());\n            LockSupport.park();\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+System.currentTimeMillis()+\"---被叫醒\");\n        &#125;,\"t1\");\n        t1.start();\n\n        try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        LockSupport.unpark(t1);\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+System.currentTimeMillis()+\"---unpark over\");\n    &#125;\n&#125;\n\n\n七、集合不安全1、线程不安全错误java.util.ConcurrentModificationException\nArrayList在迭代的时候如果同时对其进行修改就会\n抛出java.util.ConcurrentModificationException异常 并发修改异常\n\n2、List不安全List&lt;String> list = new ArrayList&lt;>();\nfor (int i = 0; i &lt;30 ; i++) &#123;\n            new Thread(()->&#123;\n                list.add(UUID.randomUUID().toString().substring(0,8));\n                System.out.println(list);\n            &#125;,String.valueOf(i)).start();\n        &#125;\n \n// 看ArrayList的源码\npublic boolean add(E e) &#123;\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n&#125;\n// 没有synchronized线程不安全\n\n1、 解决方案1、VectorList list = new Vector&lt;>();\n\n\n// 看Vector的源码\npublic synchronized boolean add(E e) &#123;\n    modCount++;\n    ensureCapacityHelper(elementCount + 1);\n    elementData[elementCount++] = e;\n    return true;\n&#125;\n// 有synchronized线程安全\n\n2、CollectionsList list = Collections.synchronizedList(new ArrayList&lt;>());\n// Collections提供了方法synchronizedList保证list是同步线程安全的\n// 那HashMap，HashSet是线程安全的吗？也不是,所以有同样的线程安全方法\n\n\n3、写时复制(JUC)List&lt;String> list = new CopyOnWriteArrayList&lt;>();\n\n\n4、CopyOnWrite理论/**\n * Appends the specified element to the end of this list.\n *\n * @param e element to be appended to this list\n * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)\n */\npublic boolean add(E e) &#123;\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try &#123;\n        Object[] elements = getArray();\n        int len = elements.length;\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        newElements[len] = e;\n        setArray(newElements);\n        return true;\n    &#125; finally &#123;\n        lock.unlock();\n    &#125;\n&#125;\n\n​\t\tCopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。添加元素后，再将原容器的引用指向新的容器setArray(newElements)。这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。\n3、Set不安全Set&lt;String> set = new HashSet&lt;>();//线程不安全\n \nSet&lt;String> set = new CopyOnWriteArraySet&lt;>();//线程安全\nHashSet底层数据结构是什么？\nHashMap  ?\n \n但HashSet的add是放一个值，而HashMap是放K、V键值对\n \npublic HashSet() &#123;\n    map = new HashMap&lt;>();\n&#125;\n \nprivate static final Object PRESENT = new Object();\n \npublic boolean add(E e) &#123;\n    return map.put(e, PRESENT)==null;\n&#125;\n\n4、Map不安全Map&lt;String,String> map = new HashMap&lt;>();//线程不安全\n\nMap&lt;String,String> map = new ConcurrentHashMap&lt;>();//线程安全\n\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n/**\n * 请举例说明集合类是不安全的\n */\npublic class NotSafeDemo &#123;\n    public static void main(String[] args) &#123;\n\n        Map&lt;String,String> map = new ConcurrentHashMap&lt;>();\n        for (int i = 0; i &lt;30 ; i++) &#123;\n            new Thread(()->&#123;\n                map.put(Thread.currentThread().getName(),UUID.randomUUID().toString().substring(0,8));\n                System.out.println(map);\n            &#125;,String.valueOf(i)).start();\n        &#125;\n\n\n    &#125;\n\n    private static void setNoSafe() &#123;\n        Set&lt;String> set = new CopyOnWriteArraySet&lt;>();\n        for (int i = 0; i &lt;30 ; i++) &#123;\n            new Thread(()->&#123;\n                set.add(UUID.randomUUID().toString().substring(0,8));\n                System.out.println(set);\n            &#125;,String.valueOf(i)).start();\n        &#125;\n    &#125;\n\n    private static void listNoSafe() &#123;\n        //        List&lt;String> list = Arrays.asList(\"a\",\"b\",\"c\");\n        //        list.forEach(System.out::println);\n        //写时复制\n        List&lt;String> list = new CopyOnWriteArrayList&lt;>();\n        // new CopyOnWriteArrayList&lt;>();\n        //Collections.synchronizedList(new ArrayList&lt;>());\n        //new Vector&lt;>();//new ArrayList&lt;>();\n\n        for (int i = 0; i &lt;30 ; i++) &#123;\n                    new Thread(()->&#123;\n                        list.add(UUID.randomUUID().toString().substring(0,8));\n                        System.out.println(list);\n                    &#125;,String.valueOf(i)).start();\n                &#125;\n    &#125;\n\n\n&#125;\n\n    /**\n     * 写时复制\n     CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，\n     而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。\n     添加元素后，再将原容器的引用指向新的容器setArray(newElements)。\n     这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。\n     所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。\n\n     *\n     *\n     *\n     *\n\n    public boolean add(E e) &#123;\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try &#123;\n            Object[] elements = getArray();\n            int len = elements.length;\n            Object[] newElements = Arrays.copyOf(elements, len + 1);\n            newElements[len] = e;\n            setArray(newElements);\n            return true;\n        &#125; finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n     */\n\n\n\n八、JUC强大的辅助类1、CountDownLatch减少计数CountDownLatch称之为闭锁，它可以使一个或一批线程在闭锁上等待，等到其他线程执行完相应操作后，闭锁打开，这些等待的线程才可以继续执行。确切的说，闭锁在内部维护了一个倒计数器。通过该计数器的值来决定闭锁的状态，从而决定是否允许等待的线程继续执行。\n常用方法：\n**public CountDownLatch(int count)**：构造方法，count表示计数器的值，不能小于0，否者会报异常。\npublic void await() throws InterruptedException：调用await()会让当前线程等待，直到计数器为0的时候，方法才会返回，此方法会响应线程中断操作。\npublic boolean await(long timeout, TimeUnit unit) throws InterruptedException：限时等待，在超时之前，计数器变为了0，方法返回true，否者直到超时，返回false，此方法会响应线程中断操作。\n**public void countDown()**：让计数器减1\nCountDownLatch使用步骤：\n\n创建CountDownLatch对象\n调用其实例方法await()，让当前线程等待\n调用countDown()方法，让计数器减1\n当计数器变为0的时候，await()方法会返回\n\npackage com.xue.thread;\n\nimport java.util.concurrent.CountDownLatch;\n \n \n/**\n * \n * @Description:\n *  *让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。\n * \n * CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。\n * 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，\n * 当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。\n * \n * 解释：6个同学陆续离开教室后值班同学才可以关门。\n * \n * main主线程必须要等前面6个线程完成全部工作后，自己才能开干 \n */\npublic class CountDownLatchDemo\n&#123;\n   public static void main(String[] args) throws InterruptedException\n   &#123;\n         CountDownLatch countDownLatch = new CountDownLatch(6);\n       \n       for (int i = 1; i &lt;=6; i++) //6个上自习的同学，各自离开教室的时间不一致\n       &#123;\n          new Thread(() -> &#123;\n              System.out.println(Thread.currentThread().getName()+\"\\t 号同学离开教室\");\n              countDownLatch.countDown();\n          &#125;, String.valueOf(i)).start();\n       &#125;\n       countDownLatch.await();\n       System.out.println(Thread.currentThread().getName()+\"\\t****** 班长关门走人，main线程是班长\");\n          \n   &#125;\n&#125;\n\n\nCountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。\n其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，\n当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。\n\n示例1假如有这样一个需求，当我们需要解析一个Excel里多个sheet的数据时，可以考虑使用多线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要统计解析总耗时。分析一下：解析每个sheet耗时可能不一样，总耗时就是最长耗时的那个操作。\n我们能够想到的最简单的做法是使用join，代码如下：\nimport java.util.concurrent.TimeUnit;\n\npublic class Demo1 &#123;\n    public static class T extends Thread &#123;\n        //休眠时间（秒）\n        int sleepSeconds;\n        public T(String name, int sleepSeconds) &#123;\n            super(name);\n            this.sleepSeconds = sleepSeconds;\n        &#125;\n        @Override\n        public void run() &#123;\n            Thread ct = Thread.currentThread();\n            long startTime = System.currentTimeMillis();\n            System.out.println(startTime + \",\" + ct.getName() + \",开始处理!\");\n            try &#123;\n                //模拟耗时操作，休眠sleepSeconds秒\n                TimeUnit.SECONDS.sleep(this.sleepSeconds);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            long endTime = System.currentTimeMillis();\n            System.out.println(endTime + \",\" + ct.getName() + \",处理完毕,耗时:\" + (endTime - startTime));\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        long starTime = System.currentTimeMillis();\n        T t1 = new T(\"解析sheet1线程\", 2);\n        t1.start();\n        T t2 = new T(\"解析sheet2线程\", 5);\n        t2.start();\n        t1.join();\n        t2.join();\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"总耗时:\" + (endTime - starTime));\n    &#125;\n&#125;\n\n1563767560271,解析sheet1线程,开始处理!\n1563767560272,解析sheet2线程,开始处理!\n1563767562273,解析sheet1线程,处理完毕,耗时:2002\n1563767565274,解析sheet2线程,处理完毕,耗时:5002\n总耗时:5005\n\n代码中启动了2个解析sheet的线程，第一个耗时2秒，第二个耗时5秒，最终结果中总耗时：5秒。上面的关键技术点是线程的join()方法，此方法会让当前线程等待被调用的线程完成之后才能继续。可以看一下join的源码，内部其实是在synchronized方法中调用了线程的wait方法，最后被调用的线程执行完毕之后，由jvm自动调用其notifyAll()方法，唤醒所有等待中的线程。这个notifyAll()方法是由jvm内部自动调用的，jdk源码中是看不到的，需要看jvm源码，有兴趣的同学可以去查一下。所以JDK不推荐在线程上调用wait、notify、notifyAll方法。\n而在JDK1.5之后的并发包中提供的CountDownLatch也可以实现join的这个功能。\n我们使用CountDownLatch来完成上面示例中使用join实现的功能，代码如下：\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic class Demo2 &#123;\n    public static class T extends Thread &#123;\n        //休眠时间（秒）\n        int sleepSeconds;\n        CountDownLatch countDownLatch;\n        public T(String name, int sleepSeconds, CountDownLatch countDownLatch) &#123;\n            super(name);\n            this.sleepSeconds = sleepSeconds;\n            this.countDownLatch = countDownLatch;\n        &#125;\n        @Override\n        public void run() &#123;\n            Thread ct = Thread.currentThread();\n            long startTime = System.currentTimeMillis();\n            System.out.println(startTime + \",\" + ct.getName() + \",开始处理!\");\n            try &#123;\n                //模拟耗时操作，休眠sleepSeconds秒\n                TimeUnit.SECONDS.sleep(this.sleepSeconds);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; finally &#123;\n                countDownLatch.countDown();\n            &#125;\n            long endTime = System.currentTimeMillis();\n            System.out.println(endTime + \",\" + ct.getName() + \",处理完毕,耗时:\" + (endTime - startTime));\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \"线程 start!\");\n        CountDownLatch countDownLatch = new CountDownLatch(2);\n        long starTime = System.currentTimeMillis();\n        T t1 = new T(\"解析sheet1线程\", 2, countDownLatch);\n        t1.start();\n        T t2 = new T(\"解析sheet2线程\", 5, countDownLatch);\n        t2.start();\n        countDownLatch.await();\n        System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \"线程 end!\");\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"总耗时:\" + (endTime - starTime));\n    &#125;\n&#125;\n\n1563767580511,main线程 start!\n1563767580513,解析sheet1线程,开始处理!\n1563767580513,解析sheet2线程,开始处理!\n1563767582515,解析sheet1线程,处理完毕,耗时:2002\n1563767585515,解析sheet2线程,处理完毕,耗时:5002\n1563767585515,main线程 end!\n总耗时:5003\n\n从结果中看出，效果和join实现的效果一样，代码中创建了计数器为2的CountDownLatch，主线程中调用countDownLatch.await();会让主线程等待，t1、t2线程中模拟执行耗时操作，最终在finally中调用了countDownLatch.countDown();,此方法每调用一次，CountDownLatch内部计数器会减1，当计数器变为0的时候，主线程中的await()会返回，然后继续执行。注意：上面的countDown()这个是必须要执行的方法，所以放在finally中执行。\n示例2等待指定的时间\n还是上面的示例，2个线程解析2个sheet，主线程等待2个sheet解析完成。主线程说，我等待2秒，你们还是无法处理完成，就不等待了，直接返回。如下代码：\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic class Demo3 &#123;\n    public static class T extends Thread &#123;\n        //休眠时间（秒）\n        int sleepSeconds;\n        CountDownLatch countDownLatch;\n        public T(String name, int sleepSeconds, CountDownLatch countDownLatch) &#123;\n            super(name);\n            this.sleepSeconds = sleepSeconds;\n            this.countDownLatch = countDownLatch;\n        &#125;\n        @Override\n        public void run() &#123;\n            Thread ct = Thread.currentThread();\n            long startTime = System.currentTimeMillis();\n            System.out.println(startTime + \",\" + ct.getName() + \",开始处理!\");\n            try &#123;\n                //模拟耗时操作，休眠sleepSeconds秒\n                TimeUnit.SECONDS.sleep(this.sleepSeconds);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; finally &#123;\n                countDownLatch.countDown();\n            &#125;\n            long endTime = System.currentTimeMillis();\n            System.out.println(endTime + \",\" + ct.getName() + \",处理完毕,耗时:\" + (endTime - startTime));\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \"线程 start!\");\n        CountDownLatch countDownLatch = new CountDownLatch(2);\n        long starTime = System.currentTimeMillis();\n        T t1 = new T(\"解析sheet1线程\", 2, countDownLatch);\n        t1.start();\n        T t2 = new T(\"解析sheet2线程\", 5, countDownLatch);\n        t2.start();\n        boolean result = countDownLatch.await(2, TimeUnit.SECONDS);\n        System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \"线程 end!\");\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"主线程耗时:\" + (endTime - starTime) + \",result:\" + result);\n    &#125;\n&#125;\n\n1563767637316,main线程 start!\n1563767637320,解析sheet1线程,开始处理!\n1563767637320,解析sheet2线程,开始处理!\n1563767639321,解析sheet1线程,处理完毕,耗时:2001\n1563767639322,main线程 end!\n主线程耗时:2004,result:false\n1563767642322,解析sheet2线程,处理完毕,耗时:5002\n\n从输出结果中可以看出，线程2耗时了5秒，主线程耗时了2秒，主线程中调用countDownLatch.await(2, TimeUnit.SECONDS);，表示最多等2秒，不管计数器是否为0，await方法都会返回，若等待时间内，计数器变为0了，立即返回true，否则超时后返回false。\n示例32个CountDown结合使用的示例\n有3个人参见跑步比赛，需要先等指令员发指令枪后才能开跑，所有人都跑完之后，指令员喊一声，大家跑完了。\n示例代码：\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic class Demo4 &#123;\n    public static class T extends Thread &#123;\n        //跑步耗时（秒）\n        int runCostSeconds;\n        CountDownLatch commanderCd;\n        CountDownLatch countDown;\n        public T(String name, int runCostSeconds, CountDownLatch commanderCd, CountDownLatch countDown) &#123;\n            super(name);\n            this.runCostSeconds = runCostSeconds;\n            this.commanderCd = commanderCd;\n            this.countDown = countDown;\n        &#125;\n        @Override\n        public void run() &#123;\n            //等待指令员枪响\n            try &#123;\n                commanderCd.await();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            Thread ct = Thread.currentThread();\n            long startTime = System.currentTimeMillis();\n            System.out.println(startTime + \",\" + ct.getName() + \",开始跑!\");\n            try &#123;\n                //模拟耗时操作，休眠runCostSeconds秒\n                TimeUnit.SECONDS.sleep(this.runCostSeconds);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; finally &#123;\n                countDown.countDown();\n            &#125;\n            long endTime = System.currentTimeMillis();\n            System.out.println(endTime + \",\" + ct.getName() + \",跑步结束,耗时:\" + (endTime - startTime));\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \"线程 start!\");\n        CountDownLatch commanderCd = new CountDownLatch(1);\n        CountDownLatch countDownLatch = new CountDownLatch(3);\n        long starTime = System.currentTimeMillis();\n        T t1 = new T(\"小张\", 2, commanderCd, countDownLatch);\n        t1.start();\n        T t2 = new T(\"小李\", 5, commanderCd, countDownLatch);\n        t2.start();\n        T t3 = new T(\"路人甲\", 10, commanderCd, countDownLatch);\n        t3.start();\n        //主线程休眠5秒,模拟指令员准备发枪耗时操作\n        TimeUnit.SECONDS.sleep(5);\n        System.out.println(System.currentTimeMillis() + \",枪响了，大家开始跑\");\n        commanderCd.countDown();\n        countDownLatch.await();\n        long endTime = System.currentTimeMillis();\n        System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \"所有人跑完了，主线程耗时:\" + (endTime - starTime));\n    &#125;\n&#125;\n\n1563767691087,main线程 start!\n1563767696092,枪响了，大家开始跑\n1563767696092,小张,开始跑!\n1563767696092,小李,开始跑!\n1563767696092,路人甲,开始跑!\n1563767698093,小张,跑步结束,耗时:2001\n1563767701093,小李,跑步结束,耗时:5001\n1563767706093,路人甲,跑步结束,耗时:10001\n1563767706093,main所有人跑完了，主线程耗时:15004\n\n代码中，t1、t2、t3启动之后，都阻塞在commanderCd.await();，主线程模拟发枪准备操作耗时5秒，然后调用commanderCd.countDown();模拟发枪操作，此方法被调用以后，阻塞在commanderCd.await();的3个线程会向下执行。主线程调用countDownLatch.await();之后进行等待，每个人跑完之后，调用countDown.countDown();通知一下countDownLatch让计数器减1，最后3个人都跑完了，主线程从countDownLatch.await();返回继续向下执行。\n手写一个并行处理任务的工具类import org.springframework.util.CollectionUtils;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Consumer;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class TaskDisposeUtils &#123;\n    //并行线程数\n    public static final int POOL_SIZE;\n    static &#123;\n        POOL_SIZE = Integer.max(Runtime.getRuntime().availableProcessors(), 5);\n    &#125;\n    /**\n     * 并行处理，并等待结束\n     *\n     * @param taskList 任务列表\n     * @param consumer 消费者\n     * @param &lt;T>\n     * @throws InterruptedException\n     */\n    public static &lt;T> void dispose(List&lt;T> taskList, Consumer&lt;T> consumer) throws InterruptedException &#123;\n        dispose(true, POOL_SIZE, taskList, consumer);\n    &#125;\n    /**\n     * 并行处理，并等待结束\n     *\n     * @param moreThread 是否多线程执行\n     * @param poolSize   线程池大小\n     * @param taskList   任务列表\n     * @param consumer   消费者\n     * @param &lt;T>\n     * @throws InterruptedException\n     */\n    public static &lt;T> void dispose(boolean moreThread, int poolSize, List&lt;T> taskList, Consumer&lt;T> consumer) throws InterruptedException &#123;\n        if (CollectionUtils.isEmpty(taskList)) &#123;\n            return;\n        &#125;\n        if (moreThread &amp;&amp; poolSize > 1) &#123;\n            poolSize = Math.min(poolSize, taskList.size());\n            ExecutorService executorService = null;\n            try &#123;\n                executorService = Executors.newFixedThreadPool(poolSize);\n                CountDownLatch countDownLatch = new CountDownLatch(taskList.size());\n                for (T item : taskList) &#123;\n                    executorService.execute(() -> &#123;\n                        try &#123;\n                            consumer.accept(item);\n                        &#125; finally &#123;\n                            countDownLatch.countDown();\n                        &#125;\n                    &#125;);\n                &#125;\n                countDownLatch.await();\n            &#125; finally &#123;\n                if (executorService != null) &#123;\n                    executorService.shutdown();\n                &#125;\n            &#125;\n        &#125; else &#123;\n            for (T item : taskList) &#123;\n                consumer.accept(item);\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        //生成1-10的10个数字，放在list中，相当于10个任务\n        List&lt;Integer> list = Stream.iterate(1, a -> a + 1).limit(10).collect(Collectors.toList());\n        //启动多线程处理list中的数据，每个任务休眠时间为list中的数值\n        TaskDisposeUtils.dispose(list, item -> &#123;\n            try &#123;\n                long startTime = System.currentTimeMillis();\n                TimeUnit.SECONDS.sleep(item);\n                long endTime = System.currentTimeMillis();\n                System.out.println(System.currentTimeMillis() + \",任务\" + item + \"执行完毕，耗时:\" + (endTime - startTime));\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;);\n        //上面所有任务处理完毕完毕之后，程序才能继续\n        System.out.println(list + \"中的任务都处理完毕!\");\n    &#125;\n&#125;\n\n运行代码输出：\n1563769828130,任务1执行完毕，耗时:1000\n1563769829130,任务2执行完毕，耗时:2000\n1563769830131,任务3执行完毕，耗时:3001\n1563769831131,任务4执行完毕，耗时:4001\n1563769832131,任务5执行完毕，耗时:5001\n1563769833130,任务6执行完毕，耗时:6000\n1563769834131,任务7执行完毕，耗时:7001\n1563769835131,任务8执行完毕，耗时:8001\n1563769837131,任务9执行完毕，耗时:9001\n1563769839131,任务10执行完毕，耗时:10001\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]中的任务都处理完毕!\n\nTaskDisposeUtils是一个并行处理的工具类，可以传入n个任务内部使用线程池进行处理，等待所有任务都处理完成之后，方法才会返回。比如我们发送短信，系统中有1万条短信，我们使用上面的工具，每次取100条并行发送，待100个都处理完毕之后，再取一批按照同样的逻辑发送。\n2、CyclicBarrier循环栅栏CyclicBarrier通常称为循环屏障。它和CountDownLatch很相似，都可以使线程先等待然后再执行。不过CountDownLatch是使一批线程等待另一批线程执行完后再执行；而CyclicBarrier只是使等待的线程达到一定数目后再让它们继续执行。故而CyclicBarrier内部也有一个计数器,计数器的初始值在创建对象时通过构造参数指定,如下所示：\npublic CyclicBarrier(int parties) &#123;\n    this(parties, null);\n&#125;\n\n每调用一次await()方法都将使阻塞的线程数+1，只有阻塞的线程数达到设定值时屏障才会打开，允许阻塞的所有线程继续执行。除此之外，CyclicBarrier还有几点需要注意的地方:\n\nCyclicBarrier的计数器可以重置而CountDownLatch不行，这意味着CyclicBarrier实例可以被重复使用而CountDownLatch只能被使用一次。而这也是循环屏障循环二字的语义所在。\nCyclicBarrier允许用户自定义barrierAction操作，这是个可选操作，可以在创建CyclicBarrier对象时指定\n\npublic CyclicBarrier(int parties, Runnable barrierAction) &#123;\n    if (parties &lt;= 0) throw new IllegalArgumentException();\n    this.parties = parties;\n    this.count = parties;\n    this.barrierCommand = barrierAction;\n&#125;\n\n一旦用户在创建CyclicBarrier对象时设置了barrierAction参数，则在阻塞线程数达到设定值屏障打开前，会调用barrierAction的run()方法完成用户自定义的操作。\npackage com.xue.thread;\n \nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\n \n/**\n * \n *\n * CyclicBarrier\n * 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，\n * 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，\n * 直到最后一个线程到达屏障时，屏障才会开门，所有\n * 被屏障拦截的线程才会继续干活。\n * 线程进入屏障通过CyclicBarrier的await()方法。\n * \n * 集齐7颗龙珠就可以召唤神龙\n */\npublic class CyclicBarrierDemo\n&#123;\n  private static final int NUMBER = 7;\n  \n  public static void main(String[] args)\n  &#123;\n     //CyclicBarrier(int parties, Runnable barrierAction) \n     \n     CyclicBarrier cyclicBarrier = new CyclicBarrier(NUMBER, ()->&#123;System.out.println(\"*****集齐7颗龙珠就可以召唤神龙\");&#125;) ;\n     \n     for (int i = 1; i &lt;= 7; i++) &#123;\n       new Thread(() -> &#123;\n          try &#123;\n            System.out.println(Thread.currentThread().getName()+\"\\t 星龙珠被收集 \");\n            cyclicBarrier.await();\n          &#125; catch (InterruptedException | BrokenBarrierException e) &#123;\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          &#125;\n       \n       &#125;, String.valueOf(i)).start();\n     &#125;\n     \n \n  &#125;\n&#125;\n\n\nCyclicBarrier的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，\n让一组线程到达一个屏障（也可以叫同步点）时被阻塞，\n直到最后一个线程到达屏障时，屏障才会开门，所有\n被屏障拦截的线程才会继续干活。\n线程进入屏障通过CyclicBarrier的await()方法。\n\n示例1 简单使用CyclicBarrier公司组织旅游，大家都有经历过，10个人，中午到饭点了，需要等到10个人都到了才能开饭，先到的人坐那等着，代码如下：\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.TimeUnit;\n\npublic class Demo1 &#123;\n    public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10);\n    public static class T extends Thread &#123;\n        int sleep;\n        public T(String name, int sleep) &#123;\n            super(name);\n            this.sleep = sleep;\n        &#125;\n        @Override\n        public void run() &#123;\n            try &#123;\n                //模拟休眠\n                TimeUnit.SECONDS.sleep(sleep);\n                long starTime = System.currentTimeMillis();\n                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续\n                cyclicBarrier.await();\n                long endTime = System.currentTimeMillis();\n                System.out.println(this.getName() + \",sleep:\" + this.sleep + \" 等待了\" + (endTime - starTime) + \"(ms),开始吃饭了！\");\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; catch (BrokenBarrierException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        for (int i = 1; i &lt;= 10; i++) &#123;\n            new T(\"员工\" + i, i).start();\n        &#125;\n    &#125;\n&#125;\n\n员工1,sleep:1 等待了9000(ms),开始吃饭了！\n员工9,sleep:9 等待了1000(ms),开始吃饭了！\n员工8,sleep:8 等待了2001(ms),开始吃饭了！\n员工7,sleep:7 等待了3001(ms),开始吃饭了！\n员工6,sleep:6 等待了4001(ms),开始吃饭了！\n员工4,sleep:4 等待了6000(ms),开始吃饭了！\n员工5,sleep:5 等待了5000(ms),开始吃饭了！\n员工10,sleep:10 等待了0(ms),开始吃饭了！\n员工2,sleep:2 等待了7999(ms),开始吃饭了！\n员工3,sleep:3 等待了7000(ms),开始吃饭了！\n\n代码中模拟了10个员工上桌吃饭的场景，等待所有员工都到齐了才能开发，可以看到第10个员工最慢，前面的都在等待第10个员工，员工1等待了9秒，上面代码中调用cyclicBarrier.await();会让当前线程等待。当10个员工都调用了cyclicBarrier.await();之后，所有处于等待中的员工都会被唤醒，然后继续运行。\n示例2 循环使用CyclicBarrier对示例1进行改造一下，吃饭完毕之后，所有人都去车上，待所有人都到车上之后，驱车去下一景点玩。\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.TimeUnit;\n\npublic class Demo2 &#123;\n    public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10);\n    public static class T extends Thread &#123;\n        int sleep;\n        public T(String name, int sleep) &#123;\n            super(name);\n            this.sleep = sleep;\n        &#125;\n        //等待吃饭\n        void eat() &#123;\n            try &#123;\n                //模拟休眠\n                TimeUnit.SECONDS.sleep(sleep);\n                long starTime = System.currentTimeMillis();\n                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续\n                cyclicBarrier.await();\n                long endTime = System.currentTimeMillis();\n                System.out.println(this.getName() + \",sleep:\" + this.sleep + \" 等待了\" + (endTime - starTime) + \"(ms),开始吃饭了！\");\n                //休眠sleep时间，模拟当前员工吃饭耗时\n                TimeUnit.SECONDS.sleep(sleep);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; catch (BrokenBarrierException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        //等待所有人到齐之后，开车去下一站\n        void drive() &#123;\n            try &#123;\n                long starTime = System.currentTimeMillis();\n                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续\n                cyclicBarrier.await();\n                long endTime = System.currentTimeMillis();\n                System.out.println(this.getName() + \",sleep:\" + this.sleep + \" 等待了\" + (endTime - starTime) + \"(ms),去下一景点的路上！\");\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; catch (BrokenBarrierException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        @Override\n        public void run() &#123;\n            //等待所有人到齐之后吃饭，先到的人坐那等着，什么事情不要干\n            this.eat();\n            //等待所有人到齐之后开车去下一景点，先到的人坐那等着，什么事情不要干\n            this.drive();\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        for (int i = 1; i &lt;= 10; i++) &#123;\n            new T(\"员工\" + i, i).start();\n        &#125;\n    &#125;\n&#125;\n\n员工10,sleep:10 等待了0(ms),开始吃饭了！\n员工5,sleep:5 等待了5000(ms),开始吃饭了！\n员工6,sleep:6 等待了4000(ms),开始吃饭了！\n员工9,sleep:9 等待了1001(ms),开始吃饭了！\n员工4,sleep:4 等待了6000(ms),开始吃饭了！\n员工3,sleep:3 等待了7000(ms),开始吃饭了！\n员工1,sleep:1 等待了9001(ms),开始吃饭了！\n员工2,sleep:2 等待了8000(ms),开始吃饭了！\n员工8,sleep:8 等待了2001(ms),开始吃饭了！\n员工7,sleep:7 等待了3000(ms),开始吃饭了！\n员工10,sleep:10 等待了0(ms),去下一景点的路上！\n员工1,sleep:1 等待了8998(ms),去下一景点的路上！\n员工5,sleep:5 等待了4999(ms),去下一景点的路上！\n员工4,sleep:4 等待了5999(ms),去下一景点的路上！\n员工3,sleep:3 等待了6998(ms),去下一景点的路上！\n员工2,sleep:2 等待了7998(ms),去下一景点的路上！\n员工9,sleep:9 等待了999(ms),去下一景点的路上！\n员工8,sleep:8 等待了1999(ms),去下一景点的路上！\n员工7,sleep:7 等待了2999(ms),去下一景点的路上！\n员工6,sleep:6 等待了3999(ms),去下一景点的路上！\n\n坑，又是员工10最慢，要提升效率了，不能吃的太多，得减肥。\n代码中CyclicBarrier相当于使用了2次，第一次用于等待所有人到达后开饭，第二次用于等待所有人上车后驱车去下一景点。注意一些先到的员工会在其他人到达之前，都处于等待状态（cyclicBarrier.await();会让当前线程阻塞），无法干其他事情，等到最后一个人到了会唤醒所有人，然后继续。\n\n\n\n\n\n\n\n\n\nCyclicBarrier内部相当于有个计数器（构造方法传入的），每次调用await();后，计数器会减1，并且await()方法会让当前线程阻塞，等待计数器减为0的时候，所有在await()上等待的线程被唤醒，然后继续向下执行，此时计数器又会被还原为创建时的值，然后可以继续再次使用。\n示例3 最后到的人给大家上酒，然后开饭还是示例1中的例子，员工10是最后到达的，让所有人都久等了，那怎么办，得给所有人倒酒，然后开饭，代码如下：\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.TimeUnit;\n\npublic class Demo3 &#123;\n    public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10, () -> &#123;\n        //模拟倒酒，花了2秒，又得让其他9个人等2秒\n        try &#123;\n            TimeUnit.SECONDS.sleep(2);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(Thread.currentThread().getName() + \"说，不好意思，让大家久等了，给大家倒酒赔罪!\");\n    &#125;);\n    public static class T extends Thread &#123;\n        int sleep;\n        public T(String name, int sleep) &#123;\n            super(name);\n            this.sleep = sleep;\n        &#125;\n        @Override\n        public void run() &#123;\n            try &#123;\n                //模拟休眠\n                TimeUnit.SECONDS.sleep(sleep);\n                long starTime = System.currentTimeMillis();\n                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续\n                cyclicBarrier.await();\n                long endTime = System.currentTimeMillis();\n                System.out.println(this.getName() + \",sleep:\" + this.sleep + \" 等待了\" + (endTime - starTime) + \"(ms),开始吃饭了！\");\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; catch (BrokenBarrierException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        for (int i = 1; i &lt;= 10; i++) &#123;\n            new T(\"员工\" + i, i).start();\n        &#125;\n    &#125;\n&#125;\n\n员工10说，不好意思，让大家久等了，给大家倒酒赔罪!\n员工10,sleep:10 等待了2000(ms),开始吃饭了！\n员工1,sleep:1 等待了11000(ms),开始吃饭了！\n员工2,sleep:2 等待了10000(ms),开始吃饭了！\n员工5,sleep:5 等待了7000(ms),开始吃饭了！\n员工7,sleep:7 等待了5000(ms),开始吃饭了！\n员工9,sleep:9 等待了3000(ms),开始吃饭了！\n员工4,sleep:4 等待了8000(ms),开始吃饭了！\n员工3,sleep:3 等待了9001(ms),开始吃饭了！\n员工8,sleep:8 等待了4001(ms),开始吃饭了！\n员工6,sleep:6 等待了6001(ms),开始吃饭了！\n\n代码中创建CyclicBarrier对象时，多传入了一个参数（内部是倒酒操作），先到的人先等待，待所有人都到齐之后，需要先给大家倒酒，然后唤醒所有等待中的人让大家开饭。从输出结果中我们发现，倒酒操作是由最后一个人操作的，最后一个人倒酒完毕之后，才唤醒所有等待中的其他员工，让大家开饭。\n示例4 其中一个人等待中被打断了员工5等待中，突然接了个电话，有点急事，然后就拿起筷子开吃了，其他人会怎么样呢？看着他吃么？\nimport java.sql.Time;\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.TimeUnit;\n\npublic class Demo4 &#123;\n    public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10);\n    public static class T extends Thread &#123;\n        int sleep;\n        public T(String name, int sleep) &#123;\n            super(name);\n            this.sleep = sleep;\n        &#125;\n        @Override\n        public void run() &#123;\n            long starTime = 0, endTime = 0;\n            try &#123;\n                //模拟休眠\n                TimeUnit.SECONDS.sleep(sleep);\n                starTime = System.currentTimeMillis();\n                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续\n                System.out.println(this.getName() + \"到了！\");\n                cyclicBarrier.await();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; catch (BrokenBarrierException e) &#123;\n                e.printStackTrace();\n            &#125;\n            endTime = System.currentTimeMillis();\n            System.out.println(this.getName() + \",sleep:\" + this.sleep + \" 等待了\" + (endTime - starTime) + \"(ms),开始吃饭了！\");\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        for (int i = 1; i &lt;= 10; i++) &#123;\n            int sleep = 0;\n            if (i == 10) &#123;\n                sleep = 10;\n            &#125;\n            T t = new T(\"员工\" + i, sleep);\n            t.start();\n            if (i == 5) &#123;\n                //模拟员工5接了个电话，将自己等待吃饭给打断了\n                TimeUnit.SECONDS.sleep(1);\n                System.out.println(t.getName() + \",有点急事，我先开干了！\");\n                t.interrupt();\n                TimeUnit.SECONDS.sleep(2);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n员工4到了！\n员工3到了！\n员工5到了！\n员工1到了！\n员工2到了！\n员工5,有点急事，我先开干了！\njava.util.concurrent.BrokenBarrierException\n员工1,sleep:0 等待了1001(ms),开始吃饭了！\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n员工3,sleep:0 等待了1001(ms),开始吃饭了！\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n员工4,sleep:0 等待了1001(ms),开始吃饭了！\n    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)\n员工2,sleep:0 等待了1001(ms),开始吃饭了！\n员工5,sleep:0 等待了1002(ms),开始吃饭了！\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)\njava.lang.InterruptedException\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.reportInterruptAfterWait(AbstractQueuedSynchronizer.java:2014)\n    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2048)\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:234)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)\njava.util.concurrent.BrokenBarrierException\n员工6到了！\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n员工9到了！\n    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)\n员工8到了！\n员工7到了！\n员工6,sleep:0 等待了0(ms),开始吃饭了！\n员工7,sleep:0 等待了1(ms),开始吃饭了！\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)\n员工8,sleep:0 等待了1(ms),开始吃饭了！\n员工9,sleep:0 等待了1(ms),开始吃饭了！\nDisconnected from the target VM, address: '127.0.0.1:64413', transport: 'socket'\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo4$T.run(Demo4.java:31)\n员工10到了！\n员工10,sleep:10 等待了0(ms),开始吃饭了！\n\n输出的信息看着有点乱，给大家理一理，员工5遇到急事，拿起筷子就是吃，这样好么，当然不好，他这么做了，后面看他这么做了都跟着这么做（这种场景是不是很熟悉，有一个人拿起筷子先吃起来，其他人都跟着上了），直接不等其他人了，拿起筷子就开吃了。CyclicBarrier遇到这种情况就是这么处理的。前面4个员工都在await()处等待着，员工5也在await()上等待着，等了1秒（TimeUnit.SECONDS.sleep(1);），接了个电话，然后给员工5发送中断信号后（t.interrupt();），员工5的await()方法会触发InterruptedException异常，此时其他等待中的前4个员工，看着5开吃了，自己立即也不等了，内部从await()方法中触发BrokenBarrierException异常，然后也开吃了，后面的6&#x2F;7&#x2F;8&#x2F;9&#x2F;10员工来了以后发现大家都开吃了，自己也不等了，6-10员工调用await()直接抛出了BrokenBarrierException异常，然后继续向下。\n结论：\n\n内部有一个人把规则破坏了（接收到中断信号），其他人都不按规则来了，不会等待了\n接收到中断信号的线程，await方法会触发InterruptedException异常，然后被唤醒向下运行\n其他等待中 或者后面到达的线程，会在await()方法上触发BrokenBarrierException异常，然后继续执行\n\n示例5 其中一个人只愿意等的5秒基于示例1，员工1只愿意等的5秒，5s后如果大家还没到期，自己要开吃了，员工1开吃了，其他人会怎么样呢？\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class Demo5 &#123;\n    public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10);\n    public static class T extends Thread &#123;\n        int sleep;\n        public T(String name, int sleep) &#123;\n            super(name);\n            this.sleep = sleep;\n        &#125;\n        @Override\n        public void run() &#123;\n            long starTime = 0, endTime = 0;\n            try &#123;\n                //模拟休眠\n                TimeUnit.SECONDS.sleep(sleep);\n                starTime = System.currentTimeMillis();\n                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续\n                System.out.println(this.getName() + \"到了！\");\n                if (this.getName().equals(\"员工1\")) &#123;\n                    cyclicBarrier.await(5, TimeUnit.SECONDS);\n                &#125; else &#123;\n                    cyclicBarrier.await();\n                &#125;\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; catch (BrokenBarrierException e) &#123;\n                e.printStackTrace();\n            &#125; catch (TimeoutException e) &#123;\n                e.printStackTrace();\n            &#125;\n            endTime = System.currentTimeMillis();\n            System.out.println(this.getName() + \",sleep:\" + this.sleep + \" 等待了\" + (endTime - starTime) + \"(ms),开始吃饭了！\");\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        for (int i = 1; i &lt;= 10; i++) &#123;\n            T t = new T(\"员工\" + i, i);\n            t.start();\n        &#125;\n    &#125;\n&#125;\n\n员工1到了！\n员工2到了！\n员工3到了！\n员工4到了！\n员工5到了！\n员工6到了！\n员工1,sleep:1 等待了5001(ms),开始吃饭了！\n员工5,sleep:5 等待了1001(ms),开始吃饭了！\njava.util.concurrent.TimeoutException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:257)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)\n    at com.itsoku.chat15.Demo5$T.run(Demo5.java:32)\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)\n员工6,sleep:6 等待了2(ms),开始吃饭了！\njava.util.concurrent.BrokenBarrierException\n员工2,sleep:2 等待了4002(ms),开始吃饭了！\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n员工3,sleep:3 等待了3001(ms),开始吃饭了！\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n员工4,sleep:4 等待了2001(ms),开始吃饭了！\n    at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)\njava.util.concurrent.BrokenBarrierException\n员工7到了！\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)\n员工7,sleep:7 等待了0(ms),开始吃饭了！\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)\n员工8到了！\n员工8,sleep:8 等待了0(ms),开始吃饭了！\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)\n员工9到了！\njava.util.concurrent.BrokenBarrierException\n员工9,sleep:9 等待了0(ms),开始吃饭了！\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)\njava.util.concurrent.BrokenBarrierException\n员工10到了！\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n员工10,sleep:10 等待了0(ms),开始吃饭了！\n    at com.itsoku.chat15.Demo5$T.run(Demo5.java:34)\n\n从输出结果中我们可以看到：1等待5秒之后，开吃了，其他等待人都开吃了，后面来的人不等待，直接开吃了。\n员工1调用有参await方法等待5秒之后，触发了TimeoutException异常，然后继续向下运行，其他的在5开吃之前已经等了一会的的几个员工，他们看到5开吃了，自己立即不等待了，也也开吃了（他们的await抛出了BrokenBarrierException异常）；还有几个员工在5开吃之后到达的，他们直接不等待了，直接抛出BrokenBarrierException异常，然后也开吃了。\n结论：\n\n等待超时的方法\npublic int await(long timeout, TimeUnit unit) throws InterruptedException,BrokenBarrierException,TimeoutException\n\n内部有一个人把规则破坏了（等待超时），其他人都不按规则来了，不会等待了\n\n等待超时的线程，await方法会触发TimeoutException异常，然后被唤醒向下运行\n\n其他等待中 或者后面到达的线程，会在await()方法上触发BrokenBarrierException异常，然后继续执行\n\n\n示例6 重建规则示例5中改造一下，员工1等待5秒超时之后，开吃了，打破了规则，先前等待中的以及后面到达的都不按规则来了，都拿起筷子开吃。过了一会，导游重新告知大家，要按规则来，然后重建了规则，大家都按规则来了。\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class Demo6 &#123;\n    public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10);\n    //规则是否已重建\n    public static boolean guizhe = false;\n    public static class T extends Thread &#123;\n        int sleep;\n        public T(String name, int sleep) &#123;\n            super(name);\n            this.sleep = sleep;\n        &#125;\n        @Override\n        public void run() &#123;\n            long starTime = 0, endTime = 0;\n            try &#123;\n                //模拟休眠\n                TimeUnit.SECONDS.sleep(sleep);\n                starTime = System.currentTimeMillis();\n                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续\n                System.out.println(this.getName() + \"到了！\");\n                if (!guizhe) &#123;\n                    if (this.getName().equals(\"员工1\")) &#123;\n                        cyclicBarrier.await(5, TimeUnit.SECONDS);\n                    &#125; else &#123;\n                        cyclicBarrier.await();\n                    &#125;\n                &#125; else &#123;\n                    cyclicBarrier.await();\n                &#125;\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; catch (BrokenBarrierException e) &#123;\n                e.printStackTrace();\n            &#125; catch (TimeoutException e) &#123;\n                e.printStackTrace();\n            &#125;\n            endTime = System.currentTimeMillis();\n            System.out.println(this.getName() + \",sleep:\" + this.sleep + \" 等待了\" + (endTime - starTime) + \"(ms),开始吃饭了！\");\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        for (int i = 1; i &lt;= 10; i++) &#123;\n            T t = new T(\"员工\" + i, i);\n            t.start();\n        &#125;\n        //等待10秒之后，重置，重建规则\n        TimeUnit.SECONDS.sleep(15);\n        cyclicBarrier.reset();\n        guizhe = true;\n        System.out.println(\"---------------大家太皮了，请大家按规则来------------------\");\n        //再来一次\n        for (int i = 1; i &lt;= 10; i++) &#123;\n            T t = new T(\"员工\" + i, i);\n            t.start();\n        &#125;\n    &#125;\n&#125;\n\n员工1到了！\n员工2到了！\n员工3到了！\n员工4到了！\n员工5到了！\njava.util.concurrent.TimeoutException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:257)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)\n    at com.itsoku.chat15.Demo6$T.run(Demo6.java:36)\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)\n员工6到了！\n员工1,sleep:1 等待了5002(ms),开始吃饭了！\n员工6,sleep:6 等待了4(ms),开始吃饭了！\n员工4,sleep:4 等待了2004(ms),开始吃饭了！\n员工5,sleep:5 等待了1004(ms),开始吃饭了！\n员工3,sleep:3 等待了3002(ms),开始吃饭了！\n员工2,sleep:2 等待了4004(ms),开始吃饭了！\n员工7到了！\n员工7,sleep:7 等待了0(ms),开始吃饭了！\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)\njava.util.concurrent.BrokenBarrierException\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)\n员工8到了！\n员工8,sleep:8 等待了0(ms),开始吃饭了！\njava.util.concurrent.BrokenBarrierException\n员工9到了！\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)\n员工9,sleep:9 等待了0(ms),开始吃饭了！\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)\njava.util.concurrent.BrokenBarrierException\n员工10到了！\n    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:207)\n员工10,sleep:10 等待了0(ms),开始吃饭了！\n    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:362)\n    at com.itsoku.chat15.Demo6$T.run(Demo6.java:38)\n---------------大家太皮了，请大家按规则来------------------\n员工1到了！\n员工2到了！\n员工3到了！\n员工4到了！\n员工5到了！\n员工6到了！\n员工7到了！\n员工8到了！\n员工9到了！\n员工10到了！\n员工10,sleep:10 等待了0(ms),开始吃饭了！\n员工1,sleep:1 等待了9000(ms),开始吃饭了！\n员工2,sleep:2 等待了8000(ms),开始吃饭了！\n员工3,sleep:3 等待了6999(ms),开始吃饭了！\n员工7,sleep:7 等待了3000(ms),开始吃饭了！\n员工6,sleep:6 等待了4000(ms),开始吃饭了！\n员工5,sleep:5 等待了5000(ms),开始吃饭了！\n员工4,sleep:4 等待了6000(ms),开始吃饭了！\n员工9,sleep:9 等待了999(ms),开始吃饭了！\n员工8,sleep:8 等待了1999(ms),开始吃饭了！\n\n第一次规则被打乱了，过了一会导游重建了规则（cyclicBarrier.reset();），接着又重来来了一次模拟等待吃饭的操作，正常了。\nCountDownLatch和CyclicBarrier的区别还是举例子说明一下：\nCountDownLatch示例\n主管相当于 CountDownLatch，干活的小弟相当于做事情的线程。\n老板交给主管了一个任务，让主管搞完之后立即上报给老板。主管下面有10个小弟，接到任务之后将任务划分为10个小任务分给每个小弟去干，主管一直处于等待状态（主管会调用await()方法，此方法会阻塞当前线程），让每个小弟干完之后通知一下主管（调用countDown()方法通知主管，此方法会立即返回），主管等到所有的小弟都做完了，会被唤醒，从await()方法上苏醒，然后将结果反馈给老板。期间主管会等待，会等待所有小弟将结果汇报给自己。\n而CyclicBarrier是一批线程让自己等待，等待所有的线程都准备好了，自己才能继续。\n3、Semaphore信号灯Semaphore（信号量）为多线程协作提供了更为强大的控制方法，前面的文章中我们学了synchronized和重入锁ReentrantLock，这2种锁一次都只能允许一个线程访问一个资源，而信号量可以控制有多少个线程可以同时访问特定的资源。\nSemaphore常用场景：限流\n举个例子：\n比如有个停车场，有5个空位，门口有个门卫，手中5把钥匙分别对应5个车位上面的锁，来一辆车，门卫会给司机一把钥匙，然后进去找到对应的车位停下来，出去的时候司机将钥匙归还给门卫。停车场生意比较好，同时来了100两车，门卫手中只有5把钥匙，同时只能放5辆车进入，其他车只能等待，等有人将钥匙归还给门卫之后，才能让其他车辆进入。\n上面的例子中门卫就相当于Semaphore，车钥匙就相当于许可证，车就相当于线程。\n1、Semaphore主要方法\n**Semaphore(int permits)**：构造方法，参数表示许可证数量，用来创建信号量\n**Semaphore(int permits,boolean fair)**：构造方法，当fair等于true时，创建具有给定许可数的计数信号量并设置为公平信号量\nvoid acquire() throws InterruptedException：从此信号量获取1个许可前线程将一直阻塞，相当于一辆车占了一个车位，此方法会响应线程中断，表示调用线程的interrupt方法，会使该方法抛出InterruptedException异常\nvoid acquire(int permits) throws InterruptedException ：和acquire()方法类似，参数表示需要获取许可的数量；比如一个大卡车要入停车场，由于车比较大，需要申请3个车位才可以停放\nvoid acquireUninterruptibly(int permits) ：和acquire(int permits) 方法类似，只是不会响应线程中断\n**boolean tryAcquire()**：尝试获取1个许可，不管是否能够获取成功，都立即返回，true表示获取成功，false表示获取失败\n**boolean tryAcquire(int permits)**：和tryAcquire()，表示尝试获取permits个许可\nboolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException：尝试在指定的时间内获取1个许可，获取成功返回true，指定的时间过后还是无法获取许可，返回false\nboolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException：和tryAcquire(long timeout, TimeUnit unit)类似，多了一个permits参数，表示尝试获取permits个许可\n**void release()**：释放一个许可，将其返回给信号量，相当于车从停车场出去时将钥匙归还给门卫\n**void release(int n)**：释放n个许可\n**int availablePermits()**：当前可用的许可数\n\npackage com.xue.thread;\n \nimport java.util.Random;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n \n/**\n * \n * @Description: TODO(这里用一句话描述这个类的作用)  \n * \n * 在信号量上我们定义两种操作：\n * acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），\n *             要么一直等下去，直到有线程释放信号量，或超时。\n * release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。\n * \n * 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。\n */\npublic class SemaphoreDemo\n&#123;\n  public static void main(String[] args)\n  &#123;\n     Semaphore semaphore = new Semaphore(3);//模拟3个停车位\n     \n     for (int i = 1; i &lt;=6; i++) //模拟6部汽车\n     &#123;\n       new Thread(() -> &#123;\n          try \n          &#123;\n            semaphore.acquire();\n            System.out.println(Thread.currentThread().getName()+\"\\t 抢到了车位\");\n            TimeUnit.SECONDS.sleep(new Random().nextInt(5));\n            System.out.println(Thread.currentThread().getName()+\"\\t------- 离开\");\n          &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n          &#125;finally &#123;\n            semaphore.release();\n          &#125;\n       &#125;, String.valueOf(i)).start();\n     &#125;\n     \n  &#125;\n&#125;\n\n在信号量上我们定义两种操作：\n\nacquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。\nrelease（释放）实际上会将信号量的值加1，然后唤醒等待的线程。\n信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。\n\n2、Semaphore简单的使用import java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\npublic class Demo1 &#123;\n    static Semaphore semaphore = new Semaphore(2);\n    public static class T extends Thread &#123;\n        public T(String name) &#123;\n            super(name);\n        &#125;\n        @Override\n        public void run() &#123;\n            Thread thread = Thread.currentThread();\n            try &#123;\n                semaphore.acquire();\n                System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",获取许可!\");\n                TimeUnit.SECONDS.sleep(3);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; finally &#123;\n                semaphore.release();\n                System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",释放许可!\");\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        for (int i = 0; i &lt; 10; i++) &#123;\n            new T(\"t-\" + i).start();\n        &#125;\n    &#125;\n&#125;\n\n代码中new Semaphore(2)创建了许可数量为2的信号量，每个线程获取1个许可，同时允许两个线程获取许可，从输出中也可以看出，同时有两个线程可以获取许可，其他线程需要等待已获取许可的线程释放许可之后才能运行。为获取到许可的线程会阻塞在acquire()方法上，直到获取到许可才能继续。\n3、获取许可之后不释放门卫（Semaphore）有点呆，司机进去的时候给了钥匙，出来的时候不归还，门卫也不会说什么。最终结果就是其他车辆都无法进入了。\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\npublic class Demo2 &#123;\n    static Semaphore semaphore = new Semaphore(2);\n    public static class T extends Thread &#123;\n        public T(String name) &#123;\n            super(name);\n        &#125;\n        @Override\n        public void run() &#123;\n            Thread thread = Thread.currentThread();\n            try &#123;\n                semaphore.acquire();\n                System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",获取许可!\");\n                TimeUnit.SECONDS.sleep(3);\n                System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",运行结束!\");\n                System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",当前可用许可数量:\" + semaphore.availablePermits());\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        for (int i = 0; i &lt; 10; i++) &#123;\n            new T(\"t-\" + i).start();\n        &#125;\n    &#125;\n&#125;\n\n上面程序运行后一直无法结束，观察一下代码，代码中获取许可后，没有释放许可的代码，最终导致，可用许可数量为0，其他线程无法获取许可，会在semaphore.acquire();处等待，导致程序无法结束。\n4、释放许可正确的姿势示例1中，在finally里面释放锁，会有问题么？\n如果获取锁的过程中发生异常，导致获取锁失败，最后finally里面也释放了许可，最终会怎么样，导致许可数量凭空增长了。\n示例代码：\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\npublic class Demo3 &#123;\n    static Semaphore semaphore = new Semaphore(1);\n    public static class T extends Thread &#123;\n        public T(String name) &#123;\n            super(name);\n        &#125;\n        @Override\n        public void run() &#123;\n            Thread thread = Thread.currentThread();\n            try &#123;\n                semaphore.acquire();\n                System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",获取许可,当前可用许可数量:\" + semaphore.availablePermits());\n                //休眠100秒\n                TimeUnit.SECONDS.sleep(100);\n                System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",运行结束!\");\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; finally &#123;\n                semaphore.release();\n            &#125;\n            System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",当前可用许可数量:\" + semaphore.availablePermits());\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        T t1 = new T(\"t1\");\n        t1.start();\n        //休眠1秒\n        TimeUnit.SECONDS.sleep(1);\n        T t2 = new T(\"t2\");\n        t2.start();\n        //休眠1秒\n        TimeUnit.SECONDS.sleep(1);\n        T t3 = new T(\"t3\");\n        t3.start();\n        //给t2和t3发送中断信号\n        t2.interrupt();\n        t3.interrupt();\n    &#125;\n&#125;\n\n程序中信号量许可数量为1，创建了3个线程获取许可，线程t1获取成功了，然后休眠100秒。其他两个线程阻塞在semaphore.acquire();方法处，代码中对线程t2、t3发送中断信号，我们看一下Semaphore中acquire的源码：\npublic void acquire() throws InterruptedException\n\n这个方法会响应线程中断，主线程中对t2、t3发送中断信号之后，acquire()方法会触发InterruptedException异常，t2、t3最终没有获取到许可，但是他们都执行了finally中的释放许可的操作，最后导致许可数量变为了2，导致许可数量增加了。所以程序中释放许可的方式有问题。需要改进一下，获取许可成功才去释放锁。\n正确的释放锁的方式，如下：\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\npublic class Demo4 &#123;\n    static Semaphore semaphore = new Semaphore(1);\n    public static class T extends Thread &#123;\n        public T(String name) &#123;\n            super(name);\n        &#125;\n        @Override\n        public void run() &#123;\n            Thread thread = Thread.currentThread();\n            //获取许可是否成功\n            boolean acquireSuccess = false;\n            try &#123;\n                semaphore.acquire();\n                acquireSuccess = true;\n                System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",获取许可,当前可用许可数量:\" + semaphore.availablePermits());\n                //休眠100秒\n                TimeUnit.SECONDS.sleep(5);\n                System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",运行结束!\");\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; finally &#123;\n                if (acquireSuccess) &#123;\n                    semaphore.release();\n                &#125;\n            &#125;\n            System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",当前可用许可数量:\" + semaphore.availablePermits());\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        T t1 = new T(\"t1\");\n        t1.start();\n        //休眠1秒\n        TimeUnit.SECONDS.sleep(1);\n        T t2 = new T(\"t2\");\n        t2.start();\n        //休眠1秒\n        TimeUnit.SECONDS.sleep(1);\n        T t3 = new T(\"t3\");\n        t3.start();\n        //给t2和t3发送中断信号\n        t2.interrupt();\n        t3.interrupt();\n    &#125;\n&#125;\n\n程序中增加了一个变量acquireSuccess用来标记获取许可是否成功，在finally中根据这个变量是否为true，来确定是否释放许可。\n5、在规定的时间内希望获取许可司机来到停车场，发现停车场已经满了，只能在外等待内部的车出来之后才能进去，但是要等多久，他自己也不知道，他希望等10分钟，如果还是无法进去，就不到这里停车了。\nSemaphore内部2个方法可以提供超时获取许可的功能：\npublic boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException\npublic boolean tryAcquire(int permits, long timeout, TimeUnit unit)\n        throws InterruptedException\n\n在指定的时间内去尝试获取许可，如果能够获取到，返回true，获取不到返回false。\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\npublic class Demo5 &#123;\n    static Semaphore semaphore = new Semaphore(1);\n    public static class T extends Thread &#123;\n        public T(String name) &#123;\n            super(name);\n        &#125;\n        @Override\n        public void run() &#123;\n            Thread thread = Thread.currentThread();\n            //获取许可是否成功\n            boolean acquireSuccess = false;\n            try &#123;\n                //尝试在1秒内获取许可，获取成功返回true，否则返回false\n                System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",尝试获取许可,当前可用许可数量:\" + semaphore.availablePermits());\n                acquireSuccess = semaphore.tryAcquire(1, TimeUnit.SECONDS);\n                //获取成功执行业务代码\n                if (acquireSuccess) &#123;\n                    System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",获取许可成功,当前可用许可数量:\" + semaphore.availablePermits());\n                    //休眠5秒\n                    TimeUnit.SECONDS.sleep(5);\n                &#125; else &#123;\n                    System.out.println(System.currentTimeMillis() + \",\" + thread.getName() + \",获取许可失败,当前可用许可数量:\" + semaphore.availablePermits());\n                &#125;\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; finally &#123;\n                if (acquireSuccess) &#123;\n                    semaphore.release();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws InterruptedException &#123;\n        T t1 = new T(\"t1\");\n        t1.start();\n        //休眠1秒\n        TimeUnit.SECONDS.sleep(1);\n        T t2 = new T(\"t2\");\n        t2.start();\n        //休眠1秒\n        TimeUnit.SECONDS.sleep(1);\n        T t3 = new T(\"t3\");\n        t3.start();\n    &#125;\n&#125;\n\n代码中许可数量为1，semaphore.tryAcquire(1, TimeUnit.SECONDS);：表示尝试在1秒内获取许可，获取成功立即返回true，超过1秒还是获取不到，返回false。线程t1获取许可成功，之后休眠了5秒，从输出中可以看出t2和t3都尝试了1秒，获取失败。\n6、其他一些使用说明\nSemaphore默认创建的是非公平的信号量，什么意思呢？这个涉及到公平与非公平。举个例子：5个车位，允许5个车辆进去，来了100辆车，只能进去5辆，其他95在外面排队等着。里面刚好出来了1辆，此时刚好又来了10辆车，这10辆车是直接插队到其他95辆前面去，还是到95辆后面去排队呢？排队就表示公平，直接去插队争抢第一个，就表示不公平。对于停车场，排队肯定更好一些咯。不过对于信号量来说不公平的效率更高一些，所以默认是不公平的。\n建议阅读以下Semaphore的源码，对常用的方法有个了解，不需要都记住，用的时候也方便查询就好。\n方法中带有throws InterruptedException声明的，表示这个方法会响应线程中断信号，什么意思？表示调用线程的interrupt()方法，会让这些方法触发InterruptedException异常，即使这些方法处于阻塞状态，也会立即返回，并抛出InterruptedException异常，线程中断信号也会被清除。\n\n九、Java内存模型之JMMJMM(java内存模型)，由于并发程序要比串行程序复杂很多，其中一个重要原因是并发程序中数据访问一致性和安全性将会受到严重挑战。如何保证一个线程可以看到正确的数据呢？这个问题看起来很白痴。对于串行程序来说，根本就是小菜一碟，如果你读取一个变量，这个变量的值是1，那么你读取到的一定是1，就是这么简单的问题在并行程序中居然变得复杂起来。事实上，如果不加控制地任由线程胡乱并行，即使原本是1的数值，你也可能读到2。因此我们需要在深入了解并行机制的前提下，再定义一种规则，保证多个线程间可以有小弟，正确地协同工作。而JMM也就是为此而生的。\n1、计算机硬件存储体系 计算机存储结构，从本地磁盘到主存到CPU缓存，也就是从硬盘到内存，到CPU。一般对应的程序的操作就是从数据库查数据到内存然后到CPU进行计算\n\n​\t\t因为有这么多级的缓存(cpu和物理主内存的速度不一致的)，CPU的运行并不是直接操作内存而是先把内存里边的数据读到缓存，而内存的读和写操作的时候就会造成不一致的问题\n\n​\t\tJava虚拟机规范中试图定义一种Java内存模型（java Memory Model，简称JMM) 来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。推导出我们需要知道JMM\n2、Java内存模型Java Memory Model​\t\tJMM(Java内存模型Java Memory Model，简称JMM)本身是一种抽象的概念并不真实存在它仅仅描述的是一组约定或规范，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。\n 原则： JMM的关键技术点都是围绕多线程的原子性、可见性和有序性展开的\n能干嘛？1 通过JMM来实现线程和主内存之间的抽象关系。2 屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。\n3、JMM规范下，三大特性1、可见性\n​\t\tJava中普通的共享变量不保证可见性，因为数据修改被写入内存的时机是不确定的，多线程并发下很可能出现”脏读”，所以每个线程都有自己的工作内存，线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等 ）都必需在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成\n\n 线程脏读：如果没有可见性保证\n\n2、原子性指一个操作是不可中断的，即多线程环境下，操作不能被其他线程干扰\n原子性是指操作是不可分的，要么全部一起执行，要么不执行。在java中，其表现在对于共享变量的某些操作，是不可分的，必须连续的完成。比如a++，对于共享变量a的操作，实际上会执行3个步骤：\n1.读取变量a的值，假如a&#x3D;12.a的值+1，为23.将2值赋值给变量a，此时a的值应该为2\n这三个操作中任意一个操作，a的值如果被其他线程篡改了，那么都会出现我们不希望出现的结果。所以必须保证这3个操作是原子性的，在操作a++的过程中，其他线程不会改变a的值，如果在上面的过程中出现其他线程修改了a的值，在满足原子性的原则下，上面的操作应该失败。\n3、有序性对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。但为了提供性能，编译器和处理器通常会对指令序列进行重新排序。指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致，即可能产生”脏读”，简单说，两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。\n\n单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。处理器在进行重排序时必须要考虑指令之间的数据依赖性多线程环境中线程交替执行,由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的,结果无法预测\n\n4、JMM规范下，多线程对变量的读写过程1、读取过程​\t\t由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图:\n\nJMM定义了线程和主内存之间的抽象关系1 线程之间的共享变量存储在主内存中(从硬件角度来说就是内存条)2 每个线程都有一个私有的本地工作内存，本地工作内存中存储了该线程用来读&#x2F;写共享变量的副本(从硬件角度来说就是CPU的缓存，比如寄存器、L1、L2、L3缓存等)\n2、小总结\n我们定义的所有共享变量都储存在物理主内存中\n每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)\n线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写(不能越级)\n不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行(同级不能相互访问)\n\n5、JMM规范下，多线程先行发生原则之happens-before在JMM中，如果一个操作执行的结果需要对另一个操作可见性或者 代码重排序，那么这两个操作之间必须存在happens-before关系。\n\n1、先行发生原则说明​\t\t如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将会变得非常啰嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点。\n​\t\t我们没有时时、处处、次次，添加volatile和synchronized来完成程序，这是因为Java语言中JMM原则下有一个“先行发生”(Happens-Before)的原则限制和规矩\n这个原则非常重要：        它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型苦涩难懂的底层编译原理之中。\n2、happens-before总原则\n如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。\n两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。\n1+2+3 &#x3D; 3+2+1\n周一张三周二李四，假如有事情调换班可以的\n\n\n\n6、happens-before之8条1、次序规则一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作；\n前一个操作的结果可以被后续的操作获取。讲白点就是前面一个操作把变量X赋值为1，那后面一个操作肯定能知道X已经变成了1。\n2、锁定规则一个unLock操作先行发生于后面((这里的“后面”是指时间上的先后))对同一个锁的lock操作；\npublic class HappenBeforeDemo\n&#123;\n    static Object objectLock = new Object();\n\n    public static void main(String[] args) throws InterruptedException\n    &#123;\n        //对于同一把锁objectLock，threadA一定先unlock同一把锁后B才能获得该锁，   A 先行发生于B\n        synchronized (objectLock)\n        &#123;\n\n        &#125;\n    &#125;\n&#125;\n\n3、volatile变量规则对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的“后面”同样是指时间上的先后。\n4、传递规则如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；\n5、线程启动规则(Thread Start Rule)Thread对象的start()方法先行发生于此线程的每一个动作\n6、线程中断规则(Thread Interruption Rule)对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；\n可以通过Thread.interrupted()检测到是否发生中断\n7、线程终止规则(Thread Termination Rule)线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。\n8、对象终结规则(Finalizer Rule)一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始\n对象没有完成初始化之前，是不能调用finalized()方法的\n7、案例说明\n​\t\t假设存在线程A和B，线程A先（时间上的先后）调用了setValue(1)，然后线程B调用了同一个对象的getValue()，那么线程B收到的返回值是什么？\n我们就这段简单的代码一次分析happens-before的规则（规则5、6、7、8 可以忽略，因为他们和这段代码毫无关系）：1 由于两个方法是由不同的线程调用，不在同一个线程中，所以肯定不满足程序次序规则；2 两个方法都没有使用锁，所以不满足锁定规则；3 变量不是用volatile修饰的，所以volatile变量规则不满足；4 传递规则肯定不满足；\n​\t\t所以我们无法通过happens-before原则推导出线程A happens-before线程B，虽然可以确认在时间上线程A优先于线程B指定，但就是无法确认线程B获得的结果是什么，所以这段代码不是线程安全的。那么怎么修复这段代码呢？\n\n把getter&#x2F;setter方法都定义为synchronized方法\n把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景\n\n十、volatile与Java内存模型1、被volatile修改的变量有2大特点\n可见性\n有序性\n\n2、volatile的内存语义\n当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中。\n当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，直接从主内存中读取共享变量\n所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取。\n\n3、内存屏障（重点）1、生活case\n没有管控，顺序难保\n\n设定规则，禁止乱序\n\n\n\n上海南京路步行街武警“人墙”当红灯\n\n\n2、内存屏障是什么​\t\t内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性，但volatile无法保证原子性。\n​\t\t内存屏障之前的所有写操作都要回写到主内存，内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。\n\n因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。一句话：对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读，也叫写后读。\n3、volatile凭什么可以保证可见性和有序性？？？内存屏障 (Memory Barriers &#x2F; Fences)\n4、JVM中提供了四类内存屏障指令Unsafe.class\n\nUnsafe.java\n\nUnsafe.cpp\n\nOrderAccess.hpp\n\norderAccess_linux_x86.inline.hpp\n\n5、四大屏障分别是什么意思\norderAccess_linux_x86.inline.hpp\n\n6、happens-before 之 volatile 变量规则\n\n\n\n当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序。这个操作保证了volatile读之后的操作不会被重排到volatile读之前。\n\n\n\n当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序。这个操作保证了volatile写之前的操作不会被重排到volatile写之后。\n\n\n当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。\n\n\n7、JMM 就将内存屏障插⼊策略分为 4 种\n写\n\n在每个 volatile 写操作的前⾯插⼊⼀个 StoreStore 屏障\n在每个 volatile 写操作的后⾯插⼊⼀个 StoreLoad 屏障\n\n\n读\n\n在每个 volatile 读操作的后⾯插⼊⼀个 LoadLoad 屏障\n在每个 volatile 读操作的后⾯插⼊⼀个 LoadStore 屏障\n\n\n\n\n4、volatile特性1、保证可见性保证不同线程对这个变量进行操作时的可见性，即变量一旦改变所有线程立即可见\npublic class VolatileSeeDemo\n&#123;\n    static          boolean flag = true;       //不加volatile，没有可见性\n    //static volatile boolean flag = true;       //加了volatile，保证可见性\n\n    public static void main(String[] args)\n    &#123;\n        new Thread(() -> &#123;\n            System.out.println(Thread.currentThread().getName()+\"\\t come in\");\n            while (flag)\n            &#123;\n\n            &#125;\n            System.out.println(Thread.currentThread().getName()+\"\\t flag被修改为false,退出.....\");\n        &#125;,\"t1\").start();\n\n        //暂停2秒钟后让main线程修改flag值\n        try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        flag = false;\n\n        System.out.println(\"main线程修改完成\");\n    &#125;\n&#125;\n\n\n不加volatile，没有可见性，程序无法停止\n加了volatile，保证可见性，程序可以停止\n\n线程t1中为何看不到被主线程main修改为false的flag的值？\n \n问题可能:\n1. 主线程修改了flag之后没有将其刷新到主内存，所以t1线程看不到。\n2. 主线程将flag刷新到了主内存，但是t1一直读取的是自己工作内存中flag的值，没有去主内存中更新获取flag最新的值。\n \n我们的诉求：\n1.线程中修改了工作内存中的副本之后，立即将其刷新到主内存；\n2.工作内存中每次读取共享变量时，都去主内存中重新读取，然后拷贝到工作内存。\n \n解决：\n使用volatile修饰共享变量，就可以达到上面的效果，被volatile修改的变量有以下特点：\n1. 线程中读取的时候，每次读取都会去主内存中读取共享变量最新的值，然后将其复制到工作内存\n2. 线程中修改了工作内存中变量的副本，修改之后会立即刷新到主内存\n\n1、volatile变量的读写过程Java内存模型中定义的8种工作内存与主内存之间的原子操作read(读取)→load(加载)→use(使用)→assign(赋值)→store(存储)→write(写入)→lock(锁定)→unlock(解锁)\n\nread: 作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存load: 作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载use: 作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作assign: 作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作store: 作用于工作内存，将赋值完毕的工作变量的值写回给主内存write: 作用于主内存，将store传输过来的变量值赋值给主内存中的变量由于上述只能保证单条指令的原子性，针对多条指令的组合性原子保证，没有大面积加锁，所以，JVM提供了另外两个原子指令：lock: 作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，就只是锁了写变量的过程。unlock: 作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用\n2、没有原子性1、volatile变量的复合操作(如i++)不具有原子性class MyNumber\n&#123;\n    volatile int number = 0;\n\n    public void addPlusPlus()\n    &#123;\n        number++;\n    &#125;\n&#125;\n\npublic class VolatileNoAtomicDemo\n&#123;\n    public static void main(String[] args) throws InterruptedException\n    &#123;\n        MyNumber myNumber = new MyNumber();\n\n        for (int i = 1; i &lt;=10; i++) &#123;\n            new Thread(() -> &#123;\n                for (int j = 1; j &lt;= 1000; j++) &#123;\n                    myNumber.addPlusPlus();\n                &#125;\n            &#125;,String.valueOf(i)).start();\n        &#125;\n        \n        //暂停几秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + myNumber.number);\n    &#125;\n&#125;\n\n从i++的字节码角度说明\n\n原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。\npublic void add()\n&#123;\n        i++; //不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，分3步完成\n &#125;\n如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，\n并执行相同值的加1操作，这也就造成了线程安全失败，因此对于add方法必须使用synchronized修饰，以便保证线程安全.\n\n\n多线程环境下，\"数据计算\"和\"数据赋值\"操作可能多次出现，即操作非原子。若数据在加载之后，若主内存count变量发生修改之后，由于线程工作内存中的值在此前已经加载，从而不会对变更操作做出相应变化，即私有内存和公共内存中变量不同步，进而导致数据不一致\n对于volatile变量，JVM只是保证从主内存加载到线程工作内存的值是最新的，也就是数据加载时是最新的。\n由此可见volatile解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改共享变量的场景必须使用加锁同步\n\n2、读取赋值一个普通变量的情况当线程1对主内存对象发起read操作到write操作第一套流程的时间里，线程2随时都有可能对这个主内存对象发起第二套操作\n\n3、既然一修改就是可见，为什么还不能保证原子性？volatile主要是对其中部分指令做了处理\n要use(使用)一个变量的时候必需load(载入），要载入的时候必需从主内存read(读取）这样就解决了读的可见性。 \n写操作是把assign和store做了关联(在assign(赋值)后必需store(存储))。store(存储)后write(写入)。\n也就是做到了给一个变量赋值的时候一串关联指令直接把变量值写到主内存。\n就这样通过用的时候直接从主内存取，在赋值到直接写回主内存做到了内存可见性。注意蓝色框框的间隙。。。。。。o(╥﹏╥)o\n\n\n4、读取赋值一个volatile变量的情况\n read-load-use 和 assign-store-write 成为了两个不可分割的原子操作，但是在use和assign之间依然有极小的一段真空期，有可能变量会被其他线程读取，导致写丢失一次...o(╥﹏╥)o\n但是无论在哪一个时间点主内存的变量和任一工作内存的变量的值都是相等的。这个特性就导致了volatile变量不适合参与到依赖当前值的运算，如i = i + 1; i++;之类的那么依靠可见性的特点volatile可以用在哪些地方呢？ 通常volatile用做保存某个状态的boolean值or int值。\n《深入理解Java虚拟机》提到：\n\n\n5、面试回答JVM的字节码，i++分成三步，间隙期不同步非原子操作(i++)\n\n3、指令禁重排重排序\n重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序\n不存在数据依赖关系，可以重排序；\n存在数据依赖关系，禁止重排序\n但重排后的指令绝对不能改变原有的串行语义！这点在并发设计中必须要重点考虑！\n    \n重排序的分类和执行流程\n\n\n编译器优化的重排序： 编译器在不改变单线程串行语义的前提下，可以重新调整指令的执行顺序\n指令级并行的重排序： 处理器使用指令级并行技术来讲多条指令重叠执行，若不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序\n内存系统的重排序： 由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行\n \n数据依赖性：若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性。\n \n案例 ：\n不存在数据依赖关系，可以重排序===> 重排序OK 。\n\n\n\n\n重排前\n重排后\n\n\n\nint a &#x3D; 1;  &#x2F;&#x2F;1int b &#x3D; 20; &#x2F;&#x2F;2int c &#x3D; a + b; &#x2F;&#x2F;3\nint b &#x3D; 20;  &#x2F;&#x2F;1int a &#x3D; 1; &#x2F;&#x2F;2int c &#x3D; a + b; &#x2F;&#x2F;3\n\n\n结论：编译器调整了语句的顺序，但是不影响程序的最终结果。\n重排序OK\n\n\n存在数据依赖关系，禁止重排序===> 重排序发生，会导致程序运行结果不同。\n编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在依赖关系的两个操作的执行,但不同处理器和不同线程之间的数据性不会被编译器和处理器考虑，其只会作用于单处理器和单线程环境，下面三种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。\n\n\n1、volatile的底层实现是通过内存屏障volatile有关的禁止指令重排的行为\n\n\n\n\n当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序。这个操作保证了volatile读之后的操作不会被重排到volatile读之前。\n\n\n\n当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序。这个操作保证了volatile写之前的操作不会被重排到volatile写之后。\n\n\n当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。\n\n\n四大屏障的插入情况\n\n在每一个volatile写操作前面插入一个StoreStore屏障\nStoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中。\n\n\n在每一个volatile写操作后面插入一个StoreLoad屏障\nStoreLoad屏障的作用是避免volatile写与后面可能有的volatile读&#x2F;写操作重排序\n\n\n在每一个volatile读操作后面插入一个LoadLoad屏障\nLoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。\n\n\n在每一个volatile读操作后面插入一个LoadStore屏障\nLoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。\n\n\n\n//模拟一个单线程，什么顺序读？什么顺序写？\npublic class VolatileTest &#123;\n    int i = 0;\n    volatile boolean flag = false;\n    public void write()&#123;\n        i = 2;\n        flag = true;\n    &#125;\n    public void read()&#123;\n        if(flag)&#123;\n            System.out.println(\"---i = \" + i);\n        &#125;\n    &#125;\n&#125;\n\n\n4、如何正确使用volatile1、单一赋值可以，but含复合运算赋值不可以(i++之类)volatile int a = 10\nvolatile boolean flag = false \n\n2、状态标志，判断业务是否结束/**\n *\n * 使用：作为一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或任务结束\n * 理由：状态标志并不依赖于程序内任何其他状态，且通常只有一种状态转换\n * 例子：判断业务是否结束\n */\npublic class UseVolatileDemo\n&#123;\n    private volatile static boolean flag = true;\n\n    public static void main(String[] args)\n    &#123;\n        new Thread(() -> &#123;\n            while(flag) &#123;\n                //do something......\n            &#125;\n        &#125;,\"t1\").start();\n\n        //暂停几秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(2L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            flag = false;\n        &#125;,\"t2\").start();\n    &#125;\n&#125;\n\n3、开销较低的读，写锁策略public class UseVolatileDemo\n&#123;\n    /**\n     * 使用：当读远多于写，结合使用内部锁和 volatile 变量来减少同步的开销\n     * 理由：利用volatile保证读取操作的可见性；利用synchronized保证复合操作的原子性\n     */\n    public class Counter\n    &#123;\n        private volatile int value;\n\n        public int getValue()\n        &#123;\n            return value;   //利用volatile保证读取操作的可见性\n              &#125;\n        public synchronized int increment()\n        &#123;\n            return value++; //利用synchronized保证复合操作的原子性\n               &#125;\n    &#125;\n&#125;\n\n4、DCL双端锁的发布问题代码\npublic class SafeDoubleCheckSingleton\n&#123;\n    private static SafeDoubleCheckSingleton singleton;\n    //私有化构造方法\n    private SafeDoubleCheckSingleton()&#123;\n    &#125;\n    //双重锁设计\n    public static SafeDoubleCheckSingleton getInstance()&#123;\n        if (singleton == null)&#123;\n            //1.多线程并发创建对象时，会通过加锁保证只有一个线程能创建对象\n            synchronized (SafeDoubleCheckSingleton.class)&#123;\n                if (singleton == null)&#123;\n                    //隐患：多线程环境下，由于重排序，该对象可能还未完成初始化就被其他线程读取\n                    singleton = new SafeDoubleCheckSingleton();\n                &#125;\n            &#125;\n        &#125;\n        //2.对象创建完毕，执行getInstance()将不需要获取锁，直接返回创建对象\n        return singleton;\n    &#125;\n&#125;\n\n单线程看问题代码\n单线程环境下(或者说正常情况下)，在”问题代码处”，会执行如下操作，保证能获取到已完成初始化的实例\n\n由于存在指令重排序……\n多线程看问题代码\n隐患：多线程环境下，在”问题代码处”，会执行如下操作，由于重排序导致2,3乱序，后果就是其他线程得到的是null而不是完成初始化的对象\n\n解决01\n加volatile修饰\n面试题，反周志明老师的案例，你还有不加volatile的方法吗\n解决02 – 采用静态内部类的方式实现\n//现在比较好的做法就是采用静态内部内的方式实现\n \npublic class SingletonDemo\n&#123;\n    private SingletonDemo() &#123; &#125;\n\n    private static class SingletonDemoHandler\n    &#123;\n        private static SingletonDemo instance = new SingletonDemo();\n    &#125;\n\n    public static SingletonDemo getInstance()\n    &#123;\n        return SingletonDemoHandler.instance;\n    &#125;\n&#125;\n\n5、最后的小总结1、内存屏障是什么\n2、内存屏障能干嘛\n阻止屏障两边的指令重排序\n写数据时加入屏障，强制将线程私有工作内存的数据刷回主物理内存\n读数据时加入屏障，线程私有工作内存的数据失效，重新到主物理内存中获取最新数据\n\n3、内存屏障四大指令\n在每一个volatile写操作前面插入一个StoreStore屏障\n\n\n\n在每一个volatile写操作后面插入一个StoreLoad屏障\n\n\n\n在每一个volatile读操作后面插入一个LoadLoad屏障\n\n\n\n在每一个volatile读操作后面插入一个LoadStore屏障\n\n\n\n\n4、凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的?字节码层面\n\n\n5、volatile可见性\n6、volatile禁重排写指令\n\n读指令\n\n7、对比java.util.concurrent.locks.Lock来理解\n8、一句话总结\n十一、CAS1、没有CAS之前1、多线程环境不使用原子类保证线程安全（基本数据类型）public class T3\n&#123;\n    volatile int number = 0;\n    //读取\n    public int getNumber()\n    &#123;\n        return number;\n    &#125;\n    //写入加锁保证原子性\n    public synchronized void setNumber()\n    &#123;\n        number++;\n    &#125;\n&#125;\n\n2、多线程环境    使用原子类保证线程安全（基本数据类型）public class T3\n&#123;\n    volatile int number = 0;\n    //读取\n    public int getNumber()\n    &#123;\n        return number;\n    &#125;\n    //写入加锁保证原子性\n    public synchronized void setNumber()\n    &#123;\n        number++;\n    &#125;\n    //=================================\n    AtomicInteger atomicInteger = new AtomicInteger();\n\n    public int getAtomicInteger()\n    &#123;\n        return atomicInteger.get();\n    &#125;\n\n    public void setAtomicInteger()\n    &#123;\n        atomicInteger.getAndIncrement();\n    &#125;\n&#125;\n\n2、CAS是什么compare and swap的缩写，中文翻译成比较并交换,实现并发算法时常用到的一种技术。它包含三个操作数——内存位置、预期原值及更新值。\n执行CAS操作的时候，将内存位置的值与预期原值比较：\n如果相匹配，那么处理器会自动将该位置值更新为新值，\n如果不匹配，处理器不做任何操作，多个线程同时执行CAS操作只有一个会成功。 \n\nCAS有3个操作数，位置内存值V，旧的预期值A，要修改的更新值B。当且仅当旧的预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做或重来\n\nCAS是JDK提供的非阻塞原子性操作，它通过硬件保证了比较-更新的原子性。\n它是非阻塞的且自身原子性，也就是说这玩意效率更高且通过硬件保证，说明这玩意更可靠。\n \nCAS是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。\n执行cmpxchg指令的时候，会判断当前系统是否为多核系统，如果是就给总线加锁，只有一个线程会对总线加锁成功，加锁成功之后会执行cas操作，也就是说CAS的原子性实际上是CPU实现的， 其实在这一点上还是有排他锁的，只是比起用synchronized， 这里的排他时间要短的多， 所以在多线程情况下性能会比较好\n\npublic class CASDemo\n&#123;\n    public static void main(String[] args) throws InterruptedException\n    &#123;\n        AtomicInteger atomicInteger = new AtomicInteger(5);\n\n        System.out.println(atomicInteger.compareAndSet(5, 2020)+\"\\t\"+atomicInteger.get());\n        System.out.println(atomicInteger.compareAndSet(5, 1024)+\"\\t\"+atomicInteger.get());\n    &#125;\n&#125;\n\n1、源码分析compareAndSet(int expect,int update)compareAndSet()方法的源代码：\n\n上面三个方法都是类似的，主要对4个参数做一下说明。var1：表示要操作的对象var2：表示要操作对象中属性地址的偏移量var4：表示需要修改数据的期望的值var5&#x2F;var6：表示需要修改为的新值\n\n3、CAS底层原理？如果知道，谈谈你对UnSafe的理解1、UnSafe\n\nUnsafe   是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务 \n\n变量valueOffset，表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。\n\n\n\n\n变量value用volatile修饰，保证了多线程之间的内存可见性。\n\n2、我们知道i++线程不安全的，那atomicInteger.getAndIncrement()CAS的全称为Compare-And-Swap，它是一条CPU并发原语。它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。\n\nnew AtomicInteger().getAndIncrement();\n\n\n假设线程A和线程B两个线程同时执行getAndAddInt操作（分别跑在不同CPU上）：\n\nAtomicInteger里面的value原始值为3，即主内存中AtomicInteger的value为3，根据JMM模型，线程A和线程B各自持有一份值为3的value的副本分别到各自的工作内存。\n\n线程A通过getIntVolatile(var1, var2)拿到value值3，这时线程A被挂起。\n\n线程B也通过getIntVolatile(var1, var2)方法获取到value值3，此时刚好线程B没有被挂起并执行compareAndSwapInt方法比较内存值也为3，成功修改内存值为4，线程B打完收工，一切OK。\n\n这时线程A恢复，执行compareAndSwapInt方法比较，发现自己手里的值数字3和主内存的值数字4不一致，说明该值已经被其它线程抢先一步修改过了，那A线程本次修改失败，只能重新读取重新来一遍了。\n\n线程A重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。\n\n\n3、底层汇编native修饰的方法代表是底层方法\nUnsafe类中的compareAndSwapInt，是一个本地方法，该方法的实现位于unsafe.cpp中\nUNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))\n  UnsafeWrapper(\"Unsafe_CompareAndSwapInt\");\n  oop p = JNIHandles::resolve(obj);\n// 先想办法拿到变量value在内存中的地址，根据偏移量valueOffset，计算 value 的地址\n  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);\n// 调用 Atomic 中的函数 cmpxchg来进行比较交换，其中参数x是即将更新的值，参数e是原内存的值\n  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;\nUNSAFE_END\n\n(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e;\ncmpxchg\n// 调用 Atomic 中的函数 cmpxchg来进行比较交换，其中参数x是即将更新的值，参数e是原内存的值\n  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;\n\nunsigned Atomic::cmpxchg(unsigned int exchange_value,volatile unsigned int* dest, unsigned int compare_value) &#123;\n    assert(sizeof(unsigned int) == sizeof(jint), \"more work to do\");\n  /*\n   * 根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载函数*/\n    return (unsigned int)Atomic::cmpxchg((jint)exchange_value, (volatile jint*)dest, (jint)compare_value);\n&#125;\n\n在不同的操作系统下会调用不同的cmpxchg重载函数，本次用的是win10系统\ninline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) &#123;\n  //判断是否是多核CPU\n  int mp = os::is_MP();\n  __asm &#123;\n    //三个move指令表示的是将后面的值移动到前面的寄存器上\n    mov edx, dest\n    mov ecx, exchange_value\n    mov eax, compare_value\n    //CPU原语级别，CPU触发\n    LOCK_IF_MP(mp)\n    //比较并交换指令\n    //cmpxchg: 即“比较并交换”指令\n    //dword: 全称是 double word 表示两个字，一共四个字节\n    //ptr: 全称是 pointer，与前面的 dword 连起来使用，表明访问的内存单元是一个双字单元 \n    //将 eax 寄存器中的值（compare_value）与 [edx] 双字内存单元中的值进行对比，\n    //如果相同，则将 ecx 寄存器中的值（exchange_value）存入 [edx] 内存单元中\n    cmpxchg dword ptr [edx], ecx\n  &#125;\n&#125;\n\n到这里应该理解了CAS真正实现的机制了，它最终是由操作系统的汇编指令完成的。\n4、总结你只需要记住：CAS是靠硬件实现的从而在硬件层面提升效率，最底层还是交给硬件来保证原子性和可见性\n实现方式是基于硬件平台的汇编指令，在intel的CPU中(X86机器上)，使用的是汇编指令cmpxchg指令。 \n \n核心思想就是：比较要更新变量的值V和预期值E（compare），相等才会将V的值设为新值N（swap）如果不相等自旋再来。\n\n4、原子引用AtomicInteger原子整型，可否有其它原子类型？\n\nAtomicBook\nAtomicOrder\n。。。\n\n@Getter\n@ToString\n@AllArgsConstructor\nclass User\n&#123;\n    String userName;\n    int    age;\n&#125;\n\n/**\n * @auther zzyy\n * @create 2018-12-31 17:22\n */\npublic class AtomicReferenceDemo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        User z3 = new User(\"z3\",24);\n        User li4 = new User(\"li4\",26);\n\n        AtomicReference&lt;User> atomicReferenceUser = new AtomicReference&lt;>();\n\n        atomicReferenceUser.set(z3);\n        System.out.println(atomicReferenceUser.compareAndSet(z3,li4)+\"\\t\"+atomicReferenceUser.get().toString());\n        System.out.println(atomicReferenceUser.compareAndSet(z3,li4)+\"\\t\"+atomicReferenceUser.get().toString());\n    &#125;\n&#125;\n\n5、自旋锁，借鉴CAS思想自旋锁（spinlock）\n是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU\n\n/**\n * 题目：实现一个自旋锁\n * 自旋锁好处：循环比较获取没有类似wait的阻塞。\n *\n * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒钟，B随后进来后发现\n * 当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到。\n */\npublic class SpinLockDemo\n&#123;\n    AtomicReference&lt;Thread> atomicReference = new AtomicReference&lt;>();\n\n    public void myLock()\n    &#123;\n        Thread thread = Thread.currentThread();\n        System.out.println(Thread.currentThread().getName()+\"\\t come in\");\n        while(!atomicReference.compareAndSet(null,thread))\n        &#123;\n\n        &#125;\n    &#125;\n\n    public void myUnLock()\n    &#123;\n        Thread thread = Thread.currentThread();\n        atomicReference.compareAndSet(thread,null);\n        System.out.println(Thread.currentThread().getName()+\"\\t myUnLock over\");\n    &#125;\n\n    public static void main(String[] args)\n    &#123;\n        SpinLockDemo spinLockDemo = new SpinLockDemo();\n\n        new Thread(() -> &#123;\n            spinLockDemo.myLock();\n            try &#123; TimeUnit.SECONDS.sleep( 5 ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            spinLockDemo.myUnLock();\n        &#125;,\"A\").start();\n\n        //暂停一会儿线程，保证A线程先于B线程启动并完成\n        try &#123; TimeUnit.SECONDS.sleep( 1 ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            spinLockDemo.myLock();\n            spinLockDemo.myUnLock();\n        &#125;,\"B\").start();\n\n    &#125;\n&#125;\n\n6、CAS缺点1、循环时间长开销很大我们可以看到getAndAddInt方法执行时，有个do while\n\n如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。\n2、引出来ABA问题？？？CAS会导致“ABA问题”。\n \nCAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差类会导致数据的变化。\n \n比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，\n然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功。\n \n尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。\n\npublic class ABADemo\n&#123;\n    static AtomicInteger atomicInteger = new AtomicInteger(100);\n    static AtomicStampedReference atomicStampedReference = new AtomicStampedReference(100,1);\n\n    public static void main(String[] args)\n    &#123;\n        new Thread(() -> &#123;\n            atomicInteger.compareAndSet(100,101);\n            atomicInteger.compareAndSet(101,100);\n        &#125;,\"t1\").start();\n\n        new Thread(() -> &#123;\n            //暂停一会儿线程\n            try &#123; Thread.sleep( 500 ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;;            System.out.println(atomicInteger.compareAndSet(100, 2019)+\"\\t\"+atomicInteger.get());\n        &#125;,\"t2\").start();\n\n        //暂停一会儿线程,main彻底等待上面的ABA出现演示完成。\n        try &#123; Thread.sleep( 2000 ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        System.out.println(\"============以下是ABA问题的解决=============================\");\n\n        new Thread(() -> &#123;\n            int stamp = atomicStampedReference.getStamp();\n            System.out.println(Thread.currentThread().getName()+\"\\t 首次版本号:\"+stamp);//1\n            //暂停一会儿线程,\n            try &#123; Thread.sleep( 1000 ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            atomicStampedReference.compareAndSet(100,101,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1);\n            System.out.println(Thread.currentThread().getName()+\"\\t 2次版本号:\"+atomicStampedReference.getStamp());\n            atomicStampedReference.compareAndSet(101,100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1);\n            System.out.println(Thread.currentThread().getName()+\"\\t 3次版本号:\"+atomicStampedReference.getStamp());\n        &#125;,\"t3\").start();\n\n        new Thread(() -> &#123;\n            int stamp = atomicStampedReference.getStamp();\n            System.out.println(Thread.currentThread().getName()+\"\\t 首次版本号:\"+stamp);//1\n            //暂停一会儿线程，获得初始值100和初始版本号1，故意暂停3秒钟让t3线程完成一次ABA操作产生问题\n            try &#123; Thread.sleep( 3000 ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            boolean result = atomicStampedReference.compareAndSet(100,2019,stamp,stamp+1);\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+result+\"\\t\"+atomicStampedReference.getReference());\n        &#125;,\"t4\").start();\n    &#125;\n&#125;\n\n\n\n十二、原子操作类之18罗汉增强\n\nAtomicBoolean\nAtomicInteger\nAtomicIntegerArray\nAtomicIntegerFieldUpdater\nAtomicLong\nAtomicLongArray\nAtomicLongFieldUpdater\nAtomicMarkableReference\nAtomicReference\nAtomicReferenceArray\nAtomicReferenceFieldUpdater\nAtomicStampedReference\nDoubleAccumulator\nDoubleAdder\nLongAccumulator\nLongAdder\n\n1、基本类型原子类\nAtomicInteger\nAtomicBoolean\nAtomicLong\n\n1、常用API简介public final int get() //获取当前的值\npublic final int getAndSet(int newValue)//获取当前的值，并设置新的值\npublic final int getAndIncrement()//获取当前的值，并自增\npublic final int getAndDecrement() //获取当前的值，并自减\npublic final int getAndAdd(int delta) //获取当前的值，并加上预期的值\nboolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）\n\n2、tsleep→countDownLatchclass MyNumber\n&#123;\n    @Getter\n    private AtomicInteger atomicInteger = new AtomicInteger();\n    public void addPlusPlus()\n    &#123;\n        atomicInteger.incrementAndGet();\n    &#125;\n&#125;\n\n/**\n * @create 2020-07-03 17:16\n */\npublic class AtomicIntegerDemo\n&#123;\n    public static void main(String[] args) throws InterruptedException\n    &#123;\n        MyNumber myNumber = new MyNumber();\n        CountDownLatch countDownLatch = new CountDownLatch(100);\n\n        for (int i = 1; i &lt;=100; i++) &#123;\n            new Thread(() -> &#123;\n                try\n                &#123;\n                    for (int j = 1; j &lt;=5000; j++)\n                    &#123;\n                        myNumber.addPlusPlus();\n                    &#125;\n                &#125;finally &#123;\n                    countDownLatch.countDown();\n                &#125;\n            &#125;,String.valueOf(i)).start();\n        &#125;\n\n        countDownLatch.await();\n\n        System.out.println(myNumber.getAtomicInteger().get());\n    &#125;\n&#125;\n\n2、数组类型原子类\nAtomicIntegerArray\nAtomicLongArray\nAtomicReferenceArray\n\npublic class AtomicIntegerArrayDemo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(new int[5]);\n        //AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(5);\n        //AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(new int[]&#123;1,2,3,4,5&#125;);\n\n        for (int i = 0; i &lt;atomicIntegerArray.length(); i++) &#123;\n            System.out.println(atomicIntegerArray.get(i));\n        &#125;\n        System.out.println();\n        System.out.println();\n        System.out.println();\n        int tmpInt = 0;\n\n        tmpInt = atomicIntegerArray.getAndSet(0,1122);\n        System.out.println(tmpInt+\"\\t\"+atomicIntegerArray.get(0));\n        atomicIntegerArray.getAndIncrement(1);\n        atomicIntegerArray.getAndIncrement(1);\n        tmpInt = atomicIntegerArray.getAndIncrement(1);\n        System.out.println(tmpInt+\"\\t\"+atomicIntegerArray.get(1));\n    &#125;\n&#125;\n\n3、引用类型原子类\nAtomicReference\n\n@Getter\n@ToString\n@AllArgsConstructor\nclass User\n&#123;\n    String userName;\n    int    age;\n&#125;\n\npublic class AtomicReferenceDemo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        User z3 = new User(\"z3\",24);\n        User li4 = new User(\"li4\",26);\n\n        AtomicReference&lt;User> atomicReferenceUser = new AtomicReference&lt;>();\n\n        atomicReferenceUser.set(z3);\n        System.out.println(atomicReferenceUser.compareAndSet(z3,li4)+\"\\t\"+atomicReferenceUser.get().toString());\n        System.out.println(atomicReferenceUser.compareAndSet(z3,li4)+\"\\t\"+atomicReferenceUser.get().toString());\n    &#125;\n&#125;\n\n自旋锁SpinLockDemo\n/**\n * 题目：实现一个自旋锁\n * 自旋锁好处：循环比较获取没有类似wait的阻塞。\n *\n * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒钟，B随后进来后发现\n * 当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到。\n */\npublic class SpinLockDemo\n&#123;\n    AtomicReference&lt;Thread> atomicReference = new AtomicReference&lt;>();\n\n    public void myLock()\n    &#123;\n        Thread thread = Thread.currentThread();\n        System.out.println(Thread.currentThread().getName()+\"\\t come in\");\n        while(!atomicReference.compareAndSet(null,thread))\n        &#123;\n\n        &#125;\n    &#125;\n\n    public void myUnLock()\n    &#123;\n        Thread thread = Thread.currentThread();\n        atomicReference.compareAndSet(thread,null);\n        System.out.println(Thread.currentThread().getName()+\"\\t myUnLock over\");\n    &#125;\n\n    public static void main(String[] args)\n    &#123;\n        SpinLockDemo spinLockDemo = new SpinLockDemo();\n\n        new Thread(() -> &#123;\n            spinLockDemo.myLock();\n            //暂停一会儿线程\n            try &#123; TimeUnit.SECONDS.sleep( 5 ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            spinLockDemo.myUnLock();\n        &#125;,\"A\").start();\n        //暂停一会儿线程，保证A线程先于B线程启动并完成\n        try &#123; TimeUnit.SECONDS.sleep( 1 ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            spinLockDemo.myLock();\n            spinLockDemo.myUnLock();\n        &#125;,\"B\").start();\n\n    &#125;\n&#125;\n\n\nAtomicStampedReference\n携带版本号的引用类型原子类，可以解决ABA问题\n解决修改过几次\n状态戳原子引用\n\n\n\nABADemo\npublic class ABADemo\n&#123;\n    static AtomicInteger atomicInteger = new AtomicInteger(100);\n    static AtomicStampedReference atomicStampedReference = new AtomicStampedReference(100,1);\n\n    public static void main(String[] args)\n    &#123;\n        abaProblem();\n        abaResolve();\n    &#125;\n\n    public static void abaResolve()\n    &#123;\n        new Thread(() -> &#123;\n            int stamp = atomicStampedReference.getStamp();\n            System.out.println(\"t3 ----第1次stamp  \"+stamp);\n            try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            atomicStampedReference.compareAndSet(100,101,stamp,stamp+1);\n            System.out.println(\"t3 ----第2次stamp  \"+atomicStampedReference.getStamp());\n            atomicStampedReference.compareAndSet(101,100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1);\n            System.out.println(\"t3 ----第3次stamp  \"+atomicStampedReference.getStamp());\n        &#125;,\"t3\").start();\n\n        new Thread(() -> &#123;\n            int stamp = atomicStampedReference.getStamp();\n            System.out.println(\"t4 ----第1次stamp  \"+stamp);\n            //暂停几秒钟线程\n            try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            boolean result = atomicStampedReference.compareAndSet(100, 20210308, stamp, stamp + 1);\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+result+\"\\t\"+atomicStampedReference.getReference());\n        &#125;,\"t4\").start();\n    &#125;\n\n    public static void abaProblem()\n    &#123;\n        new Thread(() -> &#123;\n            atomicInteger.compareAndSet(100,101);\n            atomicInteger.compareAndSet(101,100);\n        &#125;,\"t1\").start();\n\n        try &#123; TimeUnit.MILLISECONDS.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            atomicInteger.compareAndSet(100,20210308);\n            System.out.println(atomicInteger.get());\n        &#125;,\"t2\").start();\n    &#125;\n&#125;\n\n\n\n\nAtomicMarkableReference\n原子更新带有标记位的引用类型对象\n解决是否修改过 它的定义就是将状态戳简化为true|false – 类似一次性筷子\n\n\n\n状态戳(true&#x2F;false)原子引用\npublic class ABADemo\n&#123;\n    static AtomicInteger atomicInteger = new AtomicInteger(100);\n    static AtomicStampedReference&lt;Integer> stampedReference = new AtomicStampedReference&lt;>(100,1);\n    static AtomicMarkableReference&lt;Integer> markableReference = new AtomicMarkableReference&lt;>(100,false);\n\n    public static void main(String[] args)\n    &#123;\n        new Thread(() -> &#123;\n            atomicInteger.compareAndSet(100,101);\n            atomicInteger.compareAndSet(101,100);\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\"update ok\");\n        &#125;,\"t1\").start();\n\n        new Thread(() -> &#123;\n            //暂停几秒钟线程\n            try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            atomicInteger.compareAndSet(100,2020);\n        &#125;,\"t2\").start();\n\n        //暂停几秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        System.out.println(atomicInteger.get());\n\n        System.out.println();\n        System.out.println();\n        System.out.println();\n\n        System.out.println(\"============以下是ABA问题的解决,让我们知道引用变量中途被更改了几次=========================\");\n        new Thread(() -> &#123;\n            System.out.println(Thread.currentThread().getName()+\"\\t 1次版本号\"+stampedReference.getStamp());\n            //故意暂停200毫秒，让后面的t4线程拿到和t3一样的版本号\n            try &#123; TimeUnit.MILLISECONDS.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n            stampedReference.compareAndSet(100,101,stampedReference.getStamp(),stampedReference.getStamp()+1);\n            System.out.println(Thread.currentThread().getName()+\"\\t 2次版本号\"+stampedReference.getStamp());\n            stampedReference.compareAndSet(101,100,stampedReference.getStamp(),stampedReference.getStamp()+1);\n            System.out.println(Thread.currentThread().getName()+\"\\t 3次版本号\"+stampedReference.getStamp());\n        &#125;,\"t3\").start();\n\n        new Thread(() -> &#123;\n            int stamp = stampedReference.getStamp();\n            System.out.println(Thread.currentThread().getName()+\"\\t =======1次版本号\"+stamp);\n            //暂停2秒钟,让t3先完成ABA操作了，看看自己还能否修改\n            try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            boolean b = stampedReference.compareAndSet(100, 2020, stamp, stamp + 1);\n            System.out.println(Thread.currentThread().getName()+\"\\t=======2次版本号\"+stampedReference.getStamp()+\"\\t\"+stampedReference.getReference());\n        &#125;,\"t4\").start();\n\n        System.out.println();\n        System.out.println();\n        System.out.println();\n\n        System.out.println(\"============AtomicMarkableReference不关心引用变量更改过几次，只关心是否更改过======================\");\n\n        new Thread(() -> &#123;\n            boolean marked = markableReference.isMarked();\n            System.out.println(Thread.currentThread().getName()+\"\\t 1次版本号\"+marked);\n            try &#123; TimeUnit.MILLISECONDS.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            markableReference.compareAndSet(100,101,marked,!marked);\n            System.out.println(Thread.currentThread().getName()+\"\\t 2次版本号\"+markableReference.isMarked());\n            markableReference.compareAndSet(101,100,markableReference.isMarked(),!markableReference.isMarked());\n            System.out.println(Thread.currentThread().getName()+\"\\t 3次版本号\"+markableReference.isMarked());\n        &#125;,\"t5\").start();\n\n        new Thread(() -> &#123;\n            boolean marked = markableReference.isMarked();\n            System.out.println(Thread.currentThread().getName()+\"\\t 1次版本号\"+marked);\n            //暂停几秒钟线程\n            try &#123; TimeUnit.MILLISECONDS.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            markableReference.compareAndSet(100,2020,marked,!marked);\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+markableReference.getReference()+\"\\t\"+markableReference.isMarked());\n        &#125;,\"t6\").start();\n    &#125;\n&#125;\n\n4、对象的属性修改原子类\nAtomicIntegerFieldUpdater\n原子更新对象中int类型字段的值\n\n\nAtomicLongFieldUpdater\n原子更新对象中Long类型字段的值\n\n\nAtomicReferenceFieldUpdater\n原子更新引用类型字段的值\n\n\n\n1、使用目的以一种线程安全的方式操作非线程安全对象内的某些字段\n2、使用要求更新的对象属性必须使用 public volatile 修饰符。\n因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。\n3、AtomicIntegerFieldUpdaterDemoclass BankAccount\n&#123;\n    private String bankName = \"CCB\";//银行\n    public volatile int money = 0;//钱数\n    AtomicIntegerFieldUpdater&lt;BankAccount> accountAtomicIntegerFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(BankAccount.class,\"money\");\n\n    //不加锁+性能高，局部微创\n    public void transferMoney(BankAccount bankAccount)\n    &#123;\n        accountAtomicIntegerFieldUpdater.incrementAndGet(bankAccount);\n    &#125;\n&#125;\n\n/**\n * @auther zzyy\n * @create 2020-07-14 18:06\n * 以一种线程安全的方式操作非线程安全对象的某些字段。\n * 需求：\n * 1000个人同时向一个账号转账一元钱，那么累计应该增加1000元，\n * 除了synchronized和CAS,还可以使用AtomicIntegerFieldUpdater来实现。\n */\npublic class AtomicIntegerFieldUpdaterDemo\n&#123;\n\n    public static void main(String[] args)\n    &#123;\n        BankAccount bankAccount = new BankAccount();\n\n        for (int i = 1; i &lt;=1000; i++) &#123;\n            int finalI = i;\n            new Thread(() -> &#123;\n                bankAccount.transferMoney(bankAccount);\n            &#125;,String.valueOf(i)).start();\n        &#125;\n\n        //暂停毫秒\n        try &#123; TimeUnit.MILLISECONDS.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        System.out.println(bankAccount.money);\n\n    &#125;\n&#125;\n\n4、AtomicReferenceFieldUpdaterclass MyVar\n&#123;\n    public volatile Boolean isInit = Boolean.FALSE;\n    AtomicReferenceFieldUpdater&lt;MyVar,Boolean> atomicReferenceFieldUpdater = AtomicReferenceFieldUpdater.newUpdater(MyVar.class,Boolean.class,\"isInit\");\n\n\n    public void init(MyVar myVar)\n    &#123;\n        if(atomicReferenceFieldUpdater.compareAndSet(myVar,Boolean.FALSE,Boolean.TRUE))\n        &#123;\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\"---init.....\");\n            //暂停几秒钟线程\n            try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\"---init.....over\");\n        &#125;else&#123;\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\"------其它线程正在初始化\");\n        &#125;\n    &#125;\n\n\n&#125;\n\n\n/**\n * 多线程并发调用一个类的初始化方法，如果未被初始化过，将执行初始化工作，要求只能初始化一次\n */\npublic class AtomicIntegerFieldUpdaterDemo\n&#123;\n    public static void main(String[] args) throws InterruptedException\n    &#123;\n        MyVar myVar = new MyVar();\n\n        for (int i = 1; i &lt;=5; i++) &#123;\n            new Thread(() -> &#123;\n                myVar.init(myVar);\n            &#125;,String.valueOf(i)).start();\n        &#125;\n    &#125;\n&#125;\n\n5、你在哪里用了volatileAtomicReferenceFieldUpdater\n6、原子操作增强类原理深度解析\nDoubleAccumulator\nDoubleAdder\nLongAccumulator\nLongAdder\n\n\n1、点赞计数器，看看性能\nLongAdder只能用来计算加法，且从零开始计算\nLongAccumulator提供了自定义的函数操作\n//long类型的聚合器，需要传入一个long类型的二元操作，可以用来计算各种聚合操作，包括加乘等\n\nimport java.util.concurrent.atomic.LongAccumulator;\nimport java.util.concurrent.atomic.LongAdder;\nimport java.util.function.LongBinaryOperator;\n\npublic class LongAccumulatorDemo\n&#123;\n\n    LongAdder longAdder = new LongAdder();\n    public void add_LongAdder()\n    &#123;\n        longAdder.increment();\n    &#125;\n\n    //LongAccumulator longAccumulator = new LongAccumulator((x, y) -> x + y,0);\n    LongAccumulator longAccumulator = new LongAccumulator(new LongBinaryOperator()\n    &#123;\n        @Override\n        public long applyAsLong(long left, long right)\n        &#123;\n            return left - right;\n        &#125;\n    &#125;,777);\n\n    public void add_LongAccumulator()\n    &#123;\n        longAccumulator.accumulate(1);\n    &#125;\n\n    public static void main(String[] args)\n    &#123;\n        LongAccumulatorDemo demo = new LongAccumulatorDemo();\n\n        demo.add_LongAccumulator();\n        demo.add_LongAccumulator();\n        System.out.println(demo.longAccumulator.longValue());\n    &#125;\n&#125;\n\n2、LongAdderAPIDemopublic class LongAdderAPIDemo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        LongAdder longAdder = new LongAdder();\n\n        longAdder.increment();\n        longAdder.increment();\n        longAdder.increment();\n\n        System.out.println(longAdder.longValue());\n\n        LongAccumulator longAccumulator = new LongAccumulator((x,y) -> x * y,2);\n\n        longAccumulator.accumulate(1);\n        longAccumulator.accumulate(2);\n        longAccumulator.accumulate(3);\n\n        System.out.println(longAccumulator.longValue());\n\n    &#125;\n&#125;\n\n3、LongAdder高性能对比Code演示class ClickNumberNet\n&#123;\n    int number = 0;\n    public synchronized void clickBySync()\n    &#123;\n        number++;\n    &#125;\n\n    AtomicLong atomicLong = new AtomicLong(0);\n    public void clickByAtomicLong()\n    &#123;\n        atomicLong.incrementAndGet();\n    &#125;\n\n    LongAdder longAdder = new LongAdder();\n    public void clickByLongAdder()\n    &#123;\n        longAdder.increment();\n    &#125;\n\n    LongAccumulator longAccumulator = new LongAccumulator((x,y) -> x + y,0);\n    public void clickByLongAccumulator()\n    &#123;\n        longAccumulator.accumulate(1);\n    &#125;\n&#125;\n\n/**\n * @auther zzyy\n * @create 2020-05-21 22:23\n * 50个线程，每个线程100W次，总点赞数出来\n */\npublic class LongAdderDemo2\n&#123;\n    public static void main(String[] args) throws InterruptedException\n    &#123;\n        ClickNumberNet clickNumberNet = new ClickNumberNet();\n\n        long startTime;\n        long endTime;\n        CountDownLatch countDownLatch = new CountDownLatch(50);\n        CountDownLatch countDownLatch2 = new CountDownLatch(50);\n        CountDownLatch countDownLatch3 = new CountDownLatch(50);\n        CountDownLatch countDownLatch4 = new CountDownLatch(50);\n\n\n        startTime = System.currentTimeMillis();\n        for (int i = 1; i &lt;=50; i++) &#123;\n            new Thread(() -> &#123;\n                try\n                &#123;\n                    for (int j = 1; j &lt;=100 * 10000; j++) &#123;\n                        clickNumberNet.clickBySync();\n                    &#125;\n                &#125;finally &#123;\n                    countDownLatch.countDown();\n                &#125;\n            &#125;,String.valueOf(i)).start();\n        &#125;\n        countDownLatch.await();\n        endTime = System.currentTimeMillis();\n        System.out.println(\"----costTime: \"+(endTime - startTime) +\" 毫秒\"+\"\\t clickBySync result: \"+clickNumberNet.number);\n\n        startTime = System.currentTimeMillis();\n        for (int i = 1; i &lt;=50; i++) &#123;\n            new Thread(() -> &#123;\n                try\n                &#123;\n                    for (int j = 1; j &lt;=100 * 10000; j++) &#123;\n                        clickNumberNet.clickByAtomicLong();\n                    &#125;\n                &#125;finally &#123;\n                    countDownLatch2.countDown();\n                &#125;\n            &#125;,String.valueOf(i)).start();\n        &#125;\n        countDownLatch2.await();\n        endTime = System.currentTimeMillis();\n        System.out.println(\"----costTime: \"+(endTime - startTime) +\" 毫秒\"+\"\\t clickByAtomicLong result: \"+clickNumberNet.atomicLong);\n\n        startTime = System.currentTimeMillis();\n        for (int i = 1; i &lt;=50; i++) &#123;\n            new Thread(() -> &#123;\n                try\n                &#123;\n                    for (int j = 1; j &lt;=100 * 10000; j++) &#123;\n                        clickNumberNet.clickByLongAdder();\n                    &#125;\n                &#125;finally &#123;\n                    countDownLatch3.countDown();\n                &#125;\n            &#125;,String.valueOf(i)).start();\n        &#125;\n        countDownLatch3.await();\n        endTime = System.currentTimeMillis();\n        System.out.println(\"----costTime: \"+(endTime - startTime) +\" 毫秒\"+\"\\t clickByLongAdder result: \"+clickNumberNet.longAdder.sum());\n\n        startTime = System.currentTimeMillis();\n        for (int i = 1; i &lt;=50; i++) &#123;\n            new Thread(() -> &#123;\n                try\n                &#123;\n                    for (int j = 1; j &lt;=100 * 10000; j++) &#123;\n                        clickNumberNet.clickByLongAccumulator();\n                    &#125;\n                &#125;finally &#123;\n                    countDownLatch4.countDown();\n                &#125;\n            &#125;,String.valueOf(i)).start();\n        &#125;\n        countDownLatch4.await();\n        endTime = System.currentTimeMillis();\n        System.out.println(\"----costTime: \"+(endTime - startTime) +\" 毫秒\"+\"\\t clickByLongAccumulator result: \"+clickNumberNet.longAccumulator.longValue());\n\n\n    &#125;\n&#125;\n\n\n4、源码、原理分析1、架构\nLongAdder是Striped64的子类\n\n2、剩下两罗汉Striped64\nNumber\n\n3、原理(LongAdder为什么这么快)\n1、Striped64有几个比较重要的成员函数/** Number of CPUS, to place bound on table size        CPU数量，即cells数组的最大长度 */\nstatic final int NCPU = Runtime.getRuntime().availableProcessors();\n\n/**\n * Table of cells. When non-null, size is a power of 2.\ncells数组，为2的幂，2,4,8,16.....，方便以后位运算\n */\ntransient volatile Cell[] cells;\n\n/**基础value值，当并发较低时，只累加该值主要用于没有竞争的情况，通过CAS更新。\n * Base value, used mainly when there is no contention, but also as\n * a fallback during table initialization races. Updated via CAS.\n */\ntransient volatile long base;\n\n/**创建或者扩容Cells数组时使用的自旋锁变量调整单元格大小（扩容），创建单元格时使用的锁。\n * Spinlock (locked via CAS) used when resizing and/or creating Cells. \n */\ntransient volatile int cellsBusy;\n\n最重要的2个\n\n2、Striped64中一些变量或者方法的定义\n3、Cell是 java.util.concurrent.atomic 下 Striped64 的一个内部类\n\n4、LongAdder为什么这么快​\t\tLongAdder的基本思路就是分散热点，将value值分散到一个Cell数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。\n​\t\tsum()会将所有Cell数组中的value和base累加作为返回值，核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，从而降级更新热点。\n\n\n内部有一个base变量，一个Cell[]数组。\nbase变量：非竞态条件下，直接累加到该变量上\nCell[]数组：竞态条件下，累加个各个线程自己的槽Cell[i]中\n4、源码解读深度分析​\t\tLongAdder在无竞争的情况，跟AtomicLong一样，对同一个base进行操作，当出现竞争关系时则是采用化整为零的做法，从空间换时间，用一个数组cells，将一个value拆分进这个数组cells。多个线程需要同时对value进行操作时候，可以对线程id进行hash得到hash值，再根据hash值映射到这个数组cells的某个下标，再对该下标所对应的值进行自增操作。当所有线程操作完毕，将数组cells的所有值和无竞争值base都加起来作为最终结果。\n\nlongAdder.increment()\n\n1、add(1L)\n\n\n\n最初无竞争时只更新base；\n如果更新base失败后，首次新建一个Cell[]数组\n当多个线程竞争同一个Cell比较激烈时，可能就要对Cell[]扩容\n\n2、longAccumulatelongAccumulate入参说明\n\nStriped64中一些变量或者方法的定义\n\n线程hash值：probe\n\n\n\n\n总纲\n\n上述代码首先给当前线程分配一个hash值，然后进入一个for(;;)自旋，这个自旋分为三个分支：\nCASE1：Cell[]数组已经初始化\nCASE2：Cell[]数组未初始化(首次新建)\nCASE3：Cell[]数组正在初始化中\n\n刚刚要初始化Cell[]数组(首次新建)\n未初始化过Cell[]数组，尝试占有锁并首次初始化cells数组\n\n如果上面条件都执行成功就会执行数组的初始化及赋值操作， Cell[] rs &#x3D; new Cell[2]表示数组的长度为2，\nrs[h &amp; 1] &#x3D; new Cell(x) 表示创建一个新的Cell元素，value是x值，默认为1。\nh &amp; 1类似于我们之前HashMap常用到的计算散列桶index的算法，通常都是hash &amp; (table.len - 1)。同hashmap一个意思。\n\n兜底\n多个线程尝试CAS修改失败的线程会走到这个分支\n\n该分支实现直接操作base基数，将值累加到base上，也即其它线程正在初始化，多个线程正在更新base的值。\nCell数组不再为空且可能存在Cell数组扩容\n多个线程同时命中一个cell的竞争\n\n1. \n   \n上面代码判断当前线程hash后指向的数据位置元素是否为空，\n如果为空则将Cell数据放入数组中，跳出循环。\n如果不空则继续循环。\n\n2. \n\n\n\n说明当前线程对应的数组中有了数据，也重置过hash值，\n这时通过CAS操作尝试对当前数中的value值进行累加x操作，x默认为1，如果CAS成功则直接跳出循环。\n\n\n\n\n\n\n\n\n\n3、sumsum()会将所有Cell数组中的value和base累加作为返回值。核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，从而降级更新热点。\n为啥在并发情况下sum的值不精确\nsum执行时，并没有限制对base和cells的更新(一句要命的话)。所以LongAdder不是强一致性的，它是最终一致性的。\n​\t\t首先，最终返回的sum局部变量，初始被复制为base，而最终返回时，很可能base已经被更新了，而此时局部变量sum不会更新，造成不一致。其次，这里对cell的读取也无法保证是最后一次写入的值。所以，sum方法在没有并发的情况下，可以获得正确的结果。\n\n5、使用总结\nAtomicLong\n线程安全，可允许一些性能损耗，要求高精度时可使用\n保证精度，性能代价\nAtomicLong是多个线程针对单个热点值value进行原子操作\n\n\nLongAdder\n当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用\n保证性能，精度代价\nLongAdder是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行CAS操作\n\n\n\n7、总结1、AtomicLong\n原理\nCAS+自旋\nincrementAndGet\n\n\n场景\n低并发下的全局计算\nAtomicLong能保证并发情况下计数的准确性，其内部通过CAS来解决并发安全性的问题。\n\n\n缺陷\n高并发后性能急剧下降\nAtomicLong的自旋会成为瓶颈\nN个线程CAS操作修改线程的值，每次只有一个成功过，其它N - 1失败，失败的不停的自旋直到成功，这样大量失败自旋的情况，一下子cpu就打高了。\n\n\n\n2、LongAdder\n原理\nCAS+Base+Cell数组分散\n空间换时间并分散了热点数据\n\n\n场景\n高并发下的全局计算\n\n\n缺陷\nsum求和后还有计算线程修改结果的话，最后结果不够准确\n\n\n\n十三、ThreadLocal、InheritableThreadLocal1、ThreadLocal简介\n​\t\t稍微翻译一下：​\t\tThreadLocal提供线程局部变量。这些变量与正常的变量不同，因为每一个线程在访问ThreadLocal实例的时候（通过其get或set方法）都有自己的、独立初始化的变量副本。ThreadLocal实例通常是类中的私有静态字段，使用它的目的是希望将状态（例如，用户ID或事务ID）与线程关联起来。\n​\t\t实现每一个线程都有自己专属的本地变量副本(自己用自己的变量不麻烦别人，不和其他人共享，人人有份，人各一份)，主要解决了让每个线程绑定自己的值，通过使用get()和set()方法，获取默认值或将其值更改为当前线程所存的副本的值从而避免了线程安全问题。\n\n\n2、永远的helloworld按照总销售额统计，方便集团公司做计划统计\nclass MovieTicket\n&#123;\n    int number = 50;\n\n    public synchronized void saleTicket()\n    &#123;\n        if(number > 0)\n        &#123;\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\"号售票员卖出第： \"+(number--));\n        &#125;else&#123;\n            System.out.println(\"--------卖完了\");\n        &#125;\n    &#125;\n&#125;\n\n/**\n * 三个售票员卖完50张票务，总量完成即可，吃大锅饭，售票员每个月固定月薪\n */\npublic class ThreadLocalDemo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        MovieTicket movieTicket = new MovieTicket();\n\n        for (int i = 1; i &lt;=3; i++) &#123;\n            new Thread(() -> &#123;\n                for (int j = 0; j &lt;20; j++) &#123;\n                    movieTicket.saleTicket();\n                    try &#123; TimeUnit.MILLISECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n                &#125;\n            &#125;,String.valueOf(i)).start();\n        &#125;\n    &#125;\n&#125;\n\n不参加总和计算，希望各自分灶吃饭，各凭销售本事提成，按照出单数各自统计\nclass MovieTicket\n&#123;\n    int number = 50;\n\n    public synchronized void saleTicket()\n    &#123;\n        if(number > 0)\n        &#123;\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\"号售票员卖出第： \"+(number--));\n        &#125;else&#123;\n            System.out.println(\"--------卖完了\");\n        &#125;\n    &#125;\n&#125;\n\nclass House\n&#123;\n    ThreadLocal&lt;Integer> threadLocal = ThreadLocal.withInitial(() -> 0);\n\n    public void saleHouse()\n    &#123;\n        Integer value = threadLocal.get();\n        value++;\n        threadLocal.set(value);\n    &#125;\n&#125;\n\n/**\n * 1  三个售票员卖完50张票务，总量完成即可，吃大锅饭，售票员每个月固定月薪\n *\n * 2  分灶吃饭，各个销售自己动手，丰衣足食\n */\npublic class ThreadLocalDemo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        /*MovieTicket movieTicket = new MovieTicket();\n\n        for (int i = 1; i &lt;=3; i++) &#123;\n            new Thread(() -> &#123;\n                for (int j = 0; j &lt;20; j++) &#123;\n                    movieTicket.saleTicket();\n                    try &#123; TimeUnit.MILLISECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n                &#125;\n            &#125;,String.valueOf(i)).start();\n        &#125;*/\n\n        //===========================================\n        House house = new House();\n\n        new Thread(() -> &#123;\n            try &#123;\n                for (int i = 1; i &lt;=3; i++) &#123;\n                    house.saleHouse();\n                &#125;\n                System.out.println(Thread.currentThread().getName()+\"\\t\"+\"---\"+house.threadLocal.get());\n            &#125;finally &#123;\n                house.threadLocal.remove();//如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题\n            &#125;\n        &#125;,\"t1\").start();\n\n        new Thread(() -> &#123;\n            try &#123;\n                for (int i = 1; i &lt;=2; i++) &#123;\n                    house.saleHouse();\n                &#125;\n                System.out.println(Thread.currentThread().getName()+\"\\t\"+\"---\"+house.threadLocal.get());\n            &#125;finally &#123;\n                house.threadLocal.remove();\n            &#125;\n        &#125;,\"t2\").start();\n\n        new Thread(() -> &#123;\n            try &#123;\n                for (int i = 1; i &lt;=5; i++) &#123;\n                    house.saleHouse();\n                &#125;\n                System.out.println(Thread.currentThread().getName()+\"\\t\"+\"---\"+house.threadLocal.get());\n            &#125;finally &#123;\n                house.threadLocal.remove();\n            &#125;\n        &#125;,\"t3\").start();\n\n\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\"---\"+house.threadLocal.get());\n    &#125;\n&#125;\n\n1、小总结因为每个 Thread 内有自己的实例副本且该副本只由当前线程自己使用\n既然其它 Thread 不可访问，那就不存在多线程间共享的问题。\n统一设置初始值，但是每个线程对这个值的修改都是各自线程互相独立的\n\n加入synchronized或者Lock控制资源的访问顺序\n\n人手一份，大家各自安好，没必要抢夺\n\n\n3、从阿里ThreadLocal规范开始\n1、非线程安全的SimpleDateFormat\n​\t\t上述翻译：SimpleDateFormat中的日期格式不是同步的。推荐（建议）为每个线程创建独立的格式实例。如果多个线程同时访问一个格式，则它必须保持外部同步。\npublic class DateUtils&#123;\n    public static final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    /**\n     * 模拟并发环境下使用SimpleDateFormat的parse方法将字符串转换成Date对象\n     * @param stringDate\n     * @return\n     * @throws Exception\n     */\n    public static Date parseDate(String stringDate)throws Exception&#123;\n        return sdf.parse(stringDate);\n    &#125;\n    \n    public static void main(String[] args) throws Exception&#123;\n        for (int i = 1; i &lt;=30; i++) &#123;\n            new Thread(() -> &#123;\n                try &#123;\n                    System.out.println(DateUtils.parseDate(\"2020-11-11 11:11:11\"));\n                &#125; catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;,String.valueOf(i)).start();\n        &#125;\n    &#125;\n&#125;\n\njava.lang.NumberFormatException: For input string: \"\"\n\tat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\n\tat java.lang.Long.parseLong(Long.java:601)\n\tat java.lang.Long.parseLong(Long.java:631)\n\tat java.text.DigitList.getLong(DigitList.java:195)\n\tat java.text.DecimalFormat.parse(DecimalFormat.java:2082)\n\tat java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)\n\tat java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)\n\tat java.text.DateFormat.parse(DateFormat.java:364)\n\tat com.zdww.tcm.utils.DateTimeUtil.parseDate(DateTimeUtil.java:1129)\n\tat com.zdww.tcm.utils.DateTimeUtil.lambda$main$0(DateTimeUtil.java:1137)\n\tat java.lang.Thread.run(Thread.java:748)\njava.lang.NumberFormatException: For input string: \".20202E.20202E44\"\n\tat sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:2043)\n\tat sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)\n\tat java.lang.Double.parseDouble(Double.java:538)\n\tat java.text.DigitList.getDouble(DigitList.java:169)\n\tat java.text.DecimalFormat.parse(DecimalFormat.java:2087)\n\tat java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)\n\tat java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)\n\tat java.text.DateFormat.parse(DateFormat.java:364)\n\tat com.zdww.tcm.utils.DateTimeUtil.parseDate(DateTimeUtil.java:1129)\n\tat com.zdww.tcm.utils.DateTimeUtil.lambda$main$0(DateTimeUtil.java:1137)\n\n​\t\tSimpleDateFormat类内部有一个Calendar对象引用,它用来储存和这个SimpleDateFormat相关的日期信息,例如sdf.parse(dateStr),sdf.format(date) 诸如此类的方法参数传入的日期相关String,Date等等, 都是交由Calendar引用来储存的.这样就会导致一个问题如果你的SimpleDateFormat是个static的, 那么多个thread 之间就会共享这个SimpleDateFormat, 同时也是共享这个Calendar引用。\n\n\n2、解决1将SimpleDateFormat定义成局部变量。\n缺点：每调用一次方法就会创建一个SimpleDateFormat对象，方法结束又要作为垃圾回收。\npublic class DateUtils&#123;\n    public static final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    /**\n     * 模拟并发环境下使用SimpleDateFormat的parse方法将字符串转换成Date对象\n     * @param stringDate\n     * @return\n     * @throws Exception\n     */\n    public static Date parseDate(String stringDate)throws Exception&#123;\n        return sdf.parse(stringDate);\n    &#125;\n\n    public static void main(String[] args) throws Exception&#123;\n        for (int i = 1; i &lt;=30; i++) &#123;\n            new Thread(() -> &#123;\n                try &#123;\n                    SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n                    System.out.println(sdf.parse(\"2020-11-11 11:11:11\"));\n                    sdf = null;\n                &#125; catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;,String.valueOf(i)).start();\n        &#125;\n    &#125;\n&#125;\n\n3、解决2ThreadLocal，也叫做线程本地变量或者线程本地存储\npublic class DateUtils&#123;\n    private static final ThreadLocal&lt;SimpleDateFormat>  sdf_threadLocal =\n            ThreadLocal.withInitial(()-> new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"));\n\n    /**\n     * ThreadLocal可以确保每个线程都可以得到各自单独的一个SimpleDateFormat的对象，那么自然也就不存在竞争问题了。\n     * @param stringDate\n     * @return\n     * @throws Exception\n     */\n    public static Date parseDateTL(String stringDate)throws Exception&#123;\n        return sdf_threadLocal.get().parse(stringDate);\n    &#125;\n\n    public static void main(String[] args) throws Exception&#123;\n        for (int i = 1; i &lt;=30; i++) &#123;\n            new Thread(() -> &#123;\n                try &#123;\n                    System.out.println(DateUtils.parseDateTL(\"2020-11-11 11:11:11\"));\n                &#125; catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;,String.valueOf(i)).start();\n        &#125;\n    &#125;\n&#125;\n\npublic class DateUtils&#123;\n    /*\n    1   SimpleDateFormat如果多线程共用是线程不安全的类\n    public static final SimpleDateFormat SIMPLE_DATE_FORMAT = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n    public static String format(Date date)\n    &#123;\n        return SIMPLE_DATE_FORMAT.format(date);\n    &#125;\n\n    public static Date parse(String datetime) throws ParseException\n    &#123;\n        return SIMPLE_DATE_FORMAT.parse(datetime);\n    &#125;*/\n\n    //2   ThreadLocal可以确保每个线程都可以得到各自单独的一个SimpleDateFormat的对象，那么自然也就不存在竞争问题了。\n    public static final ThreadLocal&lt;SimpleDateFormat> SIMPLE_DATE_FORMAT_THREAD_LOCAL = ThreadLocal.withInitial(() -> new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"));\n\n    public static String format(Date date)&#123;\n        return SIMPLE_DATE_FORMAT_THREAD_LOCAL.get().format(date);\n    &#125;\n\n    public static Date parse(String datetime) throws ParseException&#123;\n        return SIMPLE_DATE_FORMAT_THREAD_LOCAL.get().parse(datetime);\n    &#125;\n\n\n    //3 DateTimeFormatter 代替 SimpleDateFormat\n    /*public static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n\n    public static String format(LocalDateTime localDateTime)\n    &#123;\n        return DATE_TIME_FORMAT.format(localDateTime);\n    &#125;\n\n    public static LocalDateTime parse(String dateString)\n    &#123;\n\n        return LocalDateTime.parse(dateString,DATE_TIME_FORMAT);\n    &#125;*/\n&#125;\n\n4、ThreadLocal源码分析1、Thread，ThreadLocal，ThreadLocalMap 关系Thread和ThreadLocal\n\n再次体会，各自线程，人手一份\nThreadLocal和ThreadLocalMap\n\nAll三者总概括\n\n​\t\tthreadLocalMap实际上就是一个以threadLocal实例为key，任意对象为value的Entry对象。当我们为threadLocal变量赋值，实际上就是以当前threadLocal实例为key，值为value的Entry往这个threadLocalMap中存放\n近似的可以理解为:ThreadLocalMap从字面上就可以看出这是一个保存ThreadLocal对象的map(其实是以ThreadLocal为Key)，不过是经过了两层包装的ThreadLocal对象：\n\n​\t\tJVM内部维护了一个线程版的Map&lt;Thread,T&gt;(通过ThreadLocal对象的set方法，结果把ThreadLocal对象自己当做key，放进了ThreadLoalMap中),每个线程要用到这个T的时候，用当前的线程去Map里面获取，通过这样让每个线程都拥有了自己独立的变量，人手一份，竞争条件被彻底消除，在并发模式下是绝对安全的变量。\n5、ThreadLocal内存泄露问题\n1、什么是内存泄漏不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。\n2、谁惹的祸？\n3、强引用、软引用、弱引用、虚引用分别是什么？\nThreadLocalMap从字面上就可以看出这是一个保存ThreadLocal对象的map(其实是以它为Key)，不过是经过了两层包装的ThreadLocal对象：（1）第一层包装是使用 WeakReference&lt;ThreadLocal> 将ThreadLocal对象变成一个弱引用的对象；\n（2）第二层包装是定义了一个专门的类 Entry 来扩展 WeakReference&gt;\n\njava 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。\n1、强引用(默认支持模式)当内存不足，JVM开始垃圾回收，对于强引用的对象，就算是出现了OOM也不会对该对象进行回收，死都不收。\n​\t\t强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之一。\n​\t\t对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，一般认为就是可以被垃圾收集的了(当然具体回收时机还是要看垃圾收集策略)。\npublic static void strongReference()\n&#123;\n    MyObject myObject = new MyObject();\n    System.out.println(\"-----gc before: \"+myObject);\n\n    myObject = null;\n    System.gc();\n    try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n    System.out.println(\"-----gc after: \"+myObject);\n&#125;\n\n2、软引用软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。\n对于只有软引用的对象来说，\n当系统内存充足时它      不会     被回收，\n当系统内存不足时它     会     被回收。\n软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收！\nclass MyObject\n&#123;\n    //一般开发中不用调用这个方法，本次只是为了演示\n    @Override\n    protected void finalize() throws Throwable\n    &#123;\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\"---finalize method invoked....\");\n    &#125;\n&#125;\n\npublic class ReferenceDemo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        //当我们内存不够用的时候，soft会被回收的情况，设置我们的内存大小：-Xms10m -Xmx10m\n        SoftReference&lt;MyObject> softReference = new SoftReference&lt;>(new MyObject());\n\n        System.gc();\n        try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n        System.out.println(\"-----gc after内存够用: \"+softReference.get());\n\n        try\n        &#123;\n            byte[] bytes = new byte[9 * 1024 * 1024];\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;finally &#123;\n            System.out.println(\"-----gc after内存不够: \"+softReference.get());\n        &#125;\n    &#125;\n\n    public static void strongReference()\n    &#123;\n        MyObject myObject = new MyObject();\n        System.out.println(\"-----gc before: \"+myObject);\n\n        myObject = null;\n        System.gc();\n        try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        System.out.println(\"-----gc after: \"+myObject);\n    &#125;\n&#125;\n\n3、弱引用​\t\t弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存。\nclass MyObject\n&#123;\n    //一般开发中不用调用这个方法，本次只是为了演示\n    @Override\n    protected void finalize() throws Throwable\n    &#123;\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\"---finalize method invoked....\");\n    &#125;\n&#125;\n\npublic class ReferenceDemo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        WeakReference&lt;MyObject> weakReference = new WeakReference&lt;>(new MyObject());\n        System.out.println(\"-----gc before内存够用: \"+weakReference.get());\n\n        System.gc();\n        try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        System.out.println(\"-----gc after内存够用: \"+weakReference.get());\n    &#125;\n\n    public static void softReference()\n    &#123;\n        //当我们内存不够用的时候，soft会被回收的情况，设置我们的内存大小：-Xms10m -Xmx10m\n        SoftReference&lt;MyObject> softReference = new SoftReference&lt;>(new MyObject());\n\n        System.gc();\n        try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n        System.out.println(\"-----gc after内存够用: \"+softReference.get());\n\n        try\n        &#123;\n            byte[] bytes = new byte[9 * 1024 * 1024];\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;finally &#123;\n            System.out.println(\"-----gc after内存不够: \"+softReference.get());\n        &#125;\n    &#125;\n\n    public static void strongReference()\n    &#123;\n        MyObject myObject = new MyObject();\n        System.out.println(\"-----gc before: \"+myObject);\n\n        myObject = null;\n        System.gc();\n        try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        System.out.println(\"-----gc after: \"+myObject);\n    &#125;\n&#125;\n\n软引用和弱引用的适用场景\n假如有一个应用需要读取大量的本地图片:\n如果每次读取图片都从硬盘读取则会严重影响性能,\n如果一次性全部加载到内存中又可能造成内存溢出。\n此时使用软引用可以解决这个问题。\n　　设计思路是：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。\nMap&lt;String, SoftReference&gt; imageCache &#x3D; new HashMap&lt;String, SoftReference&gt;();\n4、虚引用虚引用需要java.lang.ref.PhantomReference类来实现。\n​\t\t顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列 (ReferenceQueue)联合使用。\n​\t\t虚引用的主要作用是跟踪对象被垃圾回收的状态。 仅仅是提供了一种确保对象被 finalize以后，做某些事情的机制。 PhantomReference的get方法总是返回null，因此无法访问对应的引用对象。\n其意义在于：说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作。\n换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理。\n\n\n我被回收前需要被引用队列保存下。\nclass MyObject\n&#123;\n    //一般开发中不用调用这个方法，本次只是为了演示\n    @Override\n    protected void finalize() throws Throwable\n    &#123;\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\"---finalize method invoked....\");\n    &#125;\n&#125;\n\npublic class ReferenceDemo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        ReferenceQueue&lt;MyObject> referenceQueue = new ReferenceQueue();\n        PhantomReference&lt;MyObject> phantomReference = new PhantomReference&lt;>(new MyObject(),referenceQueue);\n        //System.out.println(phantomReference.get());\n\n        List&lt;byte[]> list = new ArrayList&lt;>();\n\n        new Thread(() -> &#123;\n            while (true)\n            &#123;\n                list.add(new byte[1 * 1024 * 1024]);\n                try &#123; TimeUnit.MILLISECONDS.sleep(600); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n                System.out.println(phantomReference.get());\n            &#125;\n        &#125;,\"t1\").start();\n\n        new Thread(() -> &#123;\n            while (true)\n            &#123;\n                Reference&lt;? extends MyObject> reference = referenceQueue.poll();\n                if (reference != null) &#123;\n                    System.out.println(\"***********有虚对象加入队列了\");\n                &#125;\n            &#125;\n        &#125;,\"t2\").start();\n\n        //暂停几秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n    &#125;\n\n    public static void weakReference()\n    &#123;\n        WeakReference&lt;MyObject> weakReference = new WeakReference&lt;>(new MyObject());\n        System.out.println(\"-----gc before内存够用: \"+weakReference.get());\n\n        System.gc();\n        try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        System.out.println(\"-----gc after内存够用: \"+weakReference.get());\n    &#125;\n\n    public static void softReference()\n    &#123;\n        //当我们内存不够用的时候，soft会被回收的情况，设置我们的内存大小：-Xms10m -Xmx10m\n        SoftReference&lt;MyObject> softReference = new SoftReference&lt;>(new MyObject());\n\n        System.gc();\n        try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n        System.out.println(\"-----gc after内存够用: \"+softReference.get());\n\n        try\n        &#123;\n            byte[] bytes = new byte[9 * 1024 * 1024];\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;finally &#123;\n            System.out.println(\"-----gc after内存不够: \"+softReference.get());\n        &#125;\n    &#125;\n\n    public static void strongReference()\n    &#123;\n        MyObject myObject = new MyObject();\n        System.out.println(\"-----gc before: \"+myObject);\n\n        myObject = null;\n        System.gc();\n        try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        System.out.println(\"-----gc after: \"+myObject);\n    &#125;\n&#125;\n\n5、GCRoots和四大引用小总结\n4、关系\n\n每个Thread对象维护着一个ThreadLocalMap的引用\nThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储\n调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值Value是传递进来的对象\n调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象\nThreadLocal本身并不存储值，它只是自己作为一个key来让线程从ThreadLocalMap获取value，正因为这个原理，所以ThreadLocal能够实现“数据隔离”，获取当前线程的局部变量值，不受其他线程影响～\n\n6、为什么要用弱引用?不用如何？public void function01()\n&#123;\n    ThreadLocal tl = new ThreadLocal&lt;Integer>();    //line1\n    tl.set(2021);                                   //line2\n    tl.get();                                       //line3\n&#125;\n//line1新建了一个ThreadLocal对象，t1 是强引用指向这个对象；\n//line2调用set()方法后新建一个Entry，通过源码可知Entry对象里的k是弱引用指向这个对象。\n\n\n​\t\t当function01方法执行完毕后，栈帧销毁强引用 tl 也就没有了。但此时线程的ThreadLocalMap里某个entry的key引用还指向这个对象,若这个key引用是强引用，就会导致key指向的ThreadLocal对象及v指向的对象不能被gc回收，造成内存泄漏；若这个key引用是弱引用就大概率会减少内存泄漏的问题(还有一个key为null的雷)。使用弱引用，就可以使ThreadLocal对象在方法执行完毕后顺利被回收且Entry的key引用指向为null。\n此后我们调用get,set或remove方法时，就会尝试删除key为null的entry，可以释放value对象所占用的内存。\n1、弱引用就万事大吉了吗？\n当我们为threadLocal变量赋值，实际上就是当前的Entry(threadLocal实例为key，值为value)往这个threadLocalMap中存放。Entry中的key是弱引用，当threadLocal外部强引用被置为null(tl&#x3D;null),那么系统 GC 的时候，根据可达性分析，这个threadLocal实例就没有任何一条链路能够引用到它，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。\n\n当然，如果当前thread运行结束，threadLocal，threadLocalMap,Entry没有引用链可达，在垃圾回收的时候都会被系统进行回收。\n\n但在实际使用中我们有时候会用线程池去维护我们的线程，比如在Executors.newFixedThreadPool()时创建线程的时候，为了复用线程是不会结束的，所以threadLocal内存泄漏就值得我们小心\n\n\n2、key为null的entry，原理解析\n​\t\tThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话(比如正好用在线程池)，这些key为null的Entry的value就会一直存在一条强引用链。\n​\t\t虽然弱引用，保证了key指向的ThreadLocal对象能被及时回收，但是v指向的value对象是需要ThreadLocalMap调用get、set时发现key为null时才会去回收整个entry、value，因此弱引用不能100%保证内存不泄露。我们要在不使用某个ThreadLocal对象后，手动调用remoev方法来删除它，尤其是在线程池中，不仅仅是内存泄露的问题，因为线程池中的线程是重复使用的，意味着这个线程的ThreadLocalMap对象也是重复使用的，如果我们不手动调用remove方法，那么后面的线程就有可能获取到上个线程遗留下来的value值，造成bug。\n3、set、get方法会去检查所有键为null的Entry对象set()\n\n\nget()\n\n\n\nremove()\n\n结论\n​\t\t从前面的set,getEntry,remove方法看出，在threadLocal的生命周期里，针对threadLocal存在的内存泄漏的问题，都会通过expungeStaleEntry，cleanSomeSlots,replaceStaleEntry这三个方法清理掉key为null的脏entry。\n4、结论\n\n7、最佳实践\n用完记得手动remove\n8、小总结\nThreadLocal 并不解决线程间共享数据的问题\nThreadLocal 适用于变量在线程间隔离且在方法间共享的场景\nThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题\n每个线程持有一个只属于自己的专属Map并维护了ThreadLocal对象与具体实例的映射，该Map由于只被持有它的线程访问，故不存在线程安全以及锁的问题\nThreadLocalMap的Entry对ThreadLocal的引用为弱引用，避免了ThreadLocal对象无法被回收的问题\n都会通过expungeStaleEntry，cleanSomeSlots,replaceStaleEntry这三个方法回收键为 null 的 Entry 对象的值（即为具体实例）以及 Entry 对象本身从而防止内存泄漏，属于安全加固的方法\n群雄逐鹿起纷争，人各一份天下安\n\n9、ThreadLocal和InheritableThreadLocal需要解决的问题\n\n\n\n\n\n\n\n\n\n我们还是以解决问题的方式来引出ThreadLocal、InheritableThreadLocal，这样印象会深刻一些。\n目前java开发web系统一般有3层，controller、service、dao，请求到达controller，controller调用service，service调用dao，然后进行处理。\n我们写一个简单的例子，有3个方法分别模拟controller、service、dao。代码如下：\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class Demo1 &#123;\n    static AtomicInteger threadIndex = new AtomicInteger(1);\n    //创建处理请求的线程池子\n    static ThreadPoolExecutor disposeRequestExecutor = new ThreadPoolExecutor(3,\n            3,\n            60,\n            TimeUnit.SECONDS,\n            new LinkedBlockingDeque&lt;>(),\n            r -> &#123;\n                Thread thread = new Thread(r);\n                thread.setName(\"disposeRequestThread-\" + threadIndex.getAndIncrement());\n                return thread;\n            &#125;);\n    //记录日志\n    public static void log(String msg) &#123;\n        StackTraceElement stack[] = (new Throwable()).getStackTrace();\n        System.out.println(\"****\" + System.currentTimeMillis() + \",[线程:\" + Thread.currentThread().getName() + \"],\" + stack[1] + \":\" + msg);\n    &#125;\n    //模拟controller\n    public static void controller(List&lt;String> dataList) &#123;\n        log(\"接受请求\");\n        service(dataList);\n    &#125;\n    //模拟service\n    public static void service(List&lt;String> dataList) &#123;\n        log(\"执行业务\");\n        dao(dataList);\n    &#125;\n    //模拟dao\n    public static void dao(List&lt;String> dataList) &#123;\n        log(\"执行数据库操作\");\n        //模拟插入数据\n        for (String s : dataList) &#123;\n            log(\"插入数据\" + s + \"成功\");\n        &#125;\n    &#125;\n    public static void main(String[] args) &#123;\n        //需要插入的数据\n        List&lt;String> dataList = new ArrayList&lt;>();\n        for (int i = 0; i &lt; 3; i++) &#123;\n            dataList.add(\"数据\" + i);\n        &#125;\n        //模拟5个请求\n        int requestCount = 5;\n        for (int i = 0; i &lt; requestCount; i++) &#123;\n            disposeRequestExecutor.execute(() -> &#123;\n                controller(dataList);\n            &#125;);\n        &#125;\n        disposeRequestExecutor.shutdown();\n    &#125;\n&#125;\n\n****1565338891286,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.controller(Demo1.java:36):接受请求\n****1565338891286,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.controller(Demo1.java:36):接受请求\n****1565338891287,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.service(Demo1.java:42):执行业务\n****1565338891287,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.service(Demo1.java:42):执行业务\n****1565338891287,[线程:disposeRequestThread-3],com.itsoku.chat24.Demo1.controller(Demo1.java:36):接受请求\n****1565338891287,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.dao(Demo1.java:48):执行数据库操作\n****1565338891287,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据0成功\n****1565338891287,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据1成功\n****1565338891287,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.dao(Demo1.java:48):执行数据库操作\n****1565338891287,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据2成功\n****1565338891287,[线程:disposeRequestThread-3],com.itsoku.chat24.Demo1.service(Demo1.java:42):执行业务\n****1565338891288,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.controller(Demo1.java:36):接受请求\n****1565338891287,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据0成功\n****1565338891288,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.service(Demo1.java:42):执行业务\n****1565338891288,[线程:disposeRequestThread-3],com.itsoku.chat24.Demo1.dao(Demo1.java:48):执行数据库操作\n****1565338891288,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.dao(Demo1.java:48):执行数据库操作\n****1565338891288,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据1成功\n****1565338891288,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据0成功\n****1565338891288,[线程:disposeRequestThread-3],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据0成功\n****1565338891288,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据1成功\n****1565338891288,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据2成功\n****1565338891288,[线程:disposeRequestThread-1],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据2成功\n****1565338891288,[线程:disposeRequestThread-3],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据1成功\n****1565338891288,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.controller(Demo1.java:36):接受请求\n****1565338891288,[线程:disposeRequestThread-3],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据2成功\n****1565338891288,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.service(Demo1.java:42):执行业务\n****1565338891289,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.dao(Demo1.java:48):执行数据库操作\n****1565338891289,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据0成功\n****1565338891289,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据1成功\n****1565338891289,[线程:disposeRequestThread-2],com.itsoku.chat24.Demo1.dao(Demo1.java:51):插入数据数据2成功\n\n代码中调用controller、service、dao 3个方法时，来模拟处理一个请求。main方法中循环了5次模拟发起5次请求，然后交给线程池去处理请求，dao中模拟循环插入传入的dataList数据。\n问题来了：开发者想看一下哪些地方耗时比较多，想通过日志来分析耗时情况，想追踪某个请求的完整日志，怎么搞？\n上面的请求采用线程池的方式处理的，多个请求可能会被一个线程处理，通过日志很难看出那些日志是同一个请求，我们能不能给请求加一个唯一标志，日志中输出这个唯一标志，当然可以。\n如果我们的代码就只有上面示例这么简单，我想还是很容易的，上面就3个方法，给每个方法加个traceId参数，log方法也加个traceId参数，就解决了，代码如下：\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class Demo2 &#123;\n    static AtomicInteger threadIndex = new AtomicInteger(1);\n    //创建处理请求的线程池子\n    static ThreadPoolExecutor disposeRequestExecutor = new ThreadPoolExecutor(3,\n            3,\n            60,\n            TimeUnit.SECONDS,\n            new LinkedBlockingDeque&lt;>(),\n            r -> &#123;\n                Thread thread = new Thread(r);\n                thread.setName(\"disposeRequestThread-\" + threadIndex.getAndIncrement());\n                return thread;\n            &#125;);\n    //记录日志\n    public static void log(String msg, String traceId) &#123;\n        StackTraceElement stack[] = (new Throwable()).getStackTrace();\n        System.out.println(\"****\" + System.currentTimeMillis() + \"[traceId:\" + traceId + \"],[线程:\" + Thread.currentThread().getName() + \"],\" + stack[1] + \":\" + msg);\n    &#125;\n    //模拟controller\n    public static void controller(List&lt;String> dataList, String traceId) &#123;\n        log(\"接受请求\", traceId);\n        service(dataList, traceId);\n    &#125;\n    //模拟service\n    public static void service(List&lt;String> dataList, String traceId) &#123;\n        log(\"执行业务\", traceId);\n        dao(dataList, traceId);\n    &#125;\n    //模拟dao\n    public static void dao(List&lt;String> dataList, String traceId) &#123;\n        log(\"执行数据库操作\", traceId);\n        //模拟插入数据\n        for (String s : dataList) &#123;\n            log(\"插入数据\" + s + \"成功\", traceId);\n        &#125;\n    &#125;\n    public static void main(String[] args) &#123;\n        //需要插入的数据\n        List&lt;String> dataList = new ArrayList&lt;>();\n        for (int i = 0; i &lt; 3; i++) &#123;\n            dataList.add(\"数据\" + i);\n        &#125;\n        //模拟5个请求\n        int requestCount = 5;\n        for (int i = 0; i &lt; requestCount; i++) &#123;\n            String traceId = String.valueOf(i);\n            disposeRequestExecutor.execute(() -> &#123;\n                controller(dataList, traceId);\n            &#125;);\n        &#125;\n        disposeRequestExecutor.shutdown();\n    &#125;\n&#125;\n\n****1565339559773[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.controller(Demo2.java:36):接受请求\n****1565339559773[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.controller(Demo2.java:36):接受请求\n****1565339559773[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo2.controller(Demo2.java:36):接受请求\n****1565339559774[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.service(Demo2.java:42):执行业务\n****1565339559774[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.service(Demo2.java:42):执行业务\n****1565339559774[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.dao(Demo2.java:48):执行数据库操作\n****1565339559774[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo2.service(Demo2.java:42):执行业务\n****1565339559774[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据0成功\n****1565339559774[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.dao(Demo2.java:48):执行数据库操作\n****1565339559774[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据1成功\n****1565339559774[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo2.dao(Demo2.java:48):执行数据库操作\n****1565339559774[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据2成功\n****1565339559774[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据0成功\n****1565339559775[traceId:3],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.controller(Demo2.java:36):接受请求\n****1565339559775[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据0成功\n****1565339559775[traceId:3],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.service(Demo2.java:42):执行业务\n****1565339559775[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据1成功\n****1565339559775[traceId:3],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.dao(Demo2.java:48):执行数据库操作\n****1565339559775[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据1成功\n****1565339559775[traceId:3],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据0成功\n****1565339559775[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据2成功\n****1565339559775[traceId:3],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据1成功\n****1565339559775[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据2成功\n****1565339559775[traceId:3],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据2成功\n****1565339559775[traceId:4],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.controller(Demo2.java:36):接受请求\n****1565339559776[traceId:4],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.service(Demo2.java:42):执行业务\n****1565339559776[traceId:4],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.dao(Demo2.java:48):执行数据库操作\n****1565339559776[traceId:4],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据0成功\n****1565339559776[traceId:4],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据1成功\n****1565339559776[traceId:4],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo2.dao(Demo2.java:51):插入数据数据2成功\n\n上面我们通过修改代码的方式，把问题解决了，但前提是你们的系统都像上面这么简单，功能很少，需要改的代码很少，可以这么去改。但事与愿违，我们的系统一般功能都是比较多的，如果我们都一个个去改，岂不是要疯掉，改代码还涉及到重新测试，风险也不可控。那有什么好办法么？\nThreadLocal\n还是拿上面的问题，我们来分析一下，每个请求都是由一个线程处理的，线程就相当于一个人一样，每个请求相当于一个任务，任务来了，人来处理，处理完毕之后，再处理下一个请求任务。人身上是不是有很多口袋，人刚开始准备处理任务的时候，我们把任务的编号放在处理者的口袋中，然后处理中一路携带者，处理过程中如果需要用到这个编号，直接从口袋中获取就可以了。那么刚好java中线程设计的时候也考虑到了这些问题，Thread对象中就有很多口袋，用来放东西。Thread类中有这么一个变量：\nThreadLocal.ThreadLocalMap threadLocals = null;\n\n如何来操作Thread中的这些口袋呢，java为我们提供了一个类ThreadLocal，ThreadLocal对象用来操作Thread中的某一个口袋，可以向这个口袋中放东西、获取里面的东西、清除里面的东西，这个口袋一次性只能放一个东西，重复放东西会将里面已经存在的东西覆盖掉。\n常用的3个方法：\n//向Thread中某个口袋中放东西\npublic void set(T value);\n//获取这个口袋中目前放的东西\npublic T get();\n//清空这个口袋中放的东西\npublic void remove()\n\n我们使用ThreadLocal来改造一下上面的代码，如下：\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class Demo3 &#123;\n    //创建一个操作Thread中存放请求任务追踪id口袋的对象\n    static ThreadLocal&lt;String> traceIdKD = new ThreadLocal&lt;>();\n    static AtomicInteger threadIndex = new AtomicInteger(1);\n    //创建处理请求的线程池子\n    static ThreadPoolExecutor disposeRequestExecutor = new ThreadPoolExecutor(3,\n            3,\n            60,\n            TimeUnit.SECONDS,\n            new LinkedBlockingDeque&lt;>(),\n            r -> &#123;\n                Thread thread = new Thread(r);\n                thread.setName(\"disposeRequestThread-\" + threadIndex.getAndIncrement());\n                return thread;\n            &#125;);\n    //记录日志\n    public static void log(String msg) &#123;\n        StackTraceElement stack[] = (new Throwable()).getStackTrace();\n        //获取当前线程存放tranceId口袋中的内容\n        String traceId = traceIdKD.get();\n        System.out.println(\"****\" + System.currentTimeMillis() + \"[traceId:\" + traceId + \"],[线程:\" + Thread.currentThread().getName() + \"],\" + stack[1] + \":\" + msg);\n    &#125;\n    //模拟controller\n    public static void controller(List&lt;String> dataList) &#123;\n        log(\"接受请求\");\n        service(dataList);\n    &#125;\n    //模拟service\n    public static void service(List&lt;String> dataList) &#123;\n        log(\"执行业务\");\n        dao(dataList);\n    &#125;\n    //模拟dao\n    public static void dao(List&lt;String> dataList) &#123;\n        log(\"执行数据库操作\");\n        //模拟插入数据\n        for (String s : dataList) &#123;\n            log(\"插入数据\" + s + \"成功\");\n        &#125;\n    &#125;\n    public static void main(String[] args) &#123;\n        //需要插入的数据\n        List&lt;String> dataList = new ArrayList&lt;>();\n        for (int i = 0; i &lt; 3; i++) &#123;\n            dataList.add(\"数据\" + i);\n        &#125;\n        //模拟5个请求\n        int requestCount = 5;\n        for (int i = 0; i &lt; requestCount; i++) &#123;\n            String traceId = String.valueOf(i);\n            disposeRequestExecutor.execute(() -> &#123;\n                //把traceId放入口袋中\n                traceIdKD.set(traceId);\n                try &#123;\n                    controller(dataList);\n                &#125; finally &#123;\n                    //将tranceId从口袋中移除\n                    traceIdKD.remove();\n                &#125;\n            &#125;);\n        &#125;\n        disposeRequestExecutor.shutdown();\n    &#125;\n&#125;\n\n****1565339644214[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo3.controller(Demo3.java:41):接受请求\n****1565339644214[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.controller(Demo3.java:41):接受请求\n****1565339644214[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.controller(Demo3.java:41):接受请求\n****1565339644214[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.service(Demo3.java:47):执行业务\n****1565339644214[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo3.service(Demo3.java:47):执行业务\n****1565339644214[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.dao(Demo3.java:53):执行数据库操作\n****1565339644214[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.service(Demo3.java:47):执行业务\n****1565339644214[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据0成功\n****1565339644214[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.dao(Demo3.java:53):执行数据库操作\n****1565339644214[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo3.dao(Demo3.java:53):执行数据库操作\n****1565339644215[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据0成功\n****1565339644215[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据1成功\n****1565339644215[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据1成功\n****1565339644215[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据0成功\n****1565339644215[traceId:0],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据2成功\n****1565339644215[traceId:2],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据2成功\n****1565339644215[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据1成功\n****1565339644215[traceId:4],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.controller(Demo3.java:41):接受请求\n****1565339644215[traceId:3],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.controller(Demo3.java:41):接受请求\n****1565339644215[traceId:4],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.service(Demo3.java:47):执行业务\n****1565339644215[traceId:1],[线程:disposeRequestThread-2],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据2成功\n****1565339644215[traceId:4],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.dao(Demo3.java:53):执行数据库操作\n****1565339644215[traceId:3],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.service(Demo3.java:47):执行业务\n****1565339644215[traceId:4],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据0成功\n****1565339644215[traceId:3],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.dao(Demo3.java:53):执行数据库操作\n****1565339644215[traceId:4],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据1成功\n****1565339644215[traceId:3],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据0成功\n****1565339644215[traceId:4],[线程:disposeRequestThread-3],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据2成功\n****1565339644215[traceId:3],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据1成功\n****1565339644215[traceId:3],[线程:disposeRequestThread-1],com.itsoku.chat24.Demo3.dao(Demo3.java:56):插入数据数据2成功\n\n可以看出输出和刚才使用traceId参数的方式结果一致，但是却简单了很多。不用去修改controller、service、dao代码了，风险也减少了很多。\n代码中创建了一个ThreadLocal traceIdKD，这个对象用来操作Thread中一个口袋，用这个口袋来存放tranceId。在main方法中通过traceIdKD.set(traceId)方法将traceId放入口袋，log方法中通traceIdKD.get()获取口袋中的traceId，最后任务处理完之后，main中的finally中调用traceIdKD.remove();将口袋中的traceId清除。\nThreadLocal的官方API解释为：\n\n\n\n\n\n\n\n\n\n“该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。”\nInheritableThreadLocal\n继续上面的实例，dao中循环处理dataList的内容，假如dataList处理比较耗时，我们想加快处理速度有什么办法么？大家已经想到了，用多线程并行处理dataList，那么我们把代码改一下，如下：\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class Demo4 &#123;\n    //创建一个操作Thread中存放请求任务追踪id口袋的对象\n    static ThreadLocal&lt;String> traceIdKD = new ThreadLocal&lt;>();\n    static AtomicInteger threadIndex = new AtomicInteger(1);\n    //创建处理请求的线程池子\n    static ThreadPoolExecutor disposeRequestExecutor = new ThreadPoolExecutor(3,\n            3,\n            60,\n            TimeUnit.SECONDS,\n            new LinkedBlockingDeque&lt;>(),\n            r -> &#123;\n                Thread thread = new Thread(r);\n                thread.setName(\"disposeRequestThread-\" + threadIndex.getAndIncrement());\n                return thread;\n            &#125;);\n    //记录日志\n    public static void log(String msg) &#123;\n        StackTraceElement stack[] = (new Throwable()).getStackTrace();\n        //获取当前线程存放tranceId口袋中的内容\n        String traceId = traceIdKD.get();\n        System.out.println(\"****\" + System.currentTimeMillis() + \"[traceId:\" + traceId + \"],[线程:\" + Thread.currentThread().getName() + \"],\" + stack[1] + \":\" + msg);\n    &#125;\n    //模拟controller\n    public static void controller(List&lt;String> dataList) &#123;\n        log(\"接受请求\");\n        service(dataList);\n    &#125;\n    //模拟service\n    public static void service(List&lt;String> dataList) &#123;\n        log(\"执行业务\");\n        dao(dataList);\n    &#125;\n    //模拟dao\n    public static void dao(List&lt;String> dataList) &#123;\n        CountDownLatch countDownLatch = new CountDownLatch(dataList.size());\n        log(\"执行数据库操作\");\n        String threadName = Thread.currentThread().getName();\n        //模拟插入数据\n        for (String s : dataList) &#123;\n            new Thread(() -> &#123;\n                try &#123;\n                    //模拟数据库操作耗时100毫秒\n                    TimeUnit.MILLISECONDS.sleep(100);\n                    log(\"插入数据\" + s + \"成功,主线程：\" + threadName);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125; finally &#123;\n                    countDownLatch.countDown();\n                &#125;\n            &#125;).start();\n        &#125;\n        //等待上面的dataList处理完毕\n        try &#123;\n            countDownLatch.await();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    public static void main(String[] args) &#123;\n        //需要插入的数据\n        List&lt;String> dataList = new ArrayList&lt;>();\n        for (int i = 0; i &lt; 3; i++) &#123;\n            dataList.add(\"数据\" + i);\n        &#125;\n        //模拟5个请求\n        int requestCount = 5;\n        for (int i = 0; i &lt; requestCount; i++) &#123;\n            String traceId = String.valueOf(i);\n            disposeRequestExecutor.execute(() -> &#123;\n                //把traceId放入口袋中\n                traceIdKD.set(traceId);\n                try &#123;\n                    controller(dataList);\n                &#125; finally &#123;\n                    //将tranceId从口袋中移除\n                    traceIdKD.remove();\n                &#125;\n            &#125;);\n        &#125;\n        disposeRequestExecutor.shutdown();\n    &#125;\n&#125;\n\n看一下上面的输出，有些traceId为null，这是为什么呢？这是因为dao中为了提升处理速度，创建了子线程来并行处理，子线程调用log的时候，去自己的存放traceId的口袋中拿去东西，肯定是空的了。\n那有什么办法么？可不可以这样？\n父线程相当于主管，子线程相当于干活的小弟，主管让小弟们干活的时候，将自己兜里面的东西复制一份给小弟们使用，主管兜里面可能有很多牛逼的工具，为了提升小弟们的工作效率，给小弟们都复制一个，丢到小弟们的兜里，然后小弟就可以从自己的兜里拿去这些东西使用了，也可以清空自己兜里面的东西。\nThread对象中有个inheritableThreadLocals变量，代码如下：\nThreadLocal.ThreadLocalMap inheritableThreadLocals = null;\n\ninheritableThreadLocals相当于线程中另外一种兜，这种兜有什么特征呢，当创建子线程的时候，子线程会将父线程这种类型兜的东西全部复制一份放到自己的inheritableThreadLocals兜中，使用InheritableThreadLocal对象可以操作线程中的inheritableThreadLocals兜。\nInheritableThreadLocal常用的方法也有3个：\n//向Thread中某个口袋中放东西\npublic void set(T value);\n//获取这个口袋中目前放的东西\npublic T get();\n//清空这个口袋中放的东西\npublic void remove()\n\n使用InheritableThreadLocal解决上面子线程中无法输出traceId的问题，只需要将上一个示例代码中的ThreadLocal替换成InheritableThreadLocal即可，代码如下：\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n/**\n * 跟着阿里p7学并发，微信公众号：javacode2018\n */\npublic class Demo4 &#123;\n    //创建一个操作Thread中存放请求任务追踪id口袋的对象,子线程可以继承父线程中内容\n    static InheritableThreadLocal&lt;String> traceIdKD = new InheritableThreadLocal&lt;>();\n    static AtomicInteger threadIndex = new AtomicInteger(1);\n    //创建处理请求的线程池子\n    static ThreadPoolExecutor disposeRequestExecutor = new ThreadPoolExecutor(3,\n            3,\n            60,\n            TimeUnit.SECONDS,\n            new LinkedBlockingDeque&lt;>(),\n            r -> &#123;\n                Thread thread = new Thread(r);\n                thread.setName(\"disposeRequestThread-\" + threadIndex.getAndIncrement());\n                return thread;\n            &#125;);\n    //记录日志\n    public static void log(String msg) &#123;\n        StackTraceElement stack[] = (new Throwable()).getStackTrace();\n        //获取当前线程存放tranceId口袋中的内容\n        String traceId = traceIdKD.get();\n        System.out.println(\"****\" + System.currentTimeMillis() + \"[traceId:\" + traceId + \"],[线程:\" + Thread.currentThread().getName() + \"],\" + stack[1] + \":\" + msg);\n    &#125;\n    //模拟controller\n    public static void controller(List&lt;String> dataList) &#123;\n        log(\"接受请求\");\n        service(dataList);\n    &#125;\n    //模拟service\n    public static void service(List&lt;String> dataList) &#123;\n        log(\"执行业务\");\n        dao(dataList);\n    &#125;\n    //模拟dao\n    public static void dao(List&lt;String> dataList) &#123;\n        CountDownLatch countDownLatch = new CountDownLatch(dataList.size());\n        log(\"执行数据库操作\");\n        String threadName = Thread.currentThread().getName();\n        //模拟插入数据\n        for (String s : dataList) &#123;\n            new Thread(() -> &#123;\n                try &#123;\n                    //模拟数据库操作耗时100毫秒\n                    TimeUnit.MILLISECONDS.sleep(100);\n                    log(\"插入数据\" + s + \"成功,主线程：\" + threadName);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125; finally &#123;\n                    countDownLatch.countDown();\n                &#125;\n            &#125;).start();\n        &#125;\n        //等待上面的dataList处理完毕\n        try &#123;\n            countDownLatch.await();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    public static void main(String[] args) &#123;\n        //需要插入的数据\n        List&lt;String> dataList = new ArrayList&lt;>();\n        for (int i = 0; i &lt; 3; i++) &#123;\n            dataList.add(\"数据\" + i);\n        &#125;\n        //模拟5个请求\n        int requestCount = 5;\n        for (int i = 0; i &lt; requestCount; i++) &#123;\n            String traceId = String.valueOf(i);\n            disposeRequestExecutor.execute(() -> &#123;\n                //把traceId放入口袋中\n                traceIdKD.set(traceId);\n                try &#123;\n                    controller(dataList);\n                &#125; finally &#123;\n                    //将tranceId从口袋中移除\n                    traceIdKD.remove();\n                &#125;\n            &#125;);\n        &#125;\n        disposeRequestExecutor.shutdown();\n    &#125;\n&#125;\n\n\n\n十四、Java对象内存布局和对象头1、对象在堆内存中布局\n1、对象在堆内存中的存储布局\n对象内部结构分为：对象头、实例数据、对齐填充（保证8个字节的倍数）。对象头分为对象标记（markOop）和类元信息（klassOop），类元信息存储的是指向该对象类元数据（klass）的首地址。\n2、对象头1、对象标记Mark Word\n\n在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节\n\n​\t\t默认存储对象的HashCode、分代年龄和锁标志位等信息。这些信息都是与对象自身定义无关的数据，所以MarkWord被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间MarkWord里存储的数据会随着锁标志位的变化而变化。\n2、类元信息(又叫类型指针)\n对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\n3、对象头多大在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节。\n3、实例数据存放类的属性(Field)数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。\n4、对齐填充虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐这部分内存按8字节补充对齐。\nhttp://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html\nhttp://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/89fb452b3688/src/share/vm/oops/oop.hpp\n\n_mark字段是mark word，_metadata是类指针klass pointer，对象头（object header）即是由这两个字段组成，这些术语可以参考Hotspot术语表，\n\n2、MarkWord1、oop.hpp\n2、markOop.hpphash： 保存对象的哈希码\nage： 保存对象的分代年龄\nbiased_lock： 偏向锁标识位\nlock： 锁状态标识位\nJavaThread* ：保存持有偏向锁的线程ID\nepoch： 保存偏向时间戳\n\n\nmarkword(64位)分布图，对象布局、GC回收和后面的锁升级就是对象标记MarkWord里面标志位的变化\n\n3、聊聊Object obj &#x3D; new Object()1、JOL证明http://openjdk.java.net/projects/code-tools/jol/\n&lt;!--\n官网：http://openjdk.java.net/projects/code-tools/jol/\n定位：分析对象在JVM的大小和分布\n-->\n&lt;dependency>\n    &lt;groupId>org.openjdk.jol&lt;/groupId>\n    &lt;artifactId>jol-core&lt;/artifactId>\n    &lt;version>0.9&lt;/version>\n&lt;/dependency>\n\npublic class MyObject\n&#123;\n    public static void main(String[] args)&#123;\n        //VM的细节详细情况\n        System.out.println(VM.current().details());\n        //所有的对象分配的字节都是8的整数倍。\n        System.out.println(VM.current().objectAlignment());\n    &#125;\n&#125;\n\n\npublic class JOLDemo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Object o = new Object();\n        System.out.println( ClassLayout.parseInstance(o).toPrintable());\n    &#125;\n&#125;\n\n\n\n\n\nOFFSET\n偏移量，也就是到这个字段位置所占用的byte数\n\n\n\nSIZE\n后面类型的字节大小\n\n\nTYPE\n是Class中定义的类型\n\n\nDESCRIPTION\nDESCRIPTION是类型的描述\n\n\nVALUE\nVALUE是TYPE在内存中的值\n\n\nGC年龄采用4位bit存储，最大为15，例如MaxTenuringThreshold参数默认值就是15\n-XX:MaxTenuringThreshold&#x3D;16\n\n2、默认开启压缩说明java -XX:+PrintCommandLineFlags -version\n\n\n-XX:+UseCompressedClassPointers\n\n\n上述表示开启了类型指针的压缩，以节约空间，假如不加压缩？？？\n手动关闭压缩再看看\n-XX:-UseCompressedClassPointers\n\n\n4、换成其他对象试试\n\n十五、Synchronized与锁升级1、Synchronized 锁优化的背景用锁能够实现数据的安全性，但是会带来性能下降。无锁能够基于线程并行提升程序性能，但是会带来安全性下降。\n\nsynchronized锁：由对象头中的Mark Word根据锁标志位的不同而被复用及锁升级策略\n2、Synchronized的性能变化java5以前，只有Synchronized，这个是操作系统级别的重量级操作，重量级锁，假如锁的竞争比较激烈的话，性能下降\n1、Java5之前，用户态和内核态之间的切换\n​\t\tjava的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。\n​\t\t在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，挂起线程和恢复线程都需要转入内核态去完成，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间，如果同步代码块中内容过于简单，这种切换的时间可能比用户代码执行的时间还长”，时间成本相对较高，这也是为什么早期的synchronized效率低的原因Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁\n2、为什么每一个对象都可以成为一个锁？？？？markOop.hpp\n\n​\t\tMonitor可以理解为一种同步工具，也可理解为一种同步机制，常常被描述为一个Java对象。Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。\n\nMonitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，成本非常高。\nMonitor(监视器锁)\n\nMutex LockMonitor是在jvm底层实现的，底层代码是c++。本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，状态转换需要耗费很多的处理器时间成本非常高。所以synchronized是Java语言中的一个重量级操作。\nMonitor与java对象以及线程是如何关联 ？1.如果一个java对象被某个线程锁住，则该java对象的Mark Word字段中LockWord指向monitor的起始地址2.Monitor的Owner字段会存放拥有相关联对象锁的线程id\nMutex Lock 的切换需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。\n3、java6开始，优化SynchronizedJava 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁\n需要有个逐步升级的过程，别一开始就捅到重量级锁\n3、Synchronized锁种类及升级步骤1、多线程访问情况，3种\n只有一个线程来访问，有且唯一Only One\n有2个线程A、B来交替访问\n竞争激烈，多个线程来访问\n\n2、升级流程synchronized用的锁是存在Java对象头里的Mark Word中锁升级功能主要依赖MarkWord中锁标志位和释放偏向锁标志位\n\n3、无锁public class MyObject\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Object o = new Object();\n\n        System.out.println(\"10进制hash码：\"+o.hashCode());\n        System.out.println(\"16进制hash码：\"+Integer.toHexString(o.hashCode()));\n        System.out.println(\"2进制hash码：\"+Integer.toBinaryString(o.hashCode()));\n\n        System.out.println( ClassLayout.parseInstance(o).toPrintable());\n    &#125;\n&#125;\n\n\n\n4、偏向锁\n当一段同步代码一直被同一个线程多次访问，由于只有一个线程那么该线程在后续访问时便会自动获得锁\n同一个老顾客来访，直接老规矩行方便\n\n\n\n\n\n\n\n\n\n\nHotspot 的作者经过研究发现，大多数情况下：\n多线程的情况下，锁不仅不存在多线程竞争，还存在锁由同一线程多次获得的情况，\n偏向锁就是在这种情况下出现的，它的出现是为了解决只有在一个线程执行同步时提高性能。\n\n通过CAS方式修改markword中的线程ID\n1、偏向锁的持有理论落地：      在实际应用运行过程中发现，“锁总是同一个线程持有，很少发生竞争”，也就是说锁总是被第一个占用他的线程拥有，这个线程就是锁的偏向线程。\n​      那么只需要在锁第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁(后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。而是直接比较对象头里面是否存储了指向当前线程的偏向锁)。如果相等表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了，直到竞争发生才释放锁。以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，如果一致直接进入同步。无需每次加锁解锁都去CAS更新对象头。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。\n​      假如不一致意味着发生了竞争，锁已经不是总是偏向于同一个线程了，这时候可能需要升级变为轻量级锁，才能保证线程间公平竞争锁。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。\n技术实现：        一个synchronized方法被一个线程抢到了锁时，那这个方法所在的对象就会在其所在的Mark Word中将偏向锁修改状态位，同时还会有占用前54位来存储线程指针作为标识。若该线程再次访问同一个synchronized方法时，该线程只需去对象头的Mark Word 中去判断一下是否有偏向锁指向本身的ID，无需再进入 Monitor 去竞争对象了。\n2、细化案例Account对象举例说明偏向锁的操作不用直接捅到操作系统，不涉及用户到内核转换，不必要直接升级为最高级，我们以一个account对象的“对象头”为例，\n\n​\t\t假如有一个线程执行到synchronized代码块的时候，JVM使用CAS操作把线程指针ID记录到Mark Word当中，并修改标偏向标示，标示当前线程就获得该锁。锁对象变成偏向锁（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并不会主动释放偏向锁。\n\n​\t\t这时线程获得了锁，可以执行同步代码块。当该线程第二次到达同步代码块时会判断此时持有锁的线程是否还是自己（持有锁的线程ID也在对象头里），JVM通过account对象的Mark Word判断：当前线程ID还在，说明还持有着这个对象的锁，就可以继续进入临界区工作。由于之前没有释放锁，这里也就不需要重新加锁。 如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。\n​\t\t结论：JVM不用和操作系统协商设置Mutex(争取内核)，它只需要记录下线程ID就标示自己获得了当前锁，不用操作系统接入。上述就是偏向锁：在没有其他线程竞争的时候，一直偏向偏心当前线程，当前线程可以一直执行。\n3、偏向锁JVM命令java -XX:+PrintFlagsInitial |grep BiasedLock*\n\n\n\n* 实际上偏向锁在JDK1.6之后是默认开启的，但是启动时间有延迟，\n* 所以需要添加参数-XX:BiasedLockingStartupDelay&#x3D;0，让其在程序启动时立刻启动。\n*\n* 开启偏向锁：\n* -XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay&#x3D;0\n*\n* 关闭偏向锁：关闭之后程序默认会直接进入------------------------------------------&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   轻量级锁状态。\n* -XX:-UseBiasedLocking\n\n4、Code演示 public class MyObject\n&#123;\n    public static void main(String[] args)\n    &#123;\n        Object o = new Object();\n\n        new Thread(() -> &#123;\n            synchronized (o)&#123;\n                System.out.println(ClassLayout.parseInstance(o).toPrintable());\n            &#125;\n        &#125;,\"t1\").start();\n    &#125;\n&#125;\n\n\n一切默认，演示无效果,因为参数系统默认开启\n\n-XX:+UseBiasedLocking                       # 开启偏向锁(默认)           \n-XX:-UseBiasedLocking                       # 关闭偏向锁\n-XX:BiasedLockingStartupDelay&#x3D;0             # 关闭延迟(演示偏向锁时需要开启)\n\n#参数说明：\n#偏向锁在JDK1.6以上默认开启，开启后程序启动几秒后才会被激活，可以使用JVM参数来关闭延迟 -XX:BiasedLockingStartupDelay&#x3D;0\n \n#如果确定锁通常处于竞争状态则可通过JVM参数 -XX:-UseBiasedLocking 关闭偏向锁，那么默认会进入轻量级锁\n\n\n关闭延时参数，启用该功能\n-XX:BiasedLockingStartupDelay&#x3D;0\n\n\n5、偏向锁的撤销当有另外线程逐步来竞争锁的时候，就不能再使用偏向锁了，要升级为轻量级锁\n竞争线程尝试CAS更新对象头失败，会等待到全局安全点（此时不会执行任何代码）撤销偏向锁。\n\n\n\n\n\n\n\n\n\n偏向锁使用一种等到竞争出现才释放锁的机制，只有当其他线程竞争锁时，持有偏向锁的原来线程才会被撤销。撤销需要等待全局安全点(该时间点上没有字节码正在执行)，同时检查持有偏向锁的线程是否还在执行： \n①  第一个线程正在执行synchronized方法(处于同步块)，它还没有执行完，其它线程来抢夺，该偏向锁会被取消掉并出现锁升级。此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。②  第一个线程执行完成synchronized方法(退出同步块)，则将对象头设置成无锁状态并撤销偏向锁，重新偏向 。\n\n\n5、轻锁有线程来参与锁的竞争，但是获取锁的冲突时间极短\n本质就是自旋锁\n1、轻量级锁的获取轻量级锁是为了在线程近乎交替执行同步块时提高性能。主要目的： 在没有多线程竞争的前提下，通过CAS减少重量级锁使用操作系统互斥量产生的性能消耗，说白了先自旋再阻塞。升级时机： 当关闭偏向锁功能或多线程竞争偏向锁会导致偏向锁升级为轻量级锁\n假如线程A已经拿到锁，这时线程B又来抢该对象的锁，由于该对象的锁已经被线程A拿到，当前该锁已是偏向锁了。而线程B在争抢时发现对象头Mark Word中的线程ID不是线程B自己的线程ID(而是线程A)，那线程B就会进行CAS操作希望能获得锁。此时线程B操作中有两种情况：如果锁获取成功，直接替换Mark Word中的线程ID为B自己的ID(A → B)，重新偏向于其他线程(即将偏向锁交给其他线程，相当于当前线程”被”释放了锁)，该锁会保持偏向锁状态，A线程Over，B线程上位；\n\n​\t\t如果锁获取失败，则偏向锁升级为轻量级锁，此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程B会进入自旋等待获得该轻量级锁。\n\n2、Code演示\n如果关闭偏向锁，就可以直接进入轻量级锁\n-XX:-UseBiasedLocking\n\n3、自旋达到一定次数和程度java6之前\n默认启用，默认情况下自旋的次数是 10 次  -XX:PreBlockSpin&#x3D;10来修改，或者自旋线程数超过cpu核数一半\nJava6之后\n自适应，自适应意味着自旋的次数不是固定不变的\n而是根据：同一个锁上一次自旋的时间，拥有锁线程的状态来决定。\n4、轻量锁与偏向锁的区别和不同争夺轻量级锁失败时，自旋尝试抢占锁\n轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁\n6、重锁有大量的线程参与锁的竞争，冲突性很高\n\n\n7、各种锁优缺点、synchronized锁升级和实现原理\nsynchronized锁升级过程总结：一句话，就是先自旋，不行再阻塞。实际上是把之前的悲观锁(重量级锁)变成在一定条件下使用偏向锁以及使用轻量级(自旋锁CAS)的形式\n​\t\tsynchronized在修饰方法和代码块在字节码上实现方式有很大差异，但是内部实现还是基于对象头的MarkWord来实现的。JDK1.6之前synchronized使用的是重量级锁，JDK1.6之后进行了优化，拥有了无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁的升级过程，而不是无论什么情况都使用重量级锁。\n​\t\t偏向锁:适用于单线程适用的情况，在不存在锁竞争的时候进入同步方法&#x2F;代码块则使用偏向锁。轻量级锁：适用于竞争较不激烈的情况(这和乐观锁的使用范围类似)， 存在竞争时升级为轻量级锁，轻量级锁采用的是自旋锁，如果同步方法&#x2F;代码块执行时间很短的话，采用轻量级锁虽然会占用cpu资源但是相对比使用重量级锁还是更高效。​\t\t重量级锁：适用于竞争激烈的情况，如果同步方法&#x2F;代码块执行时间很长，那么使用轻量级锁自旋带来的性能消耗就比使用重量级锁更严重，这时候就需要升级为重量级锁。\n4、JIT编译器对锁的优化Just In Time Compiler，一般翻译为即时编译器\n1、锁消除/**\n * 锁消除\n * 从JIT角度看相当于无视它，synchronized (o)不存在了,这个锁对象并没有被共用扩散到其它线程使用，\n * 极端的说就是根本没有加这个锁对象的底层机器码，消除了锁的使用\n */\npublic class LockClearUPDemo\n&#123;\n    static Object objectLock = new Object();//正常的\n\n    public void m1()\n    &#123;\n        //锁消除,JIT会无视它，synchronized(对象锁)不存在了。不正常的\n        Object o = new Object();\n\n        synchronized (o)\n        &#123;\n            System.out.println(\"-----hello LockClearUPDemo\"+\"\\t\"+o.hashCode()+\"\\t\"+objectLock.hashCode());\n        &#125;\n    &#125;\n\n    public static void main(String[] args)\n    &#123;\n        LockClearUPDemo demo = new LockClearUPDemo();\n\n        for (int i = 1; i &lt;=10; i++) &#123;\n            new Thread(() -> &#123;\n                demo.m1();\n            &#125;,String.valueOf(i)).start();\n        &#125;\n    &#125;\n&#125;\n\n2、锁粗化/**\n * 锁粗化\n * 假如方法中首尾相接，前后相邻的都是同一个锁对象，那JIT编译器就会把这几个synchronized块合并成一个大块，\n * 加粗加大范围，一次申请锁使用即可，避免次次的申请和释放锁，提升了性能\n */\npublic class LockBigDemo\n&#123;\n    static Object objectLock = new Object();\n\n\n    public static void main(String[] args)\n    &#123;\n        new Thread(() -> &#123;\n            synchronized (objectLock) &#123;\n                System.out.println(\"11111\");\n            &#125;\n            synchronized (objectLock) &#123;\n                System.out.println(\"22222\");\n            &#125;\n            synchronized (objectLock) &#123;\n                System.out.println(\"33333\");\n            &#125;\n        &#125;,\"a\").start();\n\n        new Thread(() -> &#123;\n            synchronized (objectLock) &#123;\n                System.out.println(\"44444\");\n            &#125;\n            synchronized (objectLock) &#123;\n                System.out.println(\"55555\");\n            &#125;\n            synchronized (objectLock) &#123;\n                System.out.println(\"66666\");\n            &#125;\n        &#125;,\"b\").start();\n\n    &#125;\n&#125;\n\n\n\n十六、AbstractQueuedSynchronizer之AQS1、AQS是什么字面意思:抽象的队列同步器\n\nAbstractOwnableSynchronizer\nAbstractQueuedLongSynchronizer\nAbstractQueuedSynchronizer                  \n通常地：AbstractQueuedSynchronizer简称为AQS\n\n技术解释\n​\t\t是用来构建锁或者其它同步器组件的重量级基础框架及整个JUC体系的基石，通过内置的FIFO队列来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态\n\nCLH：Craig、Landin and Hagersten 队列，是一个单向链表，AQS中的队列是CLH变体的虚拟双向队列FIFO\n2、AQS为什么是JUC内容中最重要的基石1、和AQS有关的\n2、ReentrantLock\n3、CountDownLatch\n4、ReentrantReadWriteLock\n5、Semaphore\n6、进一步理解锁和同步器的关系锁，面向锁的使用者 \n定义了程序员和锁交互的使用层API，隐藏了实现细节，你调用即可。\n同步器，面向锁的实现者\n比如Java并发大神DougLee，提出统一规范并简化了锁的实现，屏蔽了同步状态管理、阻塞线程排队和通知、唤醒机制等。\n3、AQS能干嘛加锁会导致阻塞，有阻塞就需要排队，实现排队必然需要队列\n​\t\t抢到资源的线程直接使用处理业务，抢不到资源的必然涉及一种排队等候机制。抢占资源失败的线程继续去等待(类似银行业务办理窗口都满了，暂时没有受理窗口的顾客只能去候客区排队等候)，但等候线程仍然保留获取锁的可能且获取锁流程仍在继续(候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务)。\n既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？\n​\t\t如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS的抽象表现。它将请求共享资源的线程封装成队列的结点（Node），通过CAS、自旋以及LockSupport.park()的方式，维护state变量的状态，使并发达到同步的效果。\n\n4、AQS初步1、官网解释\n有阻塞就需要排队，实现排队必然需要队列\n​\t\tAQS使用一个volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作将每条要去抢占资源的线程封装成一个Node节点来实现锁的分配，通过CAS完成对State值的修改。\n\n2、AQS内部体系架构\n\n1、AQS自身\nAQS的int变量\n\nAQS的同步状态State成员变量\n\n银行办理业务的受理窗口状态\n零就是没人，自由状态可以办理\n大于等于1，有人占用窗口，等着去\n\nAQS的CLH队列\n\nCLH队列(三个大牛的名字组成)，为一个双向队列\n\n小总结\n有阻塞就需要排队，实现排队必然需要队列\nstate变量+CLH双端队列\n2、内部类Node(Node类在AQS类内部)\nNode的int变量\n\nNode的等待状态waitState成员变量\nvolatile int waitStatus\n\n等候区其它顾客(其它线程)的等待状态\n队列中每个排队的个体就是一个 Node\n\nNode此类的讲解\n\n\n\n3、AQS同步队列的基本结构\nCLH：Craig、Landin and Hagersten 队列，是个单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO）\n5、从ReentrantLock开始解读AQSLock接口的实现类，基本都是通过【聚合】了一个【队列同步器】的子类完成线程访问控制的\n1、ReentrantLock的原理\n2、从最简单的lock方法开始看看公平和非公平\n\n\n\n\n\n\n\n\n\n\n\n可以明显看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法\n3、非公平锁 方法lock()对比公平锁和非公平锁的 tryAcquire()方法的实现代码，其实差别就在于非公平锁获取锁时比公平锁中少了一个判断 !hasQueuedPredecessors()\nhasQueuedPredecessors() 中判断了是否需要排队，导致公平锁和非公平锁的差异如下：\n公平锁：公平锁讲究先来先到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入等待队列中；\n非公平锁：不管是否有等待队列，如果可以获取锁，则立刻占有锁对象。也就是说队列的第一个排队线程在unpark()，之后还是需要竞争锁（存在线程竞争的情况下）\n\n4、源码解读1、lock()\n2、acquire()\n\n3、tryAcquire(arg)非公平锁\n\n\nnonfairTryAcquire(acquires)\n\nreturn false; 继续推进条件，走下一个方法\nreturn true; 结束\n4、addWaiter(Node.EXCLUSIVE)addWaiter(Node mode)\n\nenq(node);\n\n双向链表中，第一个节点为虚节点(也叫哨兵节点)，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是从第二个节点开始的。\n假如3号ThreadC线程进来\nprev - compareAndSetTail - next\n5、acquireQueued(addWaiter(Node.EXCLUSIVE), arg)acquireQueued\n\n假如再抢抢失败就会进入\nshouldParkAfterFailedAcquire 和 parkAndCheckInterrupt 方法中\n\nshouldParkAfterFailedAcquire \n\n​\t\t如果前驱节点的 waitStatus 是 SIGNAL状态，即 shouldParkAfterFailedAcquire 方法会返回 true 程序会继续向下执行 parkAndCheckInterrupt 方法，用于将当前线程挂起\nparkAndCheckInterrupt \n\n5、unlocksync.release(1); \ntryRelease(arg)\nunparkSuccessor\n十七、ReentrantLock、ReentrantReadWriteLock、StampedLock1、ReentrantReadWriteLock读写锁定义为：一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程。\n\n1、读写锁意义和特点​\t\t读写锁ReentrantReadWriteLock并不是真正意义上的读写分离，它只允许读读共存，而读写和写写依然是互斥的，大多实际场景是“读&#x2F;读”线程间并不存在互斥关系，只有”读&#x2F;写”线程或”写&#x2F;写”线程间的操作需要互斥的。因此引入ReentrantReadWriteLock。\n​\t\t一个ReentrantReadWriteLock同时只能存在一个写锁但是可以存在多个读锁，但不能同时存在写锁和读锁(切菜还是拍蒜选一个)。也即一个资源可以被多个读操作访问或一个写操作访问，但两者不能同时进行。\n只有在读多写少情境之下，读写锁才具有较高的性能体现。\n2、特点\n可重入\n读写分离\n\npublic class ReentrantReadWriteLockDemo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        MyResource myResource = new MyResource();\n\n        for (int i = 1; i &lt;=10; i++) &#123;\n            int finalI = i;\n            new Thread(() -> &#123;\n                myResource.write(finalI +\"\", finalI +\"\");\n            &#125;,String.valueOf(i)).start();\n        &#125;\n\n        for (int i = 1; i &lt;=10; i++) &#123;\n            int finalI = i;\n            new Thread(() -> &#123;\n                myResource.read(finalI +\"\");\n            &#125;,String.valueOf(i)).start();\n        &#125;\n\n        //暂停几秒钟线程\n        try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        //读全部over才可以继续写\n        for (int i = 1; i &lt;=3; i++) &#123;\n            int finalI = i;\n            new Thread(() -> &#123;\n                myResource.write(finalI +\"\", finalI +\"\");\n            &#125;,\"newWriteThread===\"+String.valueOf(i)).start();\n        &#125;\n    &#125;\n&#125;\n\n3、从写锁→读锁，ReentrantReadWriteLock可以降级《Java 并发编程的艺术》中关于锁降级的说明：\n锁的严苛程度变强叫做升级，反之叫做降级\n\n锁降级：将写入锁降级为读锁(类似Linux文件读写权限理解，就像写权限要高于读权限一样)\n1、读写锁降级演示可以降级\n锁降级：遵循获取写锁→再获取读锁→再释放写锁的次序，写锁能够降级成为读锁。如果一个线程占有了写锁，在不释放写锁的情况下，它还能占有读锁，即写锁降级为读锁。\n\nJava8 官网说明\n\n重入还允许通过获取写入锁定，然后读取锁然后释放写锁从写锁到读取锁, 但是，从读锁定升级到写锁是不可能的。\n锁降级是为了让当前线程感知到数据的变化，目的是保证数据可见性\n/**\n * 锁降级：遵循获取写锁→再获取读锁→再释放写锁的次序，写锁能够降级成为读锁。\n *\n * 如果一个线程占有了写锁，在不释放写锁的情况下，它还能占有读锁，即写锁降级为读锁。\n */\npublic class LockDownGradingDemo\n&#123;\n    public static void main(String[] args)\n    &#123;\n        ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n        ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock();\n        ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock();\n\n\n        writeLock.lock();\n        System.out.println(\"-------正在写入\");\n\n\n        readLock.lock();\n        System.out.println(\"-------正在读取\");\n\n        writeLock.unlock();\n    &#125;\n&#125;\n\n如果有线程在读，那么写线程是无法获取写锁的，是悲观锁的策略\n不可锁升级\n线程获取读锁是不能直接升级为写入锁的。\n\n\n在ReentrantReadWriteLock中，当读锁被使用时，如果有线程尝试获取写锁，该写线程会被阻塞。所以，需要释放所有读锁，才可获取写锁，\n\n2、写锁和读锁是互斥的​\t\t写锁和读锁是互斥的（这里的互斥是指线程间的互斥，当前线程可以获取到写锁又获取到读锁，但是获取到了读锁不能继续获取写锁），这是因为读写锁要保持写操作的可见性。因为，如果允许读锁在被获取的情况下对写锁的获取，那么正在运行的其他读线程无法感知到当前写线程的操作\n​\t\t因此，分析读写锁ReentrantReadWriteLock，会发现它有个潜在的问题：读锁全完，写锁有望；写锁独占，读写全堵；如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，见前面Case《code演示LockDownGradingDemo》即ReadWriteLock读的过程中不允许写，只有等待线程都释放了读锁，当前线程才能获取写锁，也就是写入必须等待，这是一种悲观的读锁，o(╥﹏╥)o，人家还在读着那，你先别去写，省的数据乱。\n​\t\t分析StampedLock(后面详细讲解)，会发现它改进之处在于：读的过程中也允许获取写锁介入(相当牛B，读和写两个操作也让你“共享”(注意引号))，这样会导致我们读的数据就可能不一致！所以，需要额外的方法来判断读的过程中是否有写入，这是一种乐观的读锁，O(∩_∩)O哈哈~。 显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。\n4、读写锁之读写规矩，再说降级锁降级  下面的示例代码摘自ReentrantWriteReadLock源码中：ReentrantWriteReadLock支持锁降级，遵循按照获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁，不支持锁升级。解读在最下面:\n\n\n代码中声明了一个volatile类型的cacheValid变量，保证其可见性。\n\n首先获取读锁，如果cache不可用，则释放读锁，获取写锁，在更改数据之前，再检查一次cacheValid的值，然后修改数据，将cacheValid置为true，然后在释放写锁前获取读锁；此时，cache中数据可用，处理cache中数据，最后释放读锁。这个过程就是一个完整的锁降级的过程，目的是保证数据可见性。\n\n\n\n如果违背锁降级的步骤 \n\n如果当前的线程C在修改完cache中的数据后，没有获取读锁而是直接释放了写锁，那么假设此时另一个线程D获取了写锁并修改了数据，那么C线程无法感知到数据已被修改，则数据出现错误。\n\n\n如果遵循锁降级的步骤 \n\n线程C在释放写锁之前获取读锁，那么线程D在获取写锁时将被阻塞，直到线程C完成数据处理过程，释放读锁。这样可以保证返回的数据是这次更新的数据，该机制是专门为了缓存设计的。\n\n\n\n2、邮戳锁StampedLock无锁→独占锁→读写锁→邮戳锁\n1、StampedLock是什么StampedLock是JDK1.8中新增的一个读写锁，也是对JDK1.5中的读写锁ReentrantReadWriteLock的优化。\n邮戳锁 - 也叫票据锁\n\n\n\n\n\n\n\n\n\n stamp（戳记，long类型）\n代表了锁的状态。当stamp返回零时，表示线程获取锁失败。并且，当释放锁或者转换锁的时候，都要传入最初获取的stamp值。\n2、它是由锁饥饿问题引出​\t\tReentrantReadWriteLock实现了读写分离，但是一旦读操作比较多的时候，想要获取写锁就变得比较困难了，假如当前1000个线程，999个读，1个写，有可能999个读取线程长时间抢到了锁，那1个写线程就悲剧了 因为当前有可能会一直存在读锁，而无法获得写锁，根本没机会写，\n1、如何缓解锁饥饿问题？使用“公平”策略可以一定程度上缓解这个问题\nnew ReentrantReadWriteLock(true);\n\n但是“公平”策略是以牺牲系统吞吐量为代价的\nStampedLock类的乐观读锁闪亮登场\nReentrantReadWriteLock\n允许多个线程同时读，但是只允许一个线程写，在线程获取到写锁的时候，其他写操作和读操作都会处于阻塞状态，\n读锁和写锁也是互斥的，所以在读的时候是不允许写的，读写锁比传统的synchronized速度要快很多，\n原因就是在于ReentrantReadWriteLock支持读并发\n\nStampedLock横空出世\nReentrantReadWriteLock的读锁被占用的时候，其他线程尝试获取写锁的时候会被阻塞。\n但是，StampedLock采取乐观获取锁后，其他线程尝试获取写锁时不会被阻塞，这其实是对读锁的优化，\n所以，在获取乐观读锁后，还需要对结果进行校验。\n\n3、StampedLock的特点\n所有获取锁的方法，都返回一个邮戳（Stamp），Stamp为零表示获取失败，其余都表示成功；\n所有释放锁的方法，都需要一个邮戳（Stamp），这个Stamp必须是和成功获取锁时得到的Stamp一致；\nStampedLock是不可重入的，危险(如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁)\n\n1、StampedLock有三种访问模式\nReading（读模式）：功能和ReentrantReadWriteLock的读锁类似\n\nWriting（写模式）：功能和ReentrantReadWriteLock的写锁类似\n\nOptimistic reading（乐观读模式）：无锁机制，类似于数据库中的乐观锁，支持读写并发，很乐观认为读取时没人修改，假如被修改再实现升级为悲观读模式\n\n\n2、乐观读模式code演示public class StampedLockDemo\n&#123;\n    static int number = 37;\n    static StampedLock stampedLock = new StampedLock();\n\n    public void write()\n    &#123;\n        long stamp = stampedLock.writeLock();\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\"=====写线程准备修改\");\n        try\n        &#123;\n            number = number + 13;\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;finally &#123;\n            stampedLock.unlockWrite(stamp);\n        &#125;\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\"=====写线程结束修改\");\n    &#125;\n\n    //悲观读\n    public void read()\n    &#123;\n        long stamp = stampedLock.readLock();\n        System.out.println(Thread.currentThread().getName()+\"\\t come in readlock block,4 seconds continue...\");\n        //暂停几秒钟线程\n        for (int i = 0; i &lt;4 ; i++) &#123;\n            try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            System.out.println(Thread.currentThread().getName()+\"\\t 正在读取中......\");\n        &#125;\n        try\n        &#123;\n            int result = number;\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\" 获得成员变量值result：\" + result);\n            System.out.println(\"写线程没有修改值，因为 stampedLock.readLock()读的时候，不可以写，读写互斥\");\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;finally &#123;\n            stampedLock.unlockRead(stamp);\n        &#125;\n    &#125;\n\n    //乐观读\n    public void tryOptimisticRead()\n    &#123;\n        long stamp = stampedLock.tryOptimisticRead();\n        int result = number;\n        //间隔4秒钟，我们很乐观的认为没有其他线程修改过number值，实际靠判断。\n        System.out.println(\"4秒前stampedLock.validate值(true无修改，false有修改)\"+\"\\t\"+stampedLock.validate(stamp));\n        for (int i = 1; i &lt;=4 ; i++) &#123;\n            try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n            System.out.println(Thread.currentThread().getName()+\"\\t 正在读取中......\"+i+\n                    \"秒后stampedLock.validate值(true无修改，false有修改)\"+\"\\t\"\n                    +stampedLock.validate(stamp));\n        &#125;\n        if(!stampedLock.validate(stamp)) &#123;\n            System.out.println(\"有人动过--------存在写操作！\");\n            stamp = stampedLock.readLock();\n            try &#123;\n                System.out.println(\"从乐观读 升级为 悲观读\");\n                result = number;\n                System.out.println(\"重新悲观读锁通过获取到的成员变量值result：\" + result);\n            &#125;catch (Exception e)&#123;\n                e.printStackTrace();\n            &#125;finally &#123;\n                stampedLock.unlockRead(stamp);\n            &#125;\n        &#125;\n        System.out.println(Thread.currentThread().getName()+\"\\t finally value: \"+result);\n    &#125;\n\n    public static void main(String[] args)\n    &#123;\n        StampedLockDemo resource = new StampedLockDemo();\n\n        new Thread(() -> &#123;\n            resource.read();\n            //resource.tryOptimisticRead();\n        &#125;,\"readThread\").start();\n\n        // 2秒钟时乐观读失败，6秒钟乐观读取成功resource.tryOptimisticRead();，修改切换演示\n        //try &#123; TimeUnit.SECONDS.sleep(6); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n\n        new Thread(() -> &#123;\n            resource.write();\n        &#125;,\"writeThread\").start();\n    &#125;\n&#125;\n\n读的过程中也允许获取写锁介入\n4、StampedLock的缺点\nStampedLock 不支持重入，没有Re开头\nStampedLock 的悲观读锁和写锁都不支持条件变量（Condition），这个也需要注意。\n使用 StampedLock一定不要调用中断操作，即不要调用interrupt() 方法\n如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly()和写锁writeLockInterruptibly()\n\n\n\n附：我的博客\n","slug":"JUC并发编程","date":"2022-06-21T01:15:45.935Z","categories_index":"JUC","tags_index":"JAVA,JUC","author_index":"JIACHEN"},{"id":"1cac424653694fd0abd1397c14df4e06","title":"leetcode","content":"\n利用 x ^ 1s &#x3D; ~x 的特点，可以将位级表示翻转；利用 x ^ x &#x3D; 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。\n\n利用 x &amp; 0s &#x3D; 0 和 x &amp; 1s &#x3D; x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。\n\n利用 x | 0s &#x3D; x 和 x | 1s &#x3D; 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。\n\n&gt;&gt; n 为算术右移，相当于除以 2n；\n\n&gt;&gt;&gt; n 为无符号右移，左边会补上 0。\n\n&lt;&lt; n 为算术左移，相当于乘以 2n\n\n\n位与运算技巧：\n\nn&amp;(n-1) 去除 n 的位级表示中最低的那一位1。例如对于二进制表示 10110100，减去 1 得到 10110011，这两个数相与得到 10110000。\nn&amp;(-n) 得到 n 的位级表示中最低的那一位。-n 得到 n 的反码加 1，对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。\nn-n&amp;(~n+1) 去除 n 的位级表示中最高的那一位。\n\nmask 计算要获取 111111111，将 0 取反即可，~0。\n要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1&lt;&lt;(i-1) 。例如 1&lt;&lt;4 得到只有第 5 位为 1 的 mask ：00010000。\n要得到 1 到 i 位为 1 的 mask，1&lt;&lt;(i+1)-1 即可，例如将 1&lt;&lt;(4+1)-1 &#x3D; 00010000-1 &#x3D; 00001111。\n要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~(1&lt;&lt;(i+1)-1)。\n\nn&amp;1：与操作，判断 n 二进制最右一位是否为 1 。\nn&gt;&gt;1：移位操作，删除n二进制的最右一位。\nn&amp;(1&lt;&lt;i)是将左移i位的1与n进行按位与，即为保留n的第i位，其余位置零\n常用if(n&amp;(1&lt;&lt;i)&#x3D;&#x3D;0)用于判断n的第i位是否为0\nlist.stream().mapToInt(Integer::intValue).toArray();list.stream().mapToInt(Integer::intValue).toArray();\n\n\n\n\n\n","slug":"leetcode","date":"2022-05-14T12:18:53.462Z","categories_index":"leetcode","tags_index":"JAVA,leetcode","author_index":"JIACHEN"},{"id":"40b3365667227c08f3dff034fab7af35","title":"面试Hot100","content":"\n\nJDK JRE JVM的区别\n\n2 java 异常类\n   Throwable\n  &#x2F;                     \\\nExecption      Error\n\nruntime –&gt; try catch\n\nfinal 关键字\n\n\n\n\n\n\n\n4 list set区别\n\n5 HashMap的扩容机制原理\n数组+链表1.7\n数组+链表+红黑树1.8\n\n6 HashMap 和 HashTable的区别以及底层实现 比较old了\n方法都差不多  线程安全&#x2F;不安全\nHashTable 都加上了 sychronized\n效率太低了 所以用了currentHashMap\n\n数组扩容\n​     长度超过了就new一个数组   老的放进新的里边来 \n7 String StringBuilder StringBuffer 的区别 以及使用场景\n\n8 JDK 1.7 1.8虚拟机的区别\n\n9 ArrayList和 LinkedList的区别  阿里一面\n\n10 CurrentHashMap怎么保证线程安全 阿里二面\n相当于是HashMap的多线程版本，它的功能本质上和HashMap没什么区别。因为HashMap在并发操作的时候会出现各种问题，比如死循环问题、数据覆盖等问题。而这些问题，只要使用ConcurrentHashMap就可以完美地解决。\n底层结构：JDK1.8以后采用了数组 加 链表 加 红黑树的方式优化了ConcurrentHashMap的实现，具体实现如图所示。\n\n当链表长度大于8，并且数组长度大于64时，链表就会升级为红黑树的结构。JDK 1.8中的ConcurrentHashMap虽然保留了Segment的定义，但这，仅仅是为了保证序列化时的兼容性，不再有任何结构上的用处了。\n\n\n\n\n\n\nJVM \n11 GC是如何判断对象可以被回收的\njava 可达性分析法\n \n\n12 java类加载器\n\n13 JVM那些可以作为gc root\n\n14 JVM中那些为线程共享区域\n方法区 和 堆区\n\n15 排查JVM问题 阿里一面\n如出现oom\n\n16 JAVA内存结构 队分为哪几部分  默认年龄多大进入老年代  蚂蚁二面\n\n17 什么是字节码 使用字节码的好处是什么\njavac   .class字节码文件  \n\n18类加载器 双亲委派模型\n\n19 JVM内存模型\n\n\n20 JVM调优\n\n主要是通过定制JVM运行参数 来提高JAVA的应用程度的运行数据\nJVM参数大致分为三类\n1 标注指令 -开头  所有的hotspot都支持的参数  java -help打印出来\n2 非标注指令 -x开头 通常根特定的hotspot版本对应的 可以用java -x打印出来\n3 不稳定参数 -XX开头 跟特定的hotspot版本对应的 变化非常大  JDK1.8版本下常用的 \n\njvm参数 阿里的ARTHAS  \t指令：dashboard\nGC\n\n\n21 Spring 单例池 作用\n底层是Map 《beanname bean对象》   这个map就叫单例池\n\n22Bean对象和普通对象的区别\n同一个 但出于不同时期\n23 PostConstract\n","slug":"top100","date":"2022-05-14T12:18:53.408Z","categories_index":"JAVA","tags_index":"JAVA,面试","author_index":"JIACHEN"},{"id":"8c8767142f7e95355e375b07bd636def","title":"MYSQL优化面试","content":"MySQL架构流程\n\n经历了四层\n1 Connector JDBC odbc\n2 Server (Query Cache &#x2F; Buffer, Parser, Optimizer…)\n3 Storage (InnoDB MyISAM Memory)\n4File (Row Data, Redo Undo Binlog …)放在.frm .ibd\nQueryCache 不好用 已弃用\n以字符串的形式匹配 命中率低 数据更新时会大量失效\n替代： Buffer Pool\n解析器： Parser\n\n此语法解析 形成语法树\n优化器：Optimizer  优化性能更好一点  走哪一个索引优化 \n还有哪些优化 子查询 条件查询优化 连接查询 内连接外连接 语义优化\n基于成本（cost）默认是关闭的 set optimizer-_trace &#x3D; on 再查询数据然后系统表OPTIMIZER_TRACE 记录详细的过程和计划：1 join prepration 2 join optimizer （cost）3 join-execution\nExecute plan \nExecutor: - 》Storage InnoDB –&gt;DBfile \n\n\nMySQL的架构核心模块\n\n16k 的一个page  16384个字节\nInnoDB只有Redo log Undo log没有binlog 它在server层\nInnoDB三大特性：\n1.Adaptive hash index  自适应哈希索引（条件：等值查询）\nshow engine innodb status 查看hashtable的命中情况\n发现频繁查询  1s3次等值查询 ，走的二级索引。认为是一个热点数据 创建自适应哈希索引。\nshow variables like “%innodb_adaptive_hash%”\n2.Buffer Pool : 操作系统 块4 预读取3块 MySQL  pagesize 16K\n传统内存的分配设置是FIFO LRU淘汰机制\n不足：1.出现预读取失效  2.缓冲区污染  \n解决：JVM 新生代 旧生代 \nshow variables like “%innodb_old%”\nMySQL的设计 分成New Old : innodb_old_blocks_pct:37% \n占比 37% 停留时间 1000ms\n\n3.Double Write Buffer:  双写缓存\n存在的原因：Redo log重做可能会存在脏页 部分页失败的情况 无法重做\n一份在共享表空间2M  .  第一次是在redo prepare 第二次 事务提交更新db文件的时候。\n\n\n三大日志\n1：Redo log ：重做  二阶段提交 刷脏  然后记录\n二阶段提交：一开始是准备状态 prepare 另外一个状态commit\nbinlog –&gt;标记Redo commit\nPrepare . Commit \n为什么要有：不在一层 binlog在server层 redo log在innodb层\n如果第一阶段redo 还没来得及写binlog 中断了 bin无法完成同步\n2：Undo log：回滚  优先记录\n3：Binary log:  二进制 不在innoDB 它在server层\nUpdate流程： update name &#x3D; ‘a’ where name &#x3D; ‘b’\n\n开启事务\n查询流程一样，查询到数据之后更新BufferPool Change Buffer Logger Buffer \n记录 Undo log  name&#x3D; ‘b’\n修改 name &#x3D; ‘a’\n记录Redo name&#x3D;’a’ prepare  Double Write 第一次\n到server层记录binlog 发起线程 标记 redo log cmmit\n事务提交 DB更新\nDouble Write 第二次\n\n\n\n\n数据量还是很大：\n                      分库分表: 垂直 按业务划分 \n\n​\t\t\t\t\t\t水平垂直分库 ：按量拆分\nMyCat Sharding-JDBC  雪花\n抗住各种压力SQL本身慢怎么办？优化SQL\n","slug":"SQL","date":"2022-05-14T12:18:53.378Z","categories_index":"JAVA","tags_index":"JAVA,MYSQL","author_index":"JIACHEN"},{"id":"f72a446695f43ddb1d8bfbabff078e31","title":"Nginx 的学习手册","content":"\nNginx 是一个高性能的 HTTP 和反向代理服务器，特点是占用内存少，并发能力强，事实上 Nginx 的并发能力确实在同类型的网页服务器中表现较好。\nNginx 专为性能优化而开发，性能是其最重要的要求，十分注重效率，有报告 Nginx 能支持高达 50000 个并发连接数。\n01\nNginx 知识网结构图\nNginx 的知识网结构图如下：\n\n02****反向代理\n正向代理：局域网中的电脑用户想要直接访问网络是不可行的，只能通过代理服务器来访问，这种代理服务就被称为正向代理。\n\n反向代理：客户端无法感知代理，因为客户端访问网络不需要配置，只要把请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据，然后再返回到客户端。\n此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。\n\n03\n负载均衡\n客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕之后，再将结果返回给客户端。\n普通请求和响应过程如下图：\n\n但是随着信息数量增长，访问量和数据量飞速增长，普通架构无法满足现在的需求。\n我们首先想到的是升级服务器配置，可以由于摩尔定律的日益失效，单纯从硬件提升性能已经逐渐不可取了，怎么解决这种需求呢？\n我们可以增加服务器的数量，构建集群，将请求分发到各个服务器上，将原来请求集中到单个服务器的情况改为请求分发到多个服务器，也就是我们说的负载均衡。\n图解负载均衡：\n\n假设有 15 个请求发送到代理服务器，那么由代理服务器根据服务器数量，平均分配，每个服务器处理 5 个请求，这个过程就叫做负载均衡。\n04****动静分离\n为了加快网站的解析速度，可以把动态页面和静态页面交给不同的服务器来解析，加快解析的速度，降低由单个服务器的压力。\n动静分离之前的状态：\n\n动静分离之后：\n\n05****Nginx安装\nNginx 如何在 Linux 安装\n参考链接：\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;yujing1314&#x2F;article&#x2F;details&#x2F;97267369\n\nNginx 常用命令\n查看版本：\n.&#x2F;nginx -v\n\n\n\n启动：\n.&#x2F;nginx\n\n\n\n关闭（有两种方式，推荐使用 .&#x2F;nginx -s quit）：\n.&#x2F;nginx -s stop\n.&#x2F;nginx -s quit\n\n\n\n重新加载 Nginx 配置：\n.&#x2F;nginx -s reload\n\n\n\nNginx 的配置文件\n配置文件分三部分组成：\n①全局块从配置文件开始到 events 块之间，主要是设置一些影响 Nginx 服务器整体运行的配置指令。\n并发处理服务的配置，值越大，可以支持的并发处理量越多，但是会受到硬件、软件等设备的制约。\n\n②events 块影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 workprocess 下的网络连接进行序列化，是否允许同时接收多个网络连接等等。\n支持的最大连接数：\n\n③HTTP 块诸如反向代理和负载均衡都在此配置。\nlocation[ &#x3D; | ~ | ~* | ^~] url&#123;\n\n&#125;\n\n\n\nlocation 指令说明，该语法用来匹配 url，语法如上：\n\n&#x3D;：用于不含正则表达式的 url 前，要求字符串与 url 严格匹配，匹配成功就停止向下搜索并处理请求。\n~：用于表示 url 包含正则表达式，并且区分大小写。\n~*：用于表示 url 包含正则表达式，并且不区分大小写。\n^~：用于不含正则表达式的 url 前，要求 Nginx 服务器找到表示 url 和字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再匹配。\n如果有 url 包含正则表达式，不需要有 ~ 开头标识。\n\n06****反向代理实战\n①配置反向代理目的：在浏览器地址栏输入地址 www.123.com 跳转 Linux 系统 Tomcat 主页面。\n②具体实现\n先配置 Tomcat，因为比较简单，此处不再赘叙，并在 Windows 访问：\n\n具体流程如下图：\n\n修改之前：\n\n配置如下：\n\n再次访问：\n\n③反向代理 2\n目标：\n\n访问 http://192.168.25.132:9001/edu/ 直接跳转到 192.168.25.132:8080\n访问 http://192.168.25.132:9001/vod/ 直接跳转到 192.168.25.132:8081\n\n准备：配置两个 Tomcat，端口分别为 8080 和 8081，都可以访问，端口修改配置文件即可。\n\n\n新建文件内容分别添加 8080！！！和 8081！！！\n\n响应如下图：\n\n具体配置如下：\n\n重新加载 Nginx：\n.&#x2F;nginx -s reload\n\n\n\n\n\n访问：\n\n实现了同一个端口代理，通过 edu 和 vod 路径的切换显示不同的页面。\n反向代理小结\n第一个例子：浏览器访问 www.123.com，由 host 文件解析出服务器 ip 地址192.168.25.132 www.123.com。\n然后默认访问 80 端口，而通过 Nginx 监听 80 端口代理到本地的 8080 端口上，从而实现了访问 www.123.com，最终转发到 tomcat 8080 上去。\n第二个例子：\n\n访问 http://192.168.25.132:9001/edu/ 直接跳转到 192.168.25.132:8080\n访问 http://192.168.25.132:9001/vod/ 直接跳转到 192.168.25.132:8081\n\n实际上就是通过 Nginx 监听 9001 端口，然后通过正则表达式选择转发到 8080 还是 8081 的 Tomcat 上去。\n07\n负载均衡实战\n①修改 nginx.conf，如下图：\n\n②重启 Nginx：\n.&#x2F;nginx -s reload\n\n\n\n③在 8081 的 Tomcat 的 webapps 文件夹下新建 edu 文件夹和 a.html 文件，填写内容为 8081！！！！\n④在地址栏回车，就会分发到不同的 Tomcat 服务器上：\n\n负载均衡方式如下：\n\n轮询（默认）。\nweight，代表权，权越高优先级越高。\nfair，按后端服务器的响应时间来分配请求，相应时间短的优先分配。\nip_hash，每个请求按照访问 ip 的 hash 结果分配，这样每一个访客固定的访问一个后端服务器，可以解决 Session 的问题。\n\n\n08****动静分离实战什么是动静分离？把动态请求和静态请求分开，不是讲动态页面和静态页面物理分离，可以理解为 Nginx 处理静态页面，Tomcat 处理动态页面。动静分离大致分为两种：\n\n纯粹将静态文件独立成单独域名放在独立的服务器上，也是目前主流方案。\n将动态跟静态文件混合在一起发布，通过 Nginx 分开。\n\n动静分离图析：\n实战准备，准备静态文件：\n\n配置 Nginx，如下图：\n\nNginx 高可用\n如果 Nginx 出现问题：\n\n解决办法：\n\n前期准备：\n\n两台 Nginx 服务器\n安装 Keepalived\n虚拟 ip\n\n安装 Keepalived：[root@192 usr]# yum install keepalived -y\n[root@192 usr]# rpm -q -a keepalived\nkeepalived-1.3.5-16.el7.x86_64\n\n\n\n修改配置文件：\n[root@192 keepalived]# cd &#x2F;etc&#x2F;keepalived\n[root@192 keepalived]# vi keepalived.conf\n\n\n\n分别将如下配置文件复制粘贴，覆盖掉 keepalived.conf，虚拟 ip 为 192.168.25.50。\n对应主机 ip 需要修改的是：\n\nsmtp_server 192.168.25.147（主）smtp_server 192.168.25.147（备）\nstate MASTER（主） state BACKUP（备）\n\nglobal_defs &#123;\n   notification_email &#123;\n     acassen@firewall.loc\n     failover@firewall.loc\n     sysadmin@firewall.loc\n   &#125;\n   notification_email_from Alexandre.Cassen@firewall.loc\n   smtp_server 192.168.25.147\n   smtp_connect_timeout 30\n   router_id LVS_DEVEL # 访问的主机地址\n&#125;\n\nvrrp_script chk_nginx &#123;\n  script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot;  # 检测文件的地址\n  interval 2   # 检测脚本执行的间隔\n  weight 2   # 权重\n&#125;\n\nvrrp_instance VI_1 &#123;\n    state BACKUP    # 主机MASTER、备机BACKUP    \n    interface ens33   # 网卡\n    virtual_router_id 51 # 同一组需一致\n    priority 90  # 访问优先级，主机值较大，备机较小\n    advert_int 1\n    authentication &#123;\n        auth_type PASS\n        auth_pass 1111\n    &#125;\n    virtual_ipaddress &#123;\n        192.168.25.50  # 虚拟ip\n    &#125;\n&#125;\n\n\n\n启动代码如下：\n[root@192 sbin]# systemctl start keepalived.service\n\n\n\n\n\n访问虚拟 ip 成功：\n\n关闭主机 147 的 Nginx 和 Keepalived，发现仍然可以访问。\n原理解析\n\n如下图，就是启动了一个 master，一个 worker，master 是管理员，worker是具体工作的进程。\n\nworker 如何工作？如下图：\n\n小结\nworker 数应该和 CPU 数相等；一个 master 多个 worker 可以使用热部署，同时 worker 是独立的，一个挂了不会影响其他的。\n","slug":"nginx","date":"2022-05-08T07:14:34.191Z","categories_index":"JAVA","tags_index":"JAVA,Nginx","author_index":"JIACHEN"},{"id":"f10986d12ebf2b7b240f2a2d5f137570","title":"Spring Cloud 学习笔记（1 / 3）","content":"零基础微服务架构理论入门什么是微服务In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.——James Lewis and Martin Fowler (2014)\n微服务是一种架构风格一个应用拆分为一组小型服务每个服务运行在自己的进程内，也就是可独立部署和升级服务之间使用轻量级HTTP交互服务围绕业务功能拆分可以由全自动部署机制独立部署去中心化，服务自治。服务可以使用不同的语言、不同的存储技术主题词01：现代数字化生活-落地维度\n手机PC智能家居…主题词02：分布式微服务架构-落地维度\n满足哪些维度？支撑起这些维度的具体技术？\n服务调用服务降级服务注册与发先服务熔断负载均衡服务消息队列服务网关配置中心管理自动化构建部署服务监控全链路追踪服务定时任务调度操作\nSpring Cloud简介是什么？符合微服务技术维度\nSpringCloud&#x3D;分布式微服务架构的站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶\n猜猜SpringCloud这个大集合里有多少种技术?\nSpringCloud俨然已成为微服务开发的主流技术栈，在国内开发者社区非常火爆。\n“微”力十足，互联网大厂微服务架构案例\n京东的：\n阿里的：\n京东物流的：\nSpring Cloud技术栈\n总结\n03_第二季Boot和Cloud版本选型Spring Boot 2.X 版\n源码地址Spring Boot 2 的新特性通过上面官网发现，Boot官方强烈建议你升级到2.X以上版本Spring Cloud H版\n源码地址官网Spring Boot 与 Spring Cloud 兼容性查看\n文档JSON接口接下来开发用到的组件版本\nCloud - Hoxton.SR1Boot - 2.2.2.RELEASECloud Alibaba - 2.1.0.RELEASEJava - Java 8Maven - 3.5及以上MySQL - 5.7及以上04_Cloud组件停更说明停更引发的“升级惨案”\n停更不停用被动修复bugs不再接受合并请求不再发布新版本Cloud升级\n服务注册中心\n× Eureka√ Zookeeper√ Consul√ Nacos服务调用\n√ Ribbon√ LoadBalancer服务调用2\n× Feign√ OpenFeign服务降级\n× Hystrix√ resilience4j√ sentienl服务网关\n× Zuul! Zuul2√ gateway服务配置\n× Config√ Nacos服务总线\n× Bus√ NacosSpring Cloud官方文档\nSpring Cloud中文文档\nSpring Boot官方文档\n05_父工程Project空间新建约定 &gt; 配置 &gt; 编码\n创建微服务cloud整体聚合父工程Project，有8个关键步骤：\nNew Project - maven工程 - create from archetype: maven-archetype-site聚合总父工程名字Maven选版本工程名字字符编码 - Settings - File encoding注解生效激活 - Settings - Annotation ProcessorsJava编译版本选8File Type过滤 - Settings - File Typearchetype 英 [ˈɑːkitaɪp] 美 [ˈɑːrkitaɪp]n. 典型\nsite 英 [saɪt] 美 [saɪt]n. (建筑物、城镇等的)地点，位置，建筑工地;现场;发生地;场所;网站;站点v. 使坐落在;为…选址\n06_父工程pom文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;          xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  \n&lt;groupId&gt;com.lun&lt;/groupId&gt;\n&lt;artifactId&gt;LearnCloud&lt;/artifactId&gt;\n&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n&lt;packaging&gt;pom&lt;/packaging&gt;&lt;!-- 这里添加，注意不是jar或war --&gt;\n\n&lt;!-- 统一管理jar包版本 --&gt;\n&lt;properties&gt;\n    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;\n    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;\n    &lt;junit.version&gt;4.12&lt;/junit.version&gt;\n    &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;\n    &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt;\n    &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt;\n    &lt;druid.version&gt;1.1.16&lt;/druid.version&gt;\n    &lt;mybatis.spring.boot.version&gt;1.3.0&lt;/mybatis.spring.boot.version&gt;\n&lt;/properties&gt;\n\n&lt;!-- 子模块继承之后，提供作用：\n    锁定版本+子modlue不用写groupId和version --&gt;\n&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;!--spring boot 2.2.2--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!--spring cloud Hoxton.SR1--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;Hoxton.SR1&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n            &lt;artifactId&gt;druid&lt;/artifactId&gt;\n            &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;$&#123;mybatis.spring.boot.version&#125;&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;/groupId&gt;\n            &lt;artifactId&gt;junit&lt;/artifactId&gt;\n            &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;log4j&lt;/groupId&gt;\n            &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n            &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n\n&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;configuration&gt;\n                &lt;fork&gt;true&lt;/fork&gt;\n                &lt;addResources&gt;true&lt;/addResources&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;\n&lt;/project&gt;\n\n07_复习DependencyManagement和DependenciesMaven使用dependencyManagement元素来提供了一种管理依赖版本号的方式。\n通常会在一个组织或者项目的最顶层的父POM中看到dependencyManagement元素。\n使用pom.xml中的dependencyManagement元素能让所有在子项目中引用个依赖而不用显式的列出版本量。\nMaven会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用这个dependencyManagement元素中指定的版本号。\n&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;        &lt;groupId&gt;mysq1&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.2&lt;/version&gt;        &lt;/dependency&gt;    &lt;dependencies&gt;&lt;/dependencyManagement&gt;\n然后在子项目里就可以添加mysql-connector时可以不指定版本号，例如：\n&lt;dependencies&gt;    &lt;dependency&gt;    &lt;groupId&gt;mysq1&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n这样做的好处就是：如果有多个子项目都引用同一样依赖，则可以避免在每个使用的子项目里都声明一个版本号，这样当想升级或切换到另一个版本时，只需要在顶层父容器里更新，而不需要一个一个子项目的修改；另外如果某个子项目需要另外的一个版本，只需要声明version就可。\ndependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项,并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom。如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。IDEA右侧旁的Maven插件有Toggle ‘ Skip Tests’ Mode按钮，这样maven可以跳过单元测试\n父工程创建完成执行mvn : install将父工程发布到仓库方便子工程继承。\n08_支付模块构建(上)创建微服务模块套路：\n建Module改POM写YML主启动业务类客户端消费者80order微服务提供者8001payment创建cloud-provider-payment8001微服务提供者支付Module模块：\n1.建名为cloud-provider-payment8001的Maven工程\n2.改POM\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;          xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;LearnCloud&lt;/artifactId&gt;        &lt;groupId&gt;com.lun&lt;/groupId&gt;        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n&lt;artifactId>cloud-provider-payment8001&lt;/artifactId>\n\n&lt;dependencies>\n    &lt;!--包含了sleuth+zipkin-->\n    &lt;dependency>\n        &lt;groupId>org.springframework.cloud&lt;/groupId>\n        &lt;artifactId>spring-cloud-starter-zipkin&lt;/artifactId>\n    &lt;/dependency>\n    &lt;!--eureka-client-->\n    &lt;dependency>\n        &lt;groupId>org.springframework.cloud&lt;/groupId>\n        &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId>\n    &lt;/dependency>\n        &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->\n    &lt;!--\n    &lt;dependency>\n        &lt;groupId>com.atguigu.springcloud&lt;/groupId>\n        &lt;artifactId>cloud-api-commons&lt;/artifactId>\n        &lt;version>$&#123;project.version&#125;&lt;/version>\n    &lt;/dependency>\n    -->\n    &lt;dependency>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-starter-actuator&lt;/artifactId>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>org.mybatis.spring.boot&lt;/groupId>\n        &lt;artifactId>mybatis-spring-boot-starter&lt;/artifactId>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>com.alibaba&lt;/groupId>\n        &lt;artifactId>druid-spring-boot-starter&lt;/artifactId>\n        &lt;version>1.1.10&lt;/version>\n    &lt;/dependency>\n    &lt;!--mysql-connector-java-->\n    &lt;dependency>\n        &lt;groupId>mysql&lt;/groupId>\n        &lt;artifactId>mysql-connector-java&lt;/artifactId>\n    &lt;/dependency>\n    &lt;!--jdbc-->\n    &lt;dependency>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-starter-jdbc&lt;/artifactId>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-devtools&lt;/artifactId>\n        &lt;scope>runtime&lt;/scope>\n        &lt;optional>true&lt;/optional>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>org.projectlombok&lt;/groupId>\n        &lt;artifactId>lombok&lt;/artifactId>\n        &lt;optional>true&lt;/optional>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-starter-test&lt;/artifactId>\n        &lt;scope>test&lt;/scope>\n    &lt;/dependency>\n&lt;/dependencies>\n\n&lt;/project&gt;\n3.写YML\nserver:\n  port: 8001\n\nspring:\n  application:\n    name: cloud-payment-service\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型\n    driver-class-name: org.gjt.mm.mysql.Driver              # mysql驱动包\n    url: jdbc:mysql://localhost:3306/my?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false\n    username: root\n    password: 1234\n\nmybatis:\n  mapperLocations: classpath:mapper/*.xml\n  type-aliases-package: com.lun.springcloud.entities    # 所有Entity别名类所在包\n\n\n09_支付模块构建(中)5.业务类\nSQL：`\n\n`CREATE TABLE payment(`\n\t`id bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',`\n    `serial varchar(200) DEFAULT '',`\n\t`PRIMARY KEY (id)`\n`)ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4\n\nEntities：\n实体类Payment：\nimport lombok.AllArgsConstructor;`\n`import lombok.Data;`\n`import lombok.NoArgsConstructor;`\n\n`import java.io.Serializable;`\n\n`@Data`\n`@AllArgsConstructor`\n`@NoArgsConstructor`\n`public class Payment implements Serializable &#123;`\n    `private Long id;`\n    `private String serial;`\n`&#125;`\n\n`JSON封装体CommonResult：`\n\n`import lombok.AllArgsConstructor;`\n`import lombok.Data;`\n`import lombok.NoArgsConstructor;`\n\n`@Data`\n`@AllArgsConstructor`\n`@NoArgsConstructor`\n`public class CommonResult&lt;T>&#123;`\n    `private Integer code;`\n    `private String message;`\n    `private T data;`\n\n    public CommonResult(Integer code, String message)&#123;\n        this(code, message, null);\n    &#125;\n\n`&#125;\n\nDAO：\n接口PaymentDao：\nimport com.atguigu.springcloud.entities.Payment;\nimport org.apache.ibatis.annotations.Mapper;\nimport org.apache.ibatis.annotations.Param;\n\n/**\n */\n@Mapper\n//@Repository不用Spring的\npublic interface PaymentDao\n&#123;\n    public int create(Payment payment);\n\n    public Payment getPaymentById(@Param(\"id\") Long id);\n\n&#125;\n\nMyBatis映射文件PaymentMapper.xml，路径：resources&#x2F;mapper&#x2F;PaymentMapper.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\n&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n\n\n\n&lt;mapper namespace=\"com.lun.springcloud.dao.PaymentDao\">\n\n    &lt;insert id=\"create\" parameterType=\"Payment\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n        insert into payment(serial)  values(#&#123;serial&#125;);\n    &lt;/insert>\n    \n    &lt;resultMap id=\"BaseResultMap\" type=\"com.lun.springcloud.entities.Payment\">\n        &lt;id column=\"id\" property=\"id\" jdbcType=\"BIGINT\"/>\n        &lt;id column=\"serial\" property=\"serial\" jdbcType=\"VARCHAR\"/>\n    &lt;/resultMap>\n    \n    &lt;select id=\"getPaymentById\" parameterType=\"Long\" resultMap=\"BaseResultMap\">\n        select * from payment where id=#&#123;id&#125;;\n    &lt;/select>\n\n&lt;/mapper>\n\nService：\n接口PaymentService\nimport com.lun.springcloud.entities.Payment;\nimport org.apache.ibatis.annotations.Param;\n\n/**\n */\npublic interface PaymentService\n&#123;\n    public int create(Payment payment);\n\n    public Payment getPaymentById(@Param(\"id\") Long id);\n\n&#125;\n\n\n实现类\n\nimport com.lun.springcloud.dao.PaymentDao;\nimport com.lun.springcloud.entities.Payment;\nimport com.lun.springcloud.service.PaymentService;\nimport org.apache.ibatis.annotations.Param;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.Resource;\n\n/**\n */\n@Service\npublic class PaymentServiceImpl implements PaymentService\n&#123;\n    @Resource\n    private PaymentDao paymentDao;\n\n    public int create(Payment payment)\n    &#123;\n        return paymentDao.create(payment);\n    &#125;\n    \n    public Payment getPaymentById(Long id)\n    &#123;\n        return paymentDao.getPaymentById(id);\n    &#125;\n\n&#125;\n\nController：\nimport com.lun.springcloud.entities.CommonResult;\nimport com.lun.springcloud.entities.Payment;\nimport com.lun.springcloud.service.PaymentService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.cloud.client.ServiceInstance;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.cloud.client.discovery.DiscoveryClient;\n\nimport javax.annotation.Resource;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\n/**\n */\n@RestController\n@Slf4j\npublic class PaymentController&#123;\n    @Resource\n    private PaymentService paymentService;\n\n    @PostMapping(value = \"/payment/create\")\n    public CommonResult create(Payment payment)\n    &#123;\n        int result = paymentService.create(payment);\n        log.info(\"*****插入结果：\"+result);\n    \n        if(result > 0)\n        &#123;\n            return new CommonResult(200,\"插入数据库成功,serverPort: \"+serverPort,result);\n        &#125;else&#123;\n            return new CommonResult(444,\"插入数据库失败\",null);\n        &#125;\n    &#125;\n    \n    @GetMapping(value = \"/payment/get/&#123;id&#125;\")\n    public CommonResult&lt;Payment> getPaymentById(@PathVariable(\"id\") Long id)\n    &#123;\n        Payment payment = paymentService.getPaymentById(id);\n    \n        if(payment != null)\n        &#123;\n            return new CommonResult(200,\"查询成功,serverPort:  \"+serverPort,payment);\n        &#125;else&#123;\n            return new CommonResult(444,\"没有对应记录,查询ID: \"+id,null);\n        &#125;\n    &#125;\n\n&#125;\n\n10_支付模块构建(下)6.测试\n浏览器 - http://localhost:8001/payment/get/1Postman - http://localhost:8001/payment/create?serial=lun27.小总结\n创建微服务模块套路：\n建Module改POM写YML主启动业务类11_热部署Devtools开发时使用，生产环境关闭\n1.Adding devtools to your project\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-devtools&lt;/artifactId>\n    &lt;scope>runtime&lt;/scope>\n    &lt;optional>true&lt;/optional>\n&lt;/dependency>\n\n1234562.Adding plugin to your pom.xml\n下段配置复制到聚合父类总工程的pom.xml\n&lt;build>\n    &lt;!--\n\t&lt;finalName>你的工程名&lt;/finalName>（单一工程时添加）\n    -->\n    &lt;plugins>\n        &lt;plugin>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId>\n            &lt;configuration>\n                &lt;fork>true&lt;/fork>\n                &lt;addResources>true&lt;/addResources>\n            &lt;/configuration>\n        &lt;/plugin>\n    &lt;/plugins>\n&lt;/build>\n\n3.Enabling automatic build\nFile -&gt; Settings(New Project Settings-&gt;Settings for New Projects) -&gt;Complier\n下面项勾选\nAutomatically show first error in editorDisplay notification on build completionBuild project automaticallyCompile independent modules in parallel4.Update the value of\n键入Ctrl + Shift + Alt + &#x2F; ，打开Registry，勾选：\ncompiler.automake.allow.when.app.running\nactionSystem.assertFocusAccessFromEdt\n5.重启IDEA\n12_消费者订单模块(上)1.建Module\n创建名为cloud-consumer-order80的maven工程。\n2.改POM\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  &lt;parent>\n    &lt;artifactId>LearnCloud&lt;/artifactId>\n    &lt;groupId>com.lun&lt;/groupId>\n    &lt;version>1.0.0-SNAPSHOT&lt;/version>\n  &lt;/parent>\n  &lt;modelVersion>4.0.0&lt;/modelVersion>\n\n  &lt;artifactId>cloud-consumer-order80&lt;/artifactId>\n\n  &lt;properties>\n    &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding>\n    &lt;maven.compiler.source>1.7&lt;/maven.compiler.source>\n    &lt;maven.compiler.target>1.7&lt;/maven.compiler.target>\n  &lt;/properties>\n\n  &lt;dependencies>\n    &lt;dependency>\n      &lt;groupId>org.springframework.boot&lt;/groupId>\n      &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n    &lt;/dependency>\n    &lt;dependency>\n      &lt;groupId>org.springframework.boot&lt;/groupId>\n      &lt;artifactId>spring-boot-starter-actuator&lt;/artifactId>\n    &lt;/dependency>\n\n    &lt;dependency>\n      &lt;groupId>org.springframework.boot&lt;/groupId>\n      &lt;artifactId>spring-boot-devtools&lt;/artifactId>\n      &lt;scope>runtime&lt;/scope>\n      &lt;optional>true&lt;/optional>\n    &lt;/dependency>\n    &lt;dependency>\n      &lt;groupId>org.projectlombok&lt;/groupId>\n      &lt;artifactId>lombok&lt;/artifactId>\n      &lt;optional>true&lt;/optional>\n    &lt;/dependency>\n    &lt;dependency>\n      &lt;groupId>org.springframework.boot&lt;/groupId>\n      &lt;artifactId>spring-boot-starter-test&lt;/artifactId>\n      &lt;scope>test&lt;/scope>\n    &lt;/dependency>\n\n  &lt;/dependencies>\n&lt;/project>\n\n\n3.写YML\nserver:  port: 80\n4.主启动\n\n&#96;&#96;&#96;javaimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;\n&#x2F;**\n\nHello world!\n *&#x2F;@SpringBootApplicationpublic class OrderMain80{public static void main( String[] args ){   SpringApplication.run(OrderMain80.class, args);}}   \n   \n\n 5.业务类\n\n实体类：\n\n&#96;&#96;&#96;java\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.io.Serializable;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Payment implements Serializable &#123;\n    private Long id;\n    private String serial;\n&#125;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class CommonResult&lt;T&gt;&#123;\n    private Integer code;\n    private String message;\n    private T data;\n\n    public CommonResult(Integer code, String message)&#123;\n        this(code, message, null);\n    &#125;\n\n&#125;\n\n\n\n\n\n控制层：\nimport com.lun.springcloud.entities.CommonResult;\nimport com.lun.springcloud.entities.Payment;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.client.RestTemplate;\n\nimport javax.annotation.Resource;\n\n@Slf4j\n@RestController\npublic class OrderController &#123;\n\n    public static final String PAYMENT_URL = \"http://localhost:8001\";\n    \n    @Resource\n    private RestTemplate restTemplate;\n    \n    @GetMapping(\"/consumer/payment/create\")\n    public CommonResult&lt;Payment> create(Payment payment)&#123;\n    \n        return restTemplate.postForObject(PAYMENT_URL+\"/payment/create\", payment, CommonResult.class);\n    &#125;\n    \n    @GetMapping(\"/consumer/payment/get/&#123;id&#125;\")\n    public CommonResult&lt;Payment> getPayment(@PathVariable(\"id\") Long id)&#123;\n        return restTemplate.getForObject(PAYMENT_URL+\"/payment/get/\"+id, CommonResult.class);\n    &#125;\n\n&#125;\n\n配置类：\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.client.RestTemplate;\n\n@Configuration\npublic class ApplicationContextConfig &#123;\n\n    @Bean\n    public RestTemplate getRestTemplate()&#123;\n        return new RestTemplate();\n    &#125;\n\n&#125;\n\n6.测试\n运行cloud-consumer-order80与cloud-provider-payment8001两工程\n浏览器 - http://localhost/consumer/payment/get/1RestTemplate\nRestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集\n官网地址\n使用：\n使用restTemplate访问restful接口非常的简单粗暴无脑。(url, requestMap, ResponseBean.class)这三个参数分别代表。REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。13_消费者订单模块(下)浏览器 - http://localhost/consumer/payment/create?serial=lun3\n虽然，返回成功，但是观测数据库中，并没有创建serial为lun3的行。\n解决之道：在loud-provider-payment8001工程的PaymentController中添加@RequestBody注解。\npublic class PaymentController\n&#123;\n\n    @PostMapping(value = \"/payment/create\")\n    public CommonResult create(@RequestBody/*添加到这里*/ Payment payment)&#123;\n    \t...\n    &#125;\n\n&#125;\n\n通过修改idea的workspace.xml的方式来快速打开Run Dashboard窗口（这个用来显示哪些Spring Boot工程运行，停止等信息。我idea 2020.1版本在名为Services窗口就可以显示哪些Spring Boot工程运行，停止等信息出来，所以这仅作记录参考）。\n开启Run DashBoard\n打开工程路径下的.idea文件夹的workspace.xml\n在中修改或添加以下代码：\n&lt;option name=\"configurationTypes\">\n\t&lt;set>\n\t\t&lt;option value=\"SpringBootApplicationConfigurationType\"/>\n    &lt;/set>\n&lt;/option>\n\n由于idea版本差异，可能需要关闭重启。\n14_工程重构观察cloud-consumer-order80与cloud-provider-payment8001两工程有重复代码（entities包下的实体）（坏味道），重构。\n1.新建 - cloud-api-commons\n2.POM\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    &lt;parent>\n        &lt;artifactId>LearnCloud&lt;/artifactId>\n        &lt;groupId>com.lun.springcloud&lt;/groupId>\n        &lt;version>1.0.0-SNAPSHOT&lt;/version>\n    &lt;/parent>\n    &lt;modelVersion>4.0.0&lt;/modelVersion>\n\n    &lt;artifactId>cloud-api-commons&lt;/artifactId>\n    \n    &lt;dependencies>\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-devtools&lt;/artifactId>\n            &lt;scope>runtime&lt;/scope>\n            &lt;optional>true&lt;/optional>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>org.projectlombok&lt;/groupId>\n            &lt;artifactId>lombok&lt;/artifactId>\n            &lt;optional>true&lt;/optional>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>cn.hutool&lt;/groupId>\n            &lt;artifactId>hutool-all&lt;/artifactId>\n            &lt;version>5.1.0&lt;/version>\n        &lt;/dependency>\n    &lt;/dependencies>\n\n&lt;/project>\n\n3.entities\n将cloud-consumer-order80与cloud-provider-payment8001两工程的公有entities包移至cloud-api-commons工程下。\n4.maven clean、install cloud-api-commons工程，以供给cloud-consumer-order80与cloud-provider-payment8001两工程调用。\n5.订单80和支付8001分别改造\n将cloud-consumer-order80与cloud-provider-payment8001两工程的公有entities包移除引入cloud-api-commons依赖\n&lt;dependency>\n    &lt;groupId>com.lun.springcloud&lt;/groupId>\n    &lt;artifactId>cloud-api-commons&lt;/artifactId>\n    &lt;version>$&#123;project.version&#125;&lt;/version>\n&lt;/dependency>\n\n6.测试\n15_Eureka基础知识什么是服务治理\nSpring Cloud封装了Netflix 公司开发的Eureka模块来实现服务治理\n在传统的RPC远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。\n什么是服务注册与发现\nEureka采用了CS的设计架构，Eureka Sever作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用Eureka的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。\n在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息比如服务地址通讯地址等以别名方式注册到注册中心上。另一方(消费者服务提供者)，以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想:在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何RPC远程框架中，都会有一个注册中心存放服务地址相关信息(接口地址)\nEureka包含两个组件:Eureka Server和Eureka Client\nEureka Server提供服务注册服务\n各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。\nEurekaClient通过注册中心进行访问\n它是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒)\n16_EurekaServer服务端安装IDEA生成eurekaServer端服务注册中心，类似物业公司\n1.创建名为cloud-eureka-server7001的Maven工程\n2.修改pom.xml\n&lt;!-- eureka新旧版本 -->\n&lt;!-- 以前的老版本（2018）-->\n&lt;dependency>\n    &lt;groupid>org.springframework.cloud&lt;/groupId>\n    &lt;artifactId>spring-cloud-starter-eureka&lt;/artifactId>\n&lt;/dependency>\n\n&lt;!-- 现在新版本（2020.2）-->&lt;!-- 我们使用最新的 -->\n&lt;dependency>\n    &lt;groupId>org.springframework.cloud&lt;/groupId>\n    &lt;artifactId>spring-cloud-starter-netflix-eureka-server&lt;/artifactId>\n&lt;/dependency>\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    &lt;parent>\n        &lt;artifactId>LearnCloud&lt;/artifactId>\n        &lt;groupId>com.lun.springcloud&lt;/groupId>\n        &lt;version>1.0.0-SNAPSHOT&lt;/version>\n    &lt;/parent>\n    &lt;modelVersion>4.0.0&lt;/modelVersion>\n\n    &lt;artifactId>cloud-eureka-server7001&lt;/artifactId>\n    \n    &lt;dependencies>\n        &lt;!--eureka-server-->\n        &lt;dependency>\n            &lt;groupId>org.springframework.cloud&lt;/groupId>\n            &lt;artifactId>spring-cloud-starter-netflix-eureka-server&lt;/artifactId>\n        &lt;/dependency>\n        &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->\n        &lt;dependency>\n            &lt;groupId>com.lun.springcloud&lt;/groupId>\n            &lt;artifactId>cloud-api-commons&lt;/artifactId>\n            &lt;version>$&#123;project.version&#125;&lt;/version>\n        &lt;/dependency>\n        &lt;!--boot web actuator-->\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-actuator&lt;/artifactId>\n        &lt;/dependency>\n        &lt;!--一般通用配置-->\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-devtools&lt;/artifactId>\n            &lt;scope>runtime&lt;/scope>\n            &lt;optional>true&lt;/optional>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>org.projectlombok&lt;/groupId>\n            &lt;artifactId>lombok&lt;/artifactId>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-test&lt;/artifactId>\n            &lt;scope>test&lt;/scope>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>junit&lt;/groupId>\n            &lt;artifactId>junit&lt;/artifactId>\n        &lt;/dependency>\n    &lt;/dependencies>\n\n&lt;/project>\n\n3.添加application.yml\nserver:\n  port: 7001\n\neureka:\n  instance:\n    hostname: locathost #eureka服务端的实例名称\n  client:\n    #false表示不向注册中心注册自己。\n    register-with-eureka: false\n    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    fetch-registry: false\n    service-url:\n      #设置与Eureka server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/\n\n4.主启动\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;\n\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaMain7001 &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(EurekaMain7001.class, args);\n    &#125;\n&#125;\n\n\n5.测试运行EurekaMain7001，浏览器输入http://localhost:7001/回车，会查看到Spring Eureka服务主页。\n17_支付微服务\n\n\n8001入驻进EurekaServerEurekaClient端cloud-provider-payment8001将注册进EurekaServer成为服务提供者provider，类似学校对外提供授课服务。\n1.修改cloud-provider-payment8001\n2.改POM\n添加spring-cloud-starter-netflix-eureka-client依赖\n&lt;dependency>\n    &lt;groupId>org.springframework.cloud&lt;/groupId>\n    &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId>\n&lt;/dependency>\n\n12343.写YML\neureka:  client:    #表示是否将自己注册进Eurekaserver默认为true。    register-with-eureka: true    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡    fetchRegistry: true    service-url:      defaultZone: http://localhost:7001/eureka123456784.主启动\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.EnableEurekaClient;\n\n@SpringBootApplication\n@EnableEurekaClient//&lt;-----添加该注解\npublic class PaymentMain001 &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(PaymentMain001.class, args);\n    &#125;\n\n&#125;\n\n1234567891011125.测试\n启动cloud-provider-payment8001和cloud-eureka-server7001工程。\n浏览器输入 - http://localhost:7001/ 主页内的Instances currently registered with Eureka会显示cloud-provider-payment8001的配置文件application.yml设置的应用名cloud-payment-service\nspring:  application:    name: cloud-payment-service1236.自我保护机制\nEMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARELESSER THAN THRESHOLD AND HENCFT ARE NOT BEING EXPIRED JUST TO BE SAFE.\n紧急情况！EUREKA可能错误地声称实例在没有启动的情况下启动了。续订小于阈值，因此实例不会为了安全而过期。\n18_订单微服务80入驻进EurekaServerEurekaClient端cloud-consumer-order80将注册进EurekaServer成为服务消费者consumer，类似来上课消费的同学\n1.cloud-consumer-order80\n2.POM\n&lt;dependency>\n    &lt;groupId>org.springframework.cloud&lt;/groupId>\n    &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId>\n&lt;/dependency>\n\n12343.YML\nserver:  port: 80\nspring:  application:    name: cloud-order-service\neureka:  client:    #表示是否将自己注册进Eurekaserver默认为true。    register-with-eureka: true    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡    fetchRegistry: true    service-url:      defaultZone: http://localhost:7001/eureka1234567891011121314154.主启动\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.EnableEurekaClient;\n\n@SpringBootApplication\n@EnableEurekaClient//&lt;--- 添加该标签\npublic class OrderMain80\n&#123;\n    public static void main( String[] args )&#123;\n        SpringApplication.run(OrderMain80.class, args);\n    &#125;\n&#125;\n\n1234567891011125.测试\n启动cloud-provider-payment8001、cloud-eureka-server7001和cloud-consumer-order80这三工程。浏览器输入 http://localhost:7001 , 在主页的Instances currently registered with Eureka将会看到cloud-provider-payment8001、cloud-consumer-order80两个工程名。注意，application.yml配置中层次缩进和空格，两者不能少，否则，会抛出异常Failed to bind properties under ‘eureka.client.service-url’ to java.util.Map &lt;java.lang.String, java.lang.String&gt;。\n19_Eureka集群原理说明1.Eureka集群原理说明\n服务注册：将服务信息注册进注册中心\n服务发现：从注册中心上获取服务信息\n实质：存key服务命取value闭用地址\n1先启动eureka注主册中心\n2启动服务提供者payment支付服务\n3支付服务启动后会把自身信息(比服务地址L以别名方式注朋进eureka\n4消费者order服务在需要调用接口时，使用服务别名去注册中心获取实际的RPC远程调用地址\n5消去者导调用地址后，底屋实际是利用HttpClient技术实现远程调用\n6消费者实癸导服务地址后会缓存在本地jvm内存中，默认每间隔30秒更新—次服务调用地址\n问题:微服务RPC远程服务调用最核心的是什么高可用，试想你的注册中心只有一个only one，万一它出故障了，会导致整个为服务环境不可用。\n解决办法：搭建Eureka注册中心集群，实现负载均衡+故障容错。\n互相注册，相互守望。\n20_Eureka集群环境构建创建cloud-eureka-server7002工程，过程参考16_EurekaServer服务端安装\nEureka7001Eureka7002找到C:\\Windows\\System32\\drivers\\etc路径下的hosts文件，修改映射配置添加进hosts文件127.0.0.1 eureka7001.com127.0.0.1 eureka7002.com12修改cloud-eureka-server7001配置文件server:  port: 7001\neureka:  instance:    hostname: eureka7001.com #eureka服务端的实例名称  client:    register-with-eureka: false     #false表示不向注册中心注册自己。    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务    service-url:    #集群指向其它eureka      defaultZone: http://eureka7002.com:7002/eureka/    #单机就是7001自己      #defaultZone: http://eureka7001.com:7001/eureka/1234567891011121314修改cloud-eureka-server7002配置文件server:  port: 7002\neureka:  instance:    hostname: eureka7002.com #eureka服务端的实例名称  client:    register-with-eureka: false     #false表示不向注册中心注册自己。    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务    service-url:    #集群指向其它eureka      defaultZone: http://eureka7001.com:7001/eureka/    #单机就是7002自己      #defaultZone: http://eureka7002.com:7002/eureka/1234567891011121314实践的时候，遇到异常情况\n在开启cloud-eureka-server7002时，开启失败，说7002端口被占用，然后在cmd中输入netstat -ano | find “7002”，查不到任何东西。\n纳闷一阵，重启电脑，问题解决。\n21_订单支付两微服务注册进Eureka集群将支付服务8001微服务，订单服务80微服务发布到上面2台Eureka集群配置中将它们的配置文件的eureka.client.service-url.defaultZone进行修改\neureka:  client:    #表示是否将自己注册进Eurekaserver默认为true。    register-with-eureka: true    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡    fetchRegistry: true    service-url:      defaultZone: http://eureka7001.com:7001/eureka, http://eureka7002.com:7002/eureka12345678测试01先要启动EurekaServer，7001&#x2F;7002服务再要启动服务提供者provider，8001再要启动消费者，80浏览器输入 - http://localhost/consumer/payment/get/122_支付微服务集群配置支付服务提供者8001集群环境构建\n参考cloud-provicer-payment8001\n1.新建cloud-provider-payment8002\n2.改POM\n3.写YML - 端口8002\n4.主启动\n5.业务类\n6.修改8001&#x2F;8002的Controller，添加serverPort\n@RestController@Slf4jpublic class PaymentController{\n@Value(&quot;$&#123;server.port&#125;&quot;)\nprivate String serverPort;//添加serverPort\n\n@PostMapping(value = &quot;/payment/create&quot;)\npublic CommonResult create(@RequestBody Payment payment)\n&#123;\n    int result = paymentService.create(payment);\n    log.info(&quot;*****插入结果：&quot; + result);\n\n    if(result &gt; 0) &#123;\n        return new CommonResult(200,&quot;插入数据库成功,serverPort: &quot;+serverPort/*添加到此处*/, result);\n    &#125;else&#123;\n        return new CommonResult(444,&quot;插入数据库失败&quot;,null);\n    &#125;\n&#125;\n\n}1234567891011121314151617181920负载均衡\ncloud-consumer-order80订单服务访问地址不能写死\n@Slf4j@RestControllerpublic class OrderController {\n//public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;\npublic static final String PAYMENT_URL = &quot;http://CLOUD-PAYMENT-SERVICE&quot;;\n\n...\n\n}123456789使用@LoadBalanced注解赋予RestTemplate负载均衡的能力\nimport org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;\n@Configurationpublic class ApplicationContextConfig {\n@Bean\n@LoadBalanced//使用@LoadBalanced注解赋予RestTemplate负载均衡的能力\npublic RestTemplate getRestTemplate()&#123;\n    return new RestTemplate();\n&#125;\n\n}123456789101112131415ApplicationContextBean - 提前说一下Ribbon的负载均衡功能\n测试\n先要启动EurekaServer，7001&#x2F;7002服务\n再要启动服务提供者provider，8001&#x2F;8002服务\n浏览器输入 - http://localhost/consumer/payment/get/31\n结果：负载均衡效果达到，8001&#x2F;8002端口交替出现\nRibbon和Eureka整合后Consumer可以直接调用服务而不用再关心地址和端口号，且该服务还有负载功能。\n相互注册，相互守望\n23_actuator微服务信息完善主机名称：服务名称修改（也就是将IP地址，换成可读性高的名字）\n修改cloud-provider-payment8001，cloud-provider-payment8002\n修改部分 - YML - eureka.instance.instance-id\neureka:  …  instance:    instance-id: payment8001 #添加此处1234eureka:  …  instance:    instance-id: payment8002 #添加此处1234修改之后\neureka主页将显示payment8001，payment8002代替原来显示的IP地址。\n访问信息有IP信息提示，（就是将鼠标指针移至payment8001，payment8002名下，会有IP地址提示）\n修改部分 - YML - eureka.instance.prefer-ip-address\neureka:  …  instance:    instance-id: payment8001    prefer-ip-address: true #添加此处12345eureka:  …  instance:    instance-id: payment8002    prefer-ip-address: true #添加此处1234524_服务发现Discovery对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息\n修改cloud-provider-payment8001的Controller@RestController@Slf4jpublic class PaymentController{    …\n@Resource\nprivate DiscoveryClient discoveryClient;\n\n...\n\n@GetMapping(value = &quot;/payment/discovery&quot;)\npublic Object discovery()\n&#123;\n    List&lt;String&gt; services = discoveryClient.getServices();\n    for (String element : services) &#123;\n        log.info(&quot;*****element: &quot;+element);\n    &#125;\n\n    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;);\n    for (ServiceInstance instance : instances) &#123;\n        log.info(instance.getServiceId()+&quot;\\t&quot;+instance.getHost()+&quot;\\t&quot;+instance.getPort()+&quot;\\t&quot;+instance.getUri());\n    &#125;\n\n    return this.discoveryClient;\n&#125;\n\n}12345678910111213141516171819202122232425268001主启动类@SpringBootApplication@EnableEurekaClient@EnableDiscoveryClient&#x2F;&#x2F;添加该注解public class PaymentMain001 {\npublic static void main(String[] args) &#123;\n    SpringApplication.run(PaymentMain001.class, args);\n&#125;\n\n}\n12345678910自测先要启动EurekaSeryer\n再启动8001主启动类，需要稍等一会儿\n浏览器输入http://localhost:8001/payment/discovery\n浏览器输出：\n{“services”:[“cloud-payment-service”],”order”:0}1后台输出：\n*****element: cloud-payment-serviceCLOUD-PAYMENT-SERVICE\t192.168.199.218\t8001\thttp://192.168.199.218:80011225_Eureka自我保护理论知识概述\n保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。\n如果在Eureka Server的首页看到以下这段提示，则说明Eureka进入了保护模式:\nEMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THANTHRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUSTTO BE SAFE\n导致原因\n一句话：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存。\n属于CAP里面的AP分支。\n为什么会产生Eureka自我保护机制?\n为了EurekaClient可以正常运行，防止与EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务剔除\n什么是自我保护模式?\n默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例(默认90秒)。但是当网络分区故障发生(延时、卡顿、拥挤)时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时(可能发生了网络分区故障)，那么这个节点就会进入自我保护模式。\n自我保护机制∶默认情况下EurekaClient定时向EurekaServer端发送心跳包\n如果Eureka在server端在一定时间内(默认90秒)没有收到EurekaClient发送心跳包，便会直接从服务注册列表中剔除该服务，但是在短时间( 90秒中)内丢失了大量的服务实例心跳，这时候Eurekaserver会开启自我保护机制，不会剔除该服务（该现象可能出现在如果网络不通但是EurekaClient为出现宕机，此时如果换做别的注册中心如果一定时间内没有收到心跳会将剔除该服务，这样就出现了严重失误，因为客户端还能正常发送心跳，只是网络延迟问题，而保护机制是为了解决此问题而产生的)。\n在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。\n它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。一句话讲解：好死不如赖活着。\n综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。\n26_怎么禁止自我保护在eurekaServer端7001处设置关闭自我保护机制出厂默认，自我保护机制是开启的\n使用eureka.server.enable-self-preservation &#x3D; false可以禁用自我保护模式\neureka:  …  server:    #关闭自我保护机制，保证不可用服务被及时踢除    enable-self-preservation: false    eviction-interval-timer-in-ms: 2000123456关闭效果：\nspring-eureka主页会显示出一句：\nTHE SELF PRESERVATION MODE IS TURNED OFF. THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK&#x2F;OTHER PROBLEMS.\n生产者客户端eureakeClient端8001默认：\neureka.instance.lease-renewal-interval-in-seconds&#x3D;30\neureka.instance.lease-expiration-duration-in-seconds&#x3D;90\neureka:  …  instance:    instance-id: payment8001    prefer-ip-address: true    #心跳检测与续约时间    #开发时没置小些，保证服务关闭后注册中心能即使剔除服务    #Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)    lease-renewal-interval-in-seconds: 1    #Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务    lease-expiration-duration-in-seconds: 21234567891011测试7001和8001都配置完成先启动7001再启动8001结果：先关闭8001，马上被删除了\n27_Eureka停更说明https://github.com/Netflix/eureka/wiki\nEureka 2.0 (Discontinued)\nThe existing open source work on eureka 2.0 is discontinued. The code base and artifacts that were released as part of the existing repository of work on the 2.x branch is considered use at your own risk.\nEureka 1.x is a core part of Netflix’s service discovery system and is still an active project.\n我们用ZooKeeper代替Eureka功能。\n28_支付服务注册进zookeeper注册中心Zookeeperzookeeper是一个分布式协调工具，可以实现注册中心功能\n关闭Linux服务器防火墙后，启动zookeeper服务器\n用到的Linux命令行：\nsystemctl stop firewalld关闭防火墙systemctl status firewalld查看防火墙状态ipconfig查看IP地址ping查验结果zookeeper服务器取代Eureka服务器，zk作为服务注册中心\n视频里是用虚拟机CentOS开启ZooKeeper，我打算在本机启动ZooKeeper，具体操作参考ZooKeeper学习笔记。\n服务提供者1.新建名为cloud-provider-payment8004的Maven工程。\n2.POM\n\n            LearnCloud        com.lun.springcloud        1.0.0-SNAPSHOT        4.0.0\n&lt;artifactId&gt;cloud-provider-payment8004&lt;/artifactId&gt;\n&lt;dependencies&gt;\n    &lt;!-- SpringBoot整合Web组件 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;\n        &lt;groupId&gt;com.lun.springcloud&lt;/groupId&gt;\n        &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;\n        &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- SpringBoot整合zookeeper客户端 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt;\n        &lt;!--先排除自带的zookeeper3.5.3 防止与3.4.9起冲突--&gt;\n        &lt;exclusions&gt;\n            &lt;exclusion&gt;\n                &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;\n                &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;\n            &lt;/exclusion&gt;\n        &lt;/exclusions&gt;\n    &lt;/dependency&gt;\n    &lt;!--添加zookeeper3.4.9版本--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;\n        &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;\n        &lt;version&gt;3.4.9&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n        &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;optional&gt;true&lt;/optional&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n        &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n        &lt;optional&gt;true&lt;/optional&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n3.YML\n\n#8004表示注册到zookeeper服务器的支付服务提供者端口号server:  port: 8004\n#服务别名—-注册zookeeper到注册中心名称spring:  application:    name: cloud-provider-payment  cloud:    zookeeper:      connect-string: 127.0.0.1:2181 # 192.168.111.144:2181 #12345678910114.主启动类\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n@SpringBootApplication@EnableDiscoveryClient&#x2F;&#x2F;该注解用于向使用consul或者zookeeper作为注册中心时注册服务public class PaymentMain8004 {    public static void main(String[] args) {        SpringApplication.run(PaymentMain8004.class, args);    }}12345678910115.Controller\nimport lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;\nimport java.util.UUID;\n@RestController@Slf4jpublic class PaymentController{    @Value(“${server.port}”)    private String serverPort;\n@RequestMapping(value = &quot;/payment/zk&quot;)\npublic String paymentzk()\n&#123;\n    return &quot;springcloud with zookeeper: &quot;+serverPort+&quot;\\t&quot;+ UUID.randomUUID().toString();\n&#125;\n\n}\n1234567891011121314151617181920216.启动8004注册进zookeeper（要先启动zookeeper的server）\n验证测试：浏览器 - http://localhost:8004/payment/zk\n验证测试2 ：接着用zookeeper客户端操作\n[zk: localhost:2181(CONNECTED) 0] ls &#x2F;[services, zookeeper][zk: localhost:2181(CONNECTED) 1] ls &#x2F;services&#x2F;cloud-provider-payment[a4567f50-6ad9-47a3-9fbb-7391f41a9f3d][zk: localhost:2181(CONNECTED) 2] get &#x2F;services&#x2F;cloud-provider-payment&#x2F;a4567f50-6ad9-47a3-9fbb-7391f41a9f3d{“name”:”cloud-provider-payment”,”id”:”a4567f50-6ad9-47a3-9fbb-7391f41a9f3d”,”address”:”192.168.199.218”,”port”:8004,”sslPort”:null,”payload”:{“@class”:”org.springframework.cloud.zookeeper.discovery.ZookeeperInstance”,”id”:”application-1”,”name”:”cloud-provider-payment”,”metadata”:{}},”registrationTimeUTC”:1612811116918,”serviceType”:”DYNAMIC”,”uriSpec”:{“parts”:[{“value”:”scheme”,”variable”:true},{“value”:”:&#x2F;&#x2F;“,”variable”:false},{“value”:”address”,”variable”:true},{“value”:”:”,”variable”:false},{“value”:”port”,”variable”:true}]}}[zk: localhost:2181(CONNECTED) 3]1234567891011json格式化get &#x2F;services&#x2F;cloud-provider-payment&#x2F;a4567f50-6ad9-47a3-9fbb-7391f41a9f3d的结果：\n{    “name”: “cloud-provider-payment”,    “id”: “a4567f50-6ad9-47a3-9fbb-7391f41a9f3d”,    “address”: “192.168.199.218”,    “port”: 8004,    “sslPort”: null,    “payload”: {        “@class”: “org.springframework.cloud.zookeeper.discovery.ZookeeperInstance”,        “id”: “application-1”,        “name”: “cloud-provider-payment”,        “metadata”: { }    },    “registrationTimeUTC”: 1612811116918,    “serviceType”: “DYNAMIC”,    “uriSpec”: {        “parts”: [            {                “value”: “scheme”,                “variable”: true            },            {                “value”: “:&#x2F;&#x2F;“,                “variable”: false            },            {                “value”: “address”,                “variable”: true            },            {                “value”: “:”,                “variable”: false            },            {                “value”: “port”,                “variable”: true            }        ]    }}12345678910111213141516171819202122232425262728293031323334353637383929_临时还是持久节点ZooKeeper的服务节点是临时节点，没有Eureka那含情脉脉。\n30_订单服务注册进zookeeper1.新建cloud-consumerzk-order80\n2.POM\n\n            LearnCloud        com.lun.springcloud        1.0.0-SNAPSHOT        4.0.0\n&lt;artifactId&gt;cloud-consumerzk-order80&lt;/artifactId&gt;\n\n&lt;dependencies&gt;\n    &lt;!-- SpringBoot整合Web组件 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!-- SpringBoot整合zookeeper客户端 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt;\n        &lt;!--先排除自带的zookeeper--&gt;\n        &lt;exclusions&gt;\n            &lt;exclusion&gt;\n                &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;\n                &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;\n            &lt;/exclusion&gt;\n        &lt;/exclusions&gt;\n    &lt;/dependency&gt;\n    &lt;!--添加zookeeper3.4.9版本--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;\n        &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;\n        &lt;version&gt;3.4.9&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n        &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;optional&gt;true&lt;/optional&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n        &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n        &lt;optional&gt;true&lt;/optional&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n3.YML\n\nserver:  port: 80\n#服务别名—-注册zookeeper到注册中心名称spring:  application:    name: cloud-consumer-order  cloud:    zookeeper:      connect-string: 127.0.0.1:2181 # 192.168.111.144:2181 #123456789104.主启动\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n@SpringBootApplication@EnableDiscoveryClientpublic class OrderZKMain80 {    public static void main(String[] args) {        SpringApplication.run(OrderZKMain80.class, args);    }}12345678910115.业务类\nimport org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;\n@Configurationpublic class ApplicationContextConfig{    @Bean    @LoadBalanced    public RestTemplate getRestTemplate()    {        return new RestTemplate();    }}123456789101112131415import javax.annotation.Resource;\n@RestController@Slf4jpublic class OrderZKController{    public static final String INVOKE_URL &#x3D; “http://cloud-provider-payment&quot;;\n@Resource\nprivate RestTemplate restTemplate;\n\n@GetMapping(value = &quot;/consumer/payment/zk&quot;)\npublic String paymentInfo()\n&#123;\n    String result = restTemplate.getForObject(INVOKE_URL+&quot;/payment/zk&quot;,String.class);\n    return result;\n&#125;\n\n}1234567891011121314151617186.验证测试\n运行ZooKeeper服务端，cloud-consumerzk-order80，cloud-provider-payment8004。\n打开ZooKeeper客户端：\n[zk: localhost:2181(CONNECTED) 0] ls &#x2F;[services, zookeeper][zk: localhost:2181(CONNECTED) 1] ls &#x2F;services[cloud-consumer-order, cloud-provider-payment][zk: localhost:2181(CONNECTED) 2]123457.访问测试地址 - http://localhost/consumer/payment/zk\n31_Consul简介Consul官网\nConsul下载地址\nWhat is Consul?\nConsul is a service mesh solution providing a full featured control plane with service discovery, configuration, and segmentation functionality. Each of these features can be used individually as needed, or they can be used together to build a full service mesh. Consul requires a data plane and supports both a proxy and native integration model. Consul ships with a simple built-in proxy so that everything works out of the box, but also supports 3rd party proxy integrations such as Envoy. link\nConsul是一个服务网格解决方案，它提供了一个功能齐全的控制平面，具有服务发现、配置和分段功能。这些特性中的每一个都可以根据需要单独使用，也可以一起用于构建全服务网格。Consul需要一个数据平面，并支持代理和本机集成模型。Consul船与一个简单的内置代理，使一切工作的开箱即用，但也支持第三方代理集成，如Envoy。\nconsul英 [ˈkɒnsl] 美 [ˈkɑːnsl]n. 领事\nConsul是一套开源的分布式服务发现和配置管理系统，由HashiCorp 公司用Go语言开发。\n提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之Consul提供了一种完整的服务网格解决方案。\n它具有很多优点。包括：基于raft协议，比较简洁；支持健康检查，同时支持HTTP和DNS协议支持跨数据中心的WAN集群提供图形界面跨平台，支持Linux、Mac、Windows。\nThe key features of Consul are:\nService Discovery: Clients of Consul can register a service, such as api or mysql, and other clients can use Consul to discover providers of a given service. Using either DNS or HTTP, applications can easily find the services they depend upon.Health Checking: Consul clients can provide any number of health checks, either associated with a given service (“is the webserver returning 200 OK”), or with the local node (“is memory utilization below 90%”). This information can be used by an operator to monitor cluster health, and it is used by the service discovery components to route traffic away from unhealthy hosts.KV Store: Applications can make use of Consul’s hierarchical key&#x2F;value store for any number of purposes, including dynamic configuration, feature flagging, coordination, leader election, and more. The simple HTTP API makes it easy to use.Secure Service Communication: Consul can generate and distribute TLS certificates for services to establish mutual TLS connections. Intentions can be used to define which services are allowed to communicate. Service segmentation can be easily managed with intentions that can be changed in real time instead of using complex network topologies and static firewall rules.Multi Datacenter: Consul supports multiple datacenters out of the box. This means users of Consul do not have to worry about building additional layers of abstraction to grow to multiple regions.link\n能干嘛？\n服务发现 - 提供HTTP和DNS两种发现方式。健康监测 - 支持多种方式，HTTP、TCP、Docker、Shell脚本定制化KV存储 - Key、Value的存储方式多数据中心 - Consul支持多数据中心可视化Web界面怎么玩\n32_安装并运行Consul官网安装说明\nwindows版解压缩后，得consul.exe，打开cmd\n查看版本consul -v：D:\\Consul&gt;consul -vConsul v1.9.3Revision f55da9306Protocol 2 spoken by default, understands 2 to 3 (agent will automatically use protocol &gt;2 when speaking to compatible agents)1234开发模式启动consul agent -dev：浏览器输入 - http://localhost:8500/ - 打开Consul控制页。\n33_服务提供者注册进Consul1.新建Module支付服务provider8006\n2.POM\n\n            LearnCloud        com.lun.springcloud        1.0.0-SNAPSHOT        4.0.0\n&lt;artifactId&gt;cloud-providerconsul-payment8006&lt;/artifactId&gt;\n&lt;dependencies&gt;\n    &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.lun.springcloud&lt;/groupId&gt;\n        &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;\n        &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!--SpringCloud consul-server --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!-- SpringBoot整合Web组件 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!--日常通用jar包配置--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n        &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;optional&gt;true&lt;/optional&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n        &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n        &lt;optional&gt;true&lt;/optional&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;cn.hutool&lt;/groupId&gt;\n        &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;\n        &lt;version&gt;RELEASE&lt;/version&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;cn.hutool&lt;/groupId&gt;\n        &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;\n        &lt;version&gt;RELEASE&lt;/version&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n3.YML\n\n###consul服务端口号server:  port: 8006\nspring:  application:    name: consul-provider-payment####consul注册中心地址  cloud:    consul:      host: localhost      port: 8500      discovery:        #hostname: 127.0.0.1        service-name: ${spring.application.name}1234567891011121314154.主启动类\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n@SpringBootApplication@EnableDiscoveryClientpublic class PaymentMain8006{    public static void main(String[] args) {            SpringApplication.run(PaymentMain8006.class, args);    }}1234567891011125.业务类Controller\nimport lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;\nimport java.util.UUID;\n@RestController@Slf4jpublic class PaymentController{    @Value(“${server.port}”)    private String serverPort;\n@RequestMapping(value = &quot;/payment/consul&quot;)\npublic String paymentConsul()\n&#123;\n    return &quot;springcloud with consul: &quot;+serverPort+&quot;\\t   &quot;+ UUID.randomUUID().toString();\n&#125;\n\n}\n1234567891011121314151617181920216.验证测试\nhttp://localhost:8006/payment/consulhttp://localhost:8500 - 会显示provider800634_服务消费者注册进Consul1.新建Module消费服务order80 - cloud-consumerconsul-order80\n2.POM\n\n            LearnCloud        com.lun.springcloud        1.0.0-SNAPSHOT        4.0.0\n&lt;artifactId&gt;cloud-consumerconsul-order80&lt;/artifactId&gt;\n&lt;dependencies&gt;\n    &lt;!--SpringCloud consul-server --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!-- SpringBoot整合Web组件 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!--日常通用jar包配置--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n        &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;optional&gt;true&lt;/optional&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n        &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n        &lt;optional&gt;true&lt;/optional&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n3.YML\n\n###consul服务端口号server:  port: 80\nspring:  application:    name: cloud-consumer-order####consul注册中心地址  cloud:    consul:      host: localhost      port: 8500      discovery:        #hostname: 127.0.0.1        service-name: ${spring.application.name}1234567891011121314154.主启动类\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;\n@SpringBootApplication@EnableDiscoveryClient &#x2F;&#x2F;该注解用于向使用consul或者zookeeper作为注册中心时注册服务public class OrderConsulMain80{    public static void main(String[] args) {            SpringApplication.run(OrderConsulMain80.class, args);    }}\n123456789101112135.配置Bean\nimport org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;\n&#x2F;** *&#x2F;@Configurationpublic class ApplicationContextConfig{    @Bean    @LoadBalanced    public RestTemplate getRestTemplate()    {        return new RestTemplate();    }}12345678910111213141516176.Controller\nimport lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;\nimport javax.annotation.Resource;\n@RestController@Slf4jpublic class OrderConsulController{    public static final String INVOKE_URL &#x3D; “http://consul-provider-payment&quot;;\n@Resource\nprivate RestTemplate restTemplate;\n\n@GetMapping(value = &quot;/consumer/payment/consul&quot;)\npublic String paymentInfo()\n&#123;\n    String result = restTemplate.getForObject(INVOKE_URL+&quot;/payment/consul&quot;,String.class);\n    return result;\n&#125;\n\n}12345678910111213141516171819202122237.验证测试\n运行consul，cloud-providerconsul-payment8006，cloud-consumerconsul-order80\nhttp://localhost:8500/ 主页会显示出consul，cloud-providerconsul-payment8006，cloud-consumerconsul-order80三服务。\n8.访问测试地址 - http://localhost/consumer/payment/consul\n35_三个注册中心异同点组件名\t语言CAP\t服务健康检查\t对外暴露接口\tSpring Cloud集成Eureka\tJava\tAP\t可配支持\tHTTPConsul\tGo\tCP\t支持\tHTTP&#x2F;DNSZookeeper\tJava\tCP\t支持客户端\t已集成CAP：\nC：Consistency (强一致性)\nA：Availability (可用性)\nP：Partition tolerance （分区容错性)\n最多只能同时较好的满足两个。\nCAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求。\n因此，根据CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三大类:\nCA - 单点集群，满足—致性，可用性的系统，通常在可扩展性上不太强大。CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。AP架构（Eureka）\n当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。\n结论：违背了一致性C的要求，只满足可用性和分区容错，即AP\nCP架构（ZooKeeper&#x2F;Consul）\n当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性。\n结论：违背了可用性A的要求，只满足一致性和分区容错，即CP。\nCP 与 AP 对立同一的矛盾关系。\n36_Ribbon入门介绍Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。\n简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。\n简单的说，就是在配置文件中列出Load Balancer(简称LB)后面所有的机器，Ribbon会自动的帮助你基于某种规则(如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。\nribbon\n英 [ˈrɪbən] 美 [ˈrɪbən]\nn. (用于捆绑或装饰的)带子;丝带;带状物;狭长的东西;绶带;勋带\nGithub - Ribbon\nRibbon目前也进入维护模式。\nRibbon未来可能被Spring Cloud LoadBalacer替代。\nLB负载均衡(Load Balance)是什么\n简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高可用)。\n常见的负载均衡有软件Nginx，LVS，硬件F5等。\nRibbon本地负载均衡客户端VS Nginx服务端负载均衡区别\nNginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。\n集中式LB\n即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx)，由该设施负责把访问请求通过某种策略转发至服务的提供方;\n进程内LB\n将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。\nRibbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。\n一句话\n负载均衡 + RestTemplate调用\n37_Ribbon的负载均衡和Rest调用架构说明\n总结：Ribbon其实就是一个软负载均衡的客户端组件，它可以和其他所需请求的客户端结合使用，和Eureka结合只是其中的一个实例。\nRibbon在工作时分成两步：\n第一步先选择EurekaServer ,它优先选择在同一个区域内负载较少的server。\n第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。\n其中Ribbon提供了多种策略：比如轮询、随机和根据响应时间加权。\nPOM\n先前工程项目没有引入spring-cloud-starter-ribbon也可以使用ribbon。\n\n    org.springframework.cloud\n    spring-cloud-starter-netflix-ribbon\n\n1\n2\n3\n4\n这是因为spring-cloud-starter-netflix-eureka-client自带了spring-cloud-starter-ribbon引用。\n\n二说RestTemplate的使用\nRestTemplate Java Doc\ngetForObject() &#x2F; getForEntity() - GET请求方法\ngetForObject()：返回对象为响应体中数据转化成的对象，基本上可以理解为Json。\ngetForEntity()：返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等。\n@GetMapping(“&#x2F;consumer&#x2F;payment&#x2F;getForEntity&#x2F;{id}”)public CommonResult getPayment2(@PathVariable(“id”) Long id){    ResponseEntity entity &#x3D; restTemplate.getForEntity(PAYMENT_URL+”&#x2F;payment&#x2F;get&#x2F;“+id,CommonResult.class);\nif(entity.getStatusCode().is2xxSuccessful())&#123;\n    return entity.getBody();//getForObject()\n&#125;else&#123;\n    return new CommonResult&lt;&gt;(444,&quot;操作失败&quot;);\n&#125;\n\n}1234567891011postForObject() &#x2F; postForEntity() - POST请求方法\n38_Ribbon默认自带的负载规则lRule：根据特定算法中从服务列表中选取一个要访问的服务\nRoundRobinRule 轮询RandomRule 随机RetryRule 先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重WeightedResponseTimeRule 对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择BestAvailableRule 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务AvailabilityFilteringRule 先过滤掉故障实例，再选择并发较小的实例ZoneAvoidanceRule 默认规则,复合判断server所在区域的性能和server的可用性选择服务器39_Ribbon负载规则替换1.修改cloud-consumer-order80\n2.注意配置细节\n官方文档明确给出了警告:\n这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，\n否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了。\n（也就是说不要将Ribbon配置类与主启动类同包）\n3.新建package - com.lun.myrule\n4.在com.lun.myrule下新建MySelfRule规则类\nimport com.netflix.loadbalancer.IRule;import com.netflix.loadbalancer.RandomRule;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;\n@Configurationpublic class MySelfRule {\n@Bean\npublic IRule myRule()&#123;\n    return new RandomRule();\n&#125;\n\n}123456789101112135.主启动类添加@RibbonClient\nimport com.lun.myrule.MySelfRule;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.ribbon.RibbonClient;\n@SpringBootApplication@EnableEurekaClient&#x2F;&#x2F;添加到此处@RibbonClient(name &#x3D; “CLOUD-PAYMENT-SERVICE”, configuration &#x3D; MySelfRule.class)public class OrderMain80{    public static void main( String[] args ){        SpringApplication.run(OrderMain80.class, args);    }}123456789101112131415166.测试\n开启cloud-eureka-server7001，cloud-consumer-order80，cloud-provider-payment8001，cloud-provider-payment8002\n浏览器-输入http://localhost/consumer/payment/get/1\n返回结果中的serverPort在8001与8002两种间反复横跳。\n40_Ribbon默认负载轮询算法原理默认负载轮训算法: rest接口第几次请求数 % 服务器集群总数量 &#x3D; 实际调用服务器位置下标，每次服务重启动后rest接口计数从1开始。\nList instances &#x3D; discoveryClient.getInstances(“CLOUD-PAYMENT-SERVICE”);\n如:\nList [0] instances &#x3D; 127.0.0.1:8002List [1] instances &#x3D; 127.0.0.1:80018001+ 8002组合成为集群，它们共计2台机器，集群总数为2，按照轮询算法原理：\n当总请求数为1时:1%2&#x3D;1对应下标位置为1，则获得服务地址为127.0.0.1:8001当总请求数位2时:2%2&#x3D;О对应下标位置为0，则获得服务地址为127.0.0.1:8002当总请求数位3时:3%2&#x3D;1对应下标位置为1，则获得服务地址为127.0.0.1:8001当总请求数位4时:4%2&#x3D;О对应下标位置为0，则获得服务地址为127.0.0.1:8002如此类推…41_RoundRobinRule源码分析public interface IRule{    &#x2F;*     * choose one alive server from lb.allServers or     * lb.upServers according to key     *     * @return choosen Server object. NULL is returned if none     *  server is available     *&#x2F;\n//重点关注这方法\npublic Server choose(Object key);\n\npublic void setLoadBalancer(ILoadBalancer lb);\n\npublic ILoadBalancer getLoadBalancer();    \n\n}12345678910111213141516package com.netflix.loadbalancer;\nimport com.netflix.client.config.IClientConfig;import org.slf4j.Logger;import org.slf4j.LoggerFactory;\nimport java.util.List;import java.util.concurrent.atomic.AtomicInteger;\n&#x2F;**\n\nThe most well known and basic load balancing strategy, i.e. Round Robin Rule.\n\n\n\n\n@author stonse\n\n@author Nikos Michalakis &#110;&#105;&#107;&#x6f;&#115;&#64;&#x6e;&#x65;&#116;&#x66;&#x6c;&#x69;&#120;&#46;&#99;&#111;&#109;\n\n *&#x2F;public class RoundRobinRule extends AbstractLoadBalancerRule {\n\nprivate AtomicInteger nextServerCyclicCounter;private static final boolean AVAILABLE_ONLY_SERVERS &#x3D; true;private static final boolean ALL_SERVERS &#x3D; false;\nprivate static Logger log &#x3D; LoggerFactory.getLogger(RoundRobinRule.class);\npublic RoundRobinRule() {    nextServerCyclicCounter &#x3D; new AtomicInteger(0);}\npublic RoundRobinRule(ILoadBalancer lb) {    this();    setLoadBalancer(lb);}\n&#x2F;&#x2F;重点关注这方法。public Server choose(ILoadBalancer lb, Object key) {    if (lb &#x3D;&#x3D; null) {        log.warn(“no load balancer”);        return null;    }\nServer server = null;\nint count = 0;\nwhile (server == null &amp;&amp; count++ &lt; 10) &#123;\n    List&lt;Server&gt; reachableServers = lb.getReachableServers();\n    List&lt;Server&gt; allServers = lb.getAllServers();\n    int upCount = reachableServers.size();\n    int serverCount = allServers.size();\n \n    if ((upCount == 0) || (serverCount == 0)) &#123;\n        log.warn(&quot;No up servers available from load balancer: &quot; + lb);\n        return null;\n    &#125;\n \n    int nextServerIndex = incrementAndGetModulo(serverCount);\n    server = allServers.get(nextServerIndex);\n \n    if (server == null) &#123;\n        /* Transient. */\n        Thread.yield();\n        continue;\n    &#125;\n \n    if (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;\n        return (server);\n    &#125;\n \n    // Next.\n    server = null;\n&#125;\n \nif (count &gt;= 10) &#123;\n    log.warn(&quot;No available alive servers after 10 tries from load balancer: &quot;\n            + lb);\n&#125;\nreturn server;\n\n}\n&#x2F;**\n\nInspired by the implementation of {@link AtomicInteger#incrementAndGet()}.\n\n\n\n@param modulo The modulo to bound the value of the counter.\n@return The next value.*&#x2F; private int incrementAndGetModulo(int modulo) {for (;;) {int current &#x3D; nextServerCyclicCounter.get();int next &#x3D; (current + 1) % modulo;&#x2F;&#x2F;求余法if (nextServerCyclicCounter.compareAndSet(current, next))    return next;} }\n\n@Overridepublic Server choose(Object key) {    return choose(getLoadBalancer(), key);}\n@Overridepublic void initWithNiwsConfig(IClientConfig clientConfig) {} } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 42_Ribbon之手写轮询算法 自己试着写一个类似RoundRobinRule的本地负载均衡器。\n\n\n7001&#x2F;7002集群启动\n8001&#x2F;8002微服务改造- controller\n@RestController@Slf4jpublic class PaymentController{\n...\n\n@GetMapping(value = &quot;/payment/lb&quot;)\npublic String getPaymentLB() &#123;\n    return serverPort;//返回服务接口\n&#125;\n\n...\n\n}1234567891011121380订单微服务改造1.ApplicationContextConfig去掉注解@LoadBalanced，OrderMain80去掉注解@RibbonClient\nimport org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;\n@Configurationpublic class ApplicationContextConfig {\n@Bean\n//@LoadBalanced\npublic RestTemplate getRestTemplate()&#123;\n    return new RestTemplate();\n&#125;\n\n}1234567891011121314152.创建LoadBalancer接口\nimport org.springframework.cloud.client.ServiceInstance;\nimport java.util.List;\n&#x2F;** *&#x2F;public interface LoadBalancer{    ServiceInstance instances(List serviceInstances);}123456789103.MyLB\n实现LoadBalancer接口\nimport org.springframework.cloud.client.ServiceInstance;import org.springframework.stereotype.Component;\nimport java.util.List;import java.util.concurrent.atomic.AtomicInteger;\n&#x2F;** *&#x2F;@Component&#x2F;&#x2F;需要跟主启动类同包，或者在其子孙包下。public class MyLB implements LoadBalancer{\nprivate AtomicInteger atomicInteger = new AtomicInteger(0);\n\npublic final int getAndIncrement()\n&#123;\n    int current;\n    int next;\n\n    do &#123;\n        current = this.atomicInteger.get();\n        next = current &gt;= 2147483647 ? 0 : current + 1;\n    &#125;while(!this.atomicInteger.compareAndSet(current,next));\n    System.out.println(&quot;*****第几次访问，次数next: &quot;+next);\n    return next;\n&#125;\n\n//负载均衡算法：rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标  ，每次服务重启动后rest接口计数从1开始。\n@Override\npublic ServiceInstance instances(List&lt;ServiceInstance&gt; serviceInstances)\n&#123;\n    int index = getAndIncrement() % serviceInstances.size();\n\n    return serviceInstances.get(index);\n&#125;\n\n}\n123456789101112131415161718192021222324252627282930313233343536374.OrderController\nimport org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.client.discovery.DiscoveryClient;import com.lun.springcloud.lb.LoadBalancer;\n@Slf4j@RestControllerpublic class OrderController {\n//public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;\npublic static final String PAYMENT_URL = &quot;http://CLOUD-PAYMENT-SERVICE&quot;;\n\n...\n\n@Resource\nprivate LoadBalancer loadBalancer;\n\n@Resource\nprivate DiscoveryClient discoveryClient;\n\n...\n\n@GetMapping(value = &quot;/consumer/payment/lb&quot;)\npublic String getPaymentLB()\n&#123;\n    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;);\n\n    if(instances == null || instances.size() &lt;= 0)&#123;\n        return null;\n    &#125;\n\n    ServiceInstance serviceInstance = loadBalancer.instances(instances);\n    URI uri = serviceInstance.getUri();\n\n    return restTemplate.getForObject(uri+&quot;/payment/lb&quot;,String.class);\n\n&#125;\n\n}123456789101112131415161718192021222324252627282930313233343536375.测试 不停地刷新http://localhost/consumer/payment/lb，可以看到8001/8002交替出现。\n43_OpenFeign是什么官方文档\nGithub地址\nFeign is a declarative web service client. It makes writing web service clients easier. To use Feign create an interface and annotate it. It has pluggable annotation support including Feign annotations and JAX-RS annotations. Feign also supports pluggable encoders and decoders. Spring Cloud adds support for Spring MVC annotations and for using the same HttpMessageConverters used by default in Spring Web. Spring Cloud integrates Ribbon and Eureka, as well as Spring Cloud LoadBalancer to provide a load-balanced http client when using Feign. link\nFeign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。\nFeign能干什么\nFeign旨在使编写Java Http客户端变得更容易。\n前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可)，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。\nFeign集成了Ribbon\n利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。\nFeign和OpenFeign两者区别\nFeign是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是:使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务。\n\n    org.springframework.cloud\n    spring-cloud-starter-feign\n\n1\n2\n3\n4\nOpenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等。OpenFeign的@Feignclient可以解析SpringMVc的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。\n\n\n    org.springframework.cloud\n    spring-cloud-starter-openfeign\n\n1\n2\n3\n4\nfeign\n英 [feɪn] 美 [feɪn]\nv. 假装，装作，佯装(有某种感觉或生病、疲倦等)\n\n44_OpenFeign服务调用接口+注解：微服务调用接口 + @FeignClient\n1.新建cloud-consumer-feign-order80\n2.POM\n\n            LearnCloud        com.lun.springcloud        1.0.0-SNAPSHOT        4.0.0\n&lt;artifactId&gt;cloud-consumer-feign-order80&lt;/artifactId&gt;\n\n&lt;dependencies&gt;\n    &lt;!--openfeign--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!--eureka client--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.lun.springcloud&lt;/groupId&gt;\n        &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;\n        &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!--web--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!--一般基础通用配置--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n        &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;optional&gt;true&lt;/optional&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n        &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n        &lt;optional&gt;true&lt;/optional&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n3.YML\n\nserver:  port: 80\neureka:  client:    register-with-eureka: false    service-url:      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/123456784.主启动\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.openfeign.EnableFeignClients;\n@SpringBootApplication@EnableFeignClientspublic class OrderFeignMain80 {    public static void main(String[] args) {        SpringApplication.run(OrderFeignMain80.class, args);    }}\n1234567891011125.业务类\n业务逻辑接口+@FeignClient配置调用provider服务\n新建PaymentFeignService接口并新增注解@FeignClient\nimport com.lun.springcloud.entities.CommonResult;import com.lun.springcloud.entities.Payment;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;\n@Component@FeignClient(value &#x3D; “CLOUD-PAYMENT-SERVICE”)public interface PaymentFeignService{    @GetMapping(value &#x3D; “&#x2F;payment&#x2F;get&#x2F;{id}”)    public CommonResult getPaymentById(@PathVariable(“id”) Long id);\n}12345678910111213141516控制层Controller\nimport com.lun.springcloud.entities.CommonResult;import com.lun.springcloud.entities.Payment;import com.lun.springcloud.service.PaymentFeignService;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;\n@RestController@Slf4jpublic class OrderFeignController{    @Resource    private PaymentFeignService paymentFeignService;\n@GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;)\npublic CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) Long id)\n&#123;\n    return paymentFeignService.getPaymentById(id);\n&#125;\n\n}\n1234567891011121314151617181920212223246.测试\n先启动2个eureka集群7001&#x2F;7002\n再启动2个微服务8001&#x2F;8002\n启动OpenFeign启动\nhttp://localhost/consumer/payment/get/1\nFeign自带负载均衡配置项\n45_OpenFeign超时控制超时设置，故意设置超时演示出错情况\n1.服务提供方8001&#x2F;8002故意写暂停程序\n@RestController@Slf4jpublic class PaymentController {\n...\n\n@Value(&quot;$&#123;server.port&#125;&quot;)\nprivate String serverPort;\n\n...\n\n@GetMapping(value = &quot;/payment/feign/timeout&quot;)\npublic String paymentFeignTimeout()\n&#123;\n    // 业务逻辑处理正确，但是需要耗费3秒钟\n    try &#123;\n        TimeUnit.SECONDS.sleep(3);\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n    return serverPort;\n&#125;\n\n...\n\n}123456789101112131415161718192021222324252.服务消费方80添加超时方法PaymentFeignService\n@Component@FeignClient(value &#x3D; “CLOUD-PAYMENT-SERVICE”)public interface PaymentFeignService{\n...\n\n@GetMapping(value = &quot;/payment/feign/timeout&quot;)\npublic String paymentFeignTimeout();\n\n}\n123456789103.服务消费方80添加超时方法OrderFeignController\n@RestController@Slf4jpublic class OrderFeignController{    @Resource    private PaymentFeignService paymentFeignService;\n...\n\n@GetMapping(value = &quot;/consumer/payment/feign/timeout&quot;)\npublic String paymentFeignTimeout()\n&#123;\n    // OpenFeign客户端一般默认等待1秒钟\n    return paymentFeignService.paymentFeignTimeout();\n&#125;\n\n}123456789101112131415164.测试：\n多次刷新http://localhost/consumer/payment/feign/timeout\n将会跳出错误Spring Boot默认错误页面，主要异常：feign.RetryableException:Read timed out executing GET http://CLOUD-PAYMENT-SERVCE/payment/feign/timeout。\nOpenFeign默认等待1秒钟，超过后报错\nYML文件里需要开启OpenFeign客户端超时控制\n#设置feign客户端超时时间(OpenFeign默认支持ribbon)(单位：毫秒)ribbon:  #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间  ReadTimeout: 5000  #指的是建立连接后从服务器读取到可用资源所用的时间  ConnectTimeout: 500012345646_OpenFeign日志增强日志打印功能\nFeign提供了日志打印功能，我们可以通过配置来调整日恙级别，从而了解Feign 中 Http请求的细节。\n说白了就是对Feign接口的调用情况进行监控和输出\n日志级别\nNONE：默认的，不显示任何日志;BASIC：仅记录请求方法、URL、响应状态码及执行时间;HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息;FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。配置日志bean\nimport feign.Logger;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;\n@Configurationpublic class FeignConfig{    @Bean    Logger.Level feignLoggerLevel()    {        return Logger.Level.FULL;    }}\n1234567891011121314YML文件里需要开启日志的Feign客户端\nlogging:  level:    # feign日志以什么级别监控哪个接口    com.lun.springcloud.service.PaymentFeignService: debug1234后台日志查看\n得到更多日志信息。\n47_Hystrix是什么概述\n分布式系统面临的问题\n复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。\n服务雪崩\n多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.对于高流量的应用来说，单一的后避依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。\n所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。\nHystrix是什么\nHystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。\n“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝)，向调用方返回一个符合预期的、可处理的备选响应（FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\nhystrixn. 豪猪属;猬草属;豪猪;豪猪亚属\n48_Hystrix停更进维能干嘛\n服务降级服务熔断接近实对的监控…官网资料\nlink\nHystrix官宣，停更进维\nlink\n被动修bugs不再接受合并请求不再发布新版本49_Hystrix的服务降级熔断限流概念初讲服务降级\n服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback\n哪些情况会出发降级\n程序运行导常超时服务熔断触发服务降级线程池&#x2F;信号量打满也会导致服务降级服务熔断\n类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。\n服务的降级 -&gt; 进而熔断 -&gt; 恢复调用链路\n服务限流\n秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行。\n50_Hystrix支付微服务构建将cloud-eureka-server7001改配置成单机版\n1.新建cloud-provider-hygtrix-payment8001\n2.POM\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    &lt;parent>\n        &lt;artifactId>cloud2020&lt;/artifactId>\n        &lt;groupId>com.atguigu.springcloud&lt;/groupId>\n        &lt;version>1.0-SNAPSHOT&lt;/version>\n    &lt;/parent>\n    &lt;modelVersion>4.0.0&lt;/modelVersion>\n\n    &lt;artifactId>cloud-provider-hystrix-payment8001&lt;/artifactId>\n    \n    &lt;dependencies>\n        &lt;!--hystrix-->\n        &lt;dependency>\n            &lt;groupId>org.springframework.cloud&lt;/groupId>\n            &lt;artifactId>spring-cloud-starter-netflix-hystrix&lt;/artifactId>\n        &lt;/dependency>\n        &lt;!--eureka client-->\n        &lt;dependency>\n            &lt;groupId>org.springframework.cloud&lt;/groupId>\n            &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId>\n        &lt;/dependency>\n        &lt;!--web-->\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-actuator&lt;/artifactId>\n        &lt;/dependency>\n        &lt;dependency>&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->\n            &lt;groupId>com.atguigu.springcloud&lt;/groupId>\n            &lt;artifactId>cloud-api-commons&lt;/artifactId>\n            &lt;version>$&#123;project.version&#125;&lt;/version>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-devtools&lt;/artifactId>\n            &lt;scope>runtime&lt;/scope>\n            &lt;optional>true&lt;/optional>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>org.projectlombok&lt;/groupId>\n            &lt;artifactId>lombok&lt;/artifactId>\n            &lt;optional>true&lt;/optional>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-test&lt;/artifactId>\n            &lt;scope>test&lt;/scope>\n        &lt;/dependency>\n    &lt;/dependencies>\n\n&lt;/project>\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556573.YML\nserver:\n  port: 8001\n\nspring:\n  application:\n    name: cloud-provider-hystrix-payment\n\neureka:\n  client:\n    register-with-eureka: true\n    fetch-registry: true\n    service-url:\n      #defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n      defaultZone: http://eureka7001.com:7001/eureka\n\n12345678910111213144.主启动\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.EnableEurekaClient;\n\n/**\n */\n@SpringBootApplication\n@EnableEurekaClient\npublic class PaymentHystrixMain8001\n&#123;\n    public static void main(String[] args) &#123;\n            SpringApplication.run(PaymentHystrixMain8001.class, args);\n    &#125;\n&#125;\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n5.业务类\n\nservice\n\nimport org.springframework.stereotype.Service;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n */\n@Service\npublic class PaymentService &#123;\n    /**\n     */\n    public String paymentInfo_OK(Integer id)\n    &#123;\n        return \"线程池:  \"+Thread.currentThread().getName()+\"  paymentInfo_OK,id:  \"+id+\"\\t\"+\"O(∩_∩)O哈哈~\";\n    &#125;\n\n    public String paymentInfo_TimeOut(Integer id)\n    &#123;\n        try &#123; TimeUnit.MILLISECONDS.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n        return \"线程池:  \"+Thread.currentThread().getName()+\" id:  \"+id+\"\\t\"+\"O(∩_∩)O哈哈~\"+\"  耗时(秒): 3\";\n    &#125;\n\n&#125;\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\ncontroller\n\nimport com.lun.springcloud.service.PaymentService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.annotation.Resource;\n\n/**\n */\n@RestController\n@Slf4j\npublic class PaymentController\n&#123;\n    @Resource\n    private PaymentService paymentService;\n\n    @Value(\"$&#123;server.port&#125;\")\n    private String serverPort;\n    \n    @GetMapping(\"/payment/hystrix/ok/&#123;id&#125;\")\n    public String paymentInfo_OK(@PathVariable(\"id\") Integer id)\n    &#123;\n        String result = paymentService.paymentInfo_OK(id);\n        log.info(\"*****result: \"+result);\n        return result;\n    &#125;\n    \n    @GetMapping(\"/payment/hystrix/timeout/&#123;id&#125;\")\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id)\n    &#123;\n        String result = paymentService.paymentInfo_TimeOut(id);\n        log.info(\"*****result: \"+result);\n        return result;\n    &#125;\n\n&#125;\n\n123456789101112131415161718192021222324252627282930313233343536376.正常测试\n启动eureka7001\n启动cloud-provider-hystrix-payment8001\n访问\nsuccess的方法 - http://localhost:8001/payment/hystrix/ok/1每次调用耗费5秒钟 - http://localhost:8001/payment/hystrix/timeout/1\n上述module均OK\n以上述为根基平台，从正确 -&gt; 错误 -&gt; 降级熔断 -&gt; 恢复。\n51_JMeter高并发压测后卡顿上述在非高并发情形下，还能勉强满足\nJmeter压测测试\nJMeter官网\nThe Apache JMeter™ application is open source software, a 100% pure Java application designed to load test functional behavior and measure performance. It was originally designed for testing Web Applications but has since expanded to other test functions.\n开启Jmeter，来20000个并发压死8001，20000个请求都去访问paymentInfo_TimeOut服务\n1.测试计划中右键添加-》线程-》线程组（线程组202102，线程数：200，线程数：100，其他参数默认）\n2.刚刚新建线程组202102，右键它-》添加-》取样器-》Http请求-》基本 输入http://localhost:8001/payment/hystrix/ok/1\n3.点击绿色三角形图标启动。\n看演示结果：拖慢，原因：tomcat的默认的工作线程数被打满了，没有多余的线程来分解压力和处理。\nJmeter压测结论\n上面还是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖慢。\n52_订单微服务调用支付服务出现卡顿看热闹不嫌弃事大，80新建加入\n1.新建 - cloud-consumer-feign-hystrix-order80\n2.POM\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    &lt;parent>\n        &lt;artifactId>LearnCloud&lt;/artifactId>\n        &lt;groupId>com.lun.springcloud&lt;/groupId>\n        &lt;version>1.0.0-SNAPSHOT&lt;/version>\n    &lt;/parent>\n    &lt;modelVersion>4.0.0&lt;/modelVersion>\n\n    &lt;artifactId>cloud-consumer-feign-hystrix-order80&lt;/artifactId>\n    \n    &lt;dependencies>\n        &lt;!--openfeign-->\n        &lt;dependency>\n            &lt;groupId>org.springframework.cloud&lt;/groupId>\n            &lt;artifactId>spring-cloud-starter-openfeign&lt;/artifactId>\n        &lt;/dependency>\n        &lt;!--hystrix-->\n        &lt;dependency>\n            &lt;groupId>org.springframework.cloud&lt;/groupId>\n            &lt;artifactId>spring-cloud-starter-netflix-hystrix&lt;/artifactId>\n        &lt;/dependency>\n        &lt;!--eureka client-->\n        &lt;dependency>\n            &lt;groupId>org.springframework.cloud&lt;/groupId>\n            &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId>\n        &lt;/dependency>\n        &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->\n        &lt;dependency>\n            &lt;groupId>com.lun.springcloud&lt;/groupId>\n            &lt;artifactId>cloud-api-commons&lt;/artifactId>\n            &lt;version>$&#123;project.version&#125;&lt;/version>\n        &lt;/dependency>\n        &lt;!--web-->\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-actuator&lt;/artifactId>\n        &lt;/dependency>\n        &lt;!--一般基础通用配置-->\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-devtools&lt;/artifactId>\n            &lt;scope>runtime&lt;/scope>\n            &lt;optional>true&lt;/optional>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>org.projectlombok&lt;/groupId>\n            &lt;artifactId>lombok&lt;/artifactId>\n            &lt;optional>true&lt;/optional>\n        &lt;/dependency>\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-test&lt;/artifactId>\n            &lt;scope>test&lt;/scope>\n        &lt;/dependency>\n    &lt;/dependencies>\n\n&lt;/project>\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263643.YML\nserver:\n  port: 80\n\neureka:\n  client:\n    register-with-eureka: false\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka/\n\n1234567894.主启动\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.hystrix.EnableHystrix;\nimport org.springframework.cloud.openfeign.EnableFeignClients;\n\n/**\n */\n@SpringBootApplication\n@EnableFeignClients\n//@EnableHystrix\npublic class OrderHystrixMain80\n&#123;\n    public static void main(String[] args)\n    &#123;\n        SpringApplication.run(OrderHystrixMain80.class,args);\n    &#125;\n&#125;\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n5.业务类\n\nimport org.springframework.cloud.openfeign.FeignClient;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\n\n/**\n */\n@Component\n@FeignClient(value = \"CLOUD-PROVIDER-HYSTRIX-PAYMENT\" /*,fallback = PaymentFallbackService.class*/)\npublic interface PaymentHystrixService\n&#123;\n    @GetMapping(\"/payment/hystrix/ok/&#123;id&#125;\")\n    public String paymentInfo_OK(@PathVariable(\"id\") Integer id);\n\n    @GetMapping(\"/payment/hystrix/timeout/&#123;id&#125;\")\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id);\n\n&#125;\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nimport com.lun.springcloud.service.PaymentHystrixService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.annotation.Resource;\n\n@RestController\n@Slf4j\npublic class OrderHystirxController &#123;\n    @Resource\n    private PaymentHystrixService paymentHystrixService;\n\n    @GetMapping(\"/consumer/payment/hystrix/ok/&#123;id&#125;\")\n    public String paymentInfo_OK(@PathVariable(\"id\") Integer id)\n    &#123;\n        String result = paymentHystrixService.paymentInfo_OK(id);\n        return result;\n    &#125;\n    \n    @GetMapping(\"/consumer/payment/hystrix/timeout/&#123;id&#125;\")\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id) &#123;\n        String result = paymentHystrixService.paymentInfo_TimeOut(id);\n        return result;\n    &#125;\n\n&#125;\n\n1234567891011121314151617181920212223242526276.正常测试\nhttp://localhost/consumer/payment/hystrix/ok/1\n7.高并发测试\n2W个线程压8001\n消费端80微服务再去访问正常的Ok微服务8001地址\nhttp://localhost/consumer/payment/hystrix/ok/32\n消费者80被拖慢\n原因：8001同一层次的其它接口服务被困死，因为tomcat线程池里面的工作线程已经被挤占完毕。\n正因为有上述故障或不佳表现才有我们的降级&#x2F;容错&#x2F;限流等技术诞生。\n53_降级容错解决的维度要求超时导致服务器变慢(转圈) - 超时不再等待\n出错(宕机或程序运行出错) - 出错要有兜底\n解决：\n对方服务(8001)超时了，调用者(80)不能一直卡死等待，必须有服务降级。对方服务(8001)down机了，调用者(80)不能一直卡死等待，必须有服务降级。对方服务(8001)OK，调用者(80)自己出故障或有自我要求(自己的等待时间小于服务提供者)，自己处理降级。54_Hystrix之服务降级支付侧fallback降级配置 - @HystrixCommand\n8001先从自身找问题\n设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处埋，作服务降级fallback。\n8001fallback\n业务类启用 - @HystrixCommand报异常后如何处理\n—旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法\n@Servicepublic class PaymentService{\n@HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeOutHandler&quot;/*指定善后方法名*/,commandProperties = &#123;\n        @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;3000&quot;)\n&#125;)\npublic String paymentInfo_TimeOut(Integer id)\n&#123;\n    //int age = 10/0;\n    try &#123; TimeUnit.MILLISECONDS.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;\n    return &quot;线程池:  &quot;+Thread.currentThread().getName()+&quot; id:  &quot;+id+&quot;\\t&quot;+&quot;O(∩_∩)O哈哈~&quot;+&quot;  耗时(秒): &quot;;\n&#125;\n\n//用来善后的方法\npublic String paymentInfo_TimeOutHandler(Integer id)\n&#123;\n    return &quot;线程池:  &quot;+Thread.currentThread().getName()+&quot;  8001系统繁忙或者运行报错，请稍后再试,id:  &quot;+id+&quot;\\t&quot;+&quot;o(╥﹏╥)o&quot;;\n&#125;\n\n}1234567891011121314151617181920上面故意制造两种异常:\nint age &#x3D; 10&#x2F;0，计算异常我们能接受3秒钟，它运行5秒钟，超时异常。当前服务不可用了，做服务降级，兜底的方案都是paymentInfo_TimeOutHandler\n主启动类激活\n添加新注解@EnableCircuitBreaker\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;\n@SpringBootApplication@EnableEurekaClient@EnableCircuitBreaker&#x2F;&#x2F;添加到此处public class PaymentHystrixMain8001{    public static void main(String[] args) {            SpringApplication.run(PaymentHystrixMain8001.class, args);    }}1234567891011121355_Hystrix之服务降级订单侧fallback80订单微服务，也可以更好的保护自己，自己也依样画葫芦进行客户端降级保护\n题外话，切记 - 我们自己配置过的热部署方式对java代码的改动明显\n但对@HystrixCommand内属性的修改建议重启微服务\nYML\nserver:  port: 80\neureka:  client:    register-with-eureka: false    service-url:      defaultZone: http://eureka7001.com:7001/eureka/\n#开启feign:  hystrix:    enabled: true12345678910111213主启动\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.hystrix.EnableHystrix;import org.springframework.cloud.openfeign.EnableFeignClients;\n@SpringBootApplication@EnableFeignClients@EnableHystrix&#x2F;&#x2F;添加到此处public class OrderHystrixMain80{\npublic static void main(String[] args)&#123;\n    SpringApplication.run(OrderHystrixMain80.class,args);\n&#125;\n\n}\n123456789101112131415业务类\nimport com.lun.springcloud.service.PaymentHystrixService;import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;\nimport javax.annotation.Resource;\n@RestController@Slf4jpublic class OrderHystirxController {    @Resource    private PaymentHystrixService paymentHystrixService;\n@GetMapping(\"/consumer/payment/hystrix/timeout/&#123;id&#125;\")\n@HystrixCommand(fallbackMethod = \"paymentTimeOutFallbackMethod\",commandProperties = &#123;\n        @HystrixProperty(name=\"execution.isolation.thread.timeoutInMilliseconds\",value=\"1500\")\n&#125;)\npublic String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id) &#123;\n    //int age = 10/0;\n    String result = paymentHystrixService.paymentInfo_TimeOut(id);\n    return result;\n&#125;\n\n//善后方法\npublic String paymentTimeOutFallbackMethod(@PathVariable(\"id\") Integer id)&#123;\n    return \"我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o\";\n&#125;\n\n}\n","slug":"spring-boot","date":"2022-05-08T06:46:00.597Z","categories_index":"JAVA","tags_index":"JAVA,Spring Cloud","author_index":"JIACHEN"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Quick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-05-07T12:13:39.099Z","categories_index":"","tags_index":"hello,hexo","author_index":"JIACHEN"}]