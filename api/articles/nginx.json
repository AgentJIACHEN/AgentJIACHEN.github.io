{"title":"Nginx 的学习手册","uid":"f72a446695f43ddb1d8bfbabff078e31","slug":"nginx","date":"2022-05-08T07:14:34.191Z","updated":"2022-05-14T12:01:27.146Z","comments":true,"path":"api/articles/nginx.json","keywords":null,"cover":[],"content":"<p><img src=\"/post/nginx/image-20220510221237830.png\" alt=\"image-20220510221237830\"></p>\n<p>Nginx 是一个高性能的 HTTP 和反向代理服务器，特点是占用内存少，并发能力强，事实上 Nginx 的并发能力确实在同类型的网页服务器中表现较好。</p>\n<p>Nginx 专为性能优化而开发，性能是其最重要的要求，十分注重效率，有报告 Nginx 能支持高达 50000 个并发连接数。</p>\n<p><strong>01</strong></p>\n<p><strong>Nginx 知识网结构图</strong></p>\n<p>Nginx 的知识网结构图如下：</p>\n<p><img src=\"/post/nginx/image-20220510221305271.png\" alt=\"image-20220510221305271\"></p>\n<p><strong>02****反向代理</strong></p>\n<p><strong>正向代理：</strong>局域网中的电脑用户想要直接访问网络是不可行的，只能通过代理服务器来访问，这种代理服务就被称为正向代理。</p>\n<p><img src=\"/post/nginx/image-20220510221325045.png\" alt=\"image-20220510221325045\"></p>\n<p><strong>反向代理：</strong>客户端无法感知代理，因为客户端访问网络不需要配置，只要把请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据，然后再返回到客户端。</p>\n<p>此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070CW3mYFhBcrgyGPrAXajVNPYB77RxkwVMjjY6HzEMIGCRaQXkWnbMxg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p><strong>03</strong></p>\n<p><strong>负载均衡</strong></p>\n<p>客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕之后，再将结果返回给客户端。</p>\n<p>普通请求和响应过程如下图：</p>\n<p><img src=\"/post/nginx/image-20220510221341097.png\" alt=\"image-20220510221341097\"></p>\n<p>但是随着信息数量增长，访问量和数据量飞速增长，普通架构无法满足现在的需求。</p>\n<p>我们首先想到的是升级服务器配置，可以由于摩尔定律的日益失效，单纯从硬件提升性能已经逐渐不可取了，怎么解决这种需求呢？</p>\n<p>我们可以增加服务器的数量，构建集群，将请求分发到各个服务器上，将原来请求集中到单个服务器的情况改为请求分发到多个服务器，也就是我们说的负载均衡。</p>\n<p>图解负载均衡：</p>\n<p><img src=\"/post/nginx/image-20220510221352882.png\" alt=\"image-20220510221352882\"></p>\n<p>假设有 15 个请求发送到代理服务器，那么由代理服务器根据服务器数量，平均分配，每个服务器处理 5 个请求，这个过程就叫做负载均衡。</p>\n<p><strong>04****动静分离</strong></p>\n<p>为了加快网站的解析速度，可以把动态页面和静态页面交给不同的服务器来解析，加快解析的速度，降低由单个服务器的压力。</p>\n<p>动静分离之前的状态：</p>\n<p><img src=\"/post/nginx/image-20220510221404639.png\" alt=\"image-20220510221404639\"></p>\n<p>动静分离之后：</p>\n<p><img src=\"/post/nginx/image-20220510221417067.png\" alt=\"image-20220510221417067\"></p>\n<p><strong>05****Nginx安装</strong></p>\n<p>Nginx 如何在 Linux 安装</p>\n<p>参考链接：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;blog.csdn.net&#x2F;yujing1314&#x2F;article&#x2F;details&#x2F;97267369<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>Nginx 常用命令</p>\n<p>查看版本：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.&#x2F;nginx -v<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<p>启动：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.&#x2F;nginx<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<p>关闭（有两种方式，推荐使用 .&#x2F;nginx -s quit）：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.&#x2F;nginx -s stop\n.&#x2F;nginx -s quit<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n\n\n<p>重新加载 Nginx 配置：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.&#x2F;nginx -s reload<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<p>Nginx 的配置文件</p>\n<p>配置文件分三部分组成：</p>\n<h5 id=\"①全局块\"><a href=\"#①全局块\" class=\"headerlink\" title=\"①全局块\"></a><strong>①全局块</strong></h5><p>从配置文件开始到 events 块之间，主要是设置一些影响 Nginx 服务器整体运行的配置指令。</p>\n<p>并发处理服务的配置，值越大，可以支持的并发处理量越多，但是会受到硬件、软件等设备的制约。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070ceEurAwxEr7fReXN8soaFFM0UVYoEN5nxmSl1Nmh2F5Sx07lCuFxrA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<h5 id=\"②events-块\"><a href=\"#②events-块\" class=\"headerlink\" title=\"②events 块\"></a><strong>②events 块</strong></h5><p>影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 workprocess 下的网络连接进行序列化，是否允许同时接收多个网络连接等等。</p>\n<p>支持的最大连接数：</p>\n<p><img src=\"/post/nginx/image-20220510221431738.png\" alt=\"image-20220510221431738\"></p>\n<h5 id=\"③HTTP-块\"><a href=\"#③HTTP-块\" class=\"headerlink\" title=\"③HTTP 块\"></a><strong>③HTTP 块</strong></h5><p>诸如反向代理和负载均衡都在此配置。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">location[ &#x3D; | ~ | ~* | ^~] url&#123;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>location 指令说明，该语法用来匹配 url，语法如上：</p>\n<ul>\n<li><strong>&#x3D;：</strong>用于不含正则表达式的 url 前，要求字符串与 url 严格匹配，匹配成功就停止向下搜索并处理请求。</li>\n<li><strong>~：</strong>用于表示 url 包含正则表达式，并且区分大小写。</li>\n<li><strong>~*：</strong>用于表示 url 包含正则表达式，并且不区分大小写。</li>\n<li><strong>^~：</strong>用于不含正则表达式的 url 前，要求 Nginx 服务器找到表示 url 和字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再匹配。</li>\n<li>如果有 url 包含正则表达式，不需要有 ~ 开头标识。</li>\n</ul>\n<p><strong>06****反向代理实战</strong></p>\n<h3 id=\"①配置反向代理\"><a href=\"#①配置反向代理\" class=\"headerlink\" title=\"①配置反向代理\"></a><strong>①配置反向代理</strong></h3><p>目的：在浏览器地址栏输入地址 <a href=\"http://www.123.com/\">www.123.com</a> 跳转 Linux 系统 Tomcat 主页面。</p>\n<p><strong>②具体实现</strong></p>\n<p>先配置 Tomcat，因为比较简单，此处不再赘叙，并在 Windows 访问：</p>\n<p><img src=\"/post/nginx/image-20220510221447678.png\" alt=\"image-20220510221447678\"></p>\n<p>具体流程如下图：</p>\n<p><img src=\"/post/nginx/image-20220510221456859.png\" alt=\"image-20220510221456859\"></p>\n<p>修改之前：</p>\n<p><img src=\"/post/nginx/image-20220510221508109.png\" alt=\"image-20220510221508109\"></p>\n<p>配置如下：</p>\n<p><img src=\"/post/nginx/image-20220510221520115.png\" alt=\"image-20220510221520115\"></p>\n<p>再次访问：</p>\n<p><img src=\"/post/nginx/image-20220510221529674.png\" alt=\"image-20220510221529674\"></p>\n<p><strong>③反向代理 2</strong></p>\n<p>目标：</p>\n<ul>\n<li>访问 <a href=\"http://192.168.25.132:9001/edu/\">http://192.168.25.132:9001/edu/</a> 直接跳转到 192.168.25.132:8080</li>\n<li>访问 <a href=\"http://192.168.25.132:9001/vod/\">http://192.168.25.132:9001/vod/</a> 直接跳转到 192.168.25.132:8081</li>\n</ul>\n<p><strong>准备：</strong>配置两个 Tomcat，端口分别为 8080 和 8081，都可以访问，端口修改配置文件即可。</p>\n<p><img src=\"/post/nginx/image-20220510221542815.png\" alt=\"image-20220510221542815\"></p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQrRD4Mcr0icGmGAj3uB9u070I2fsgic1O8TY0C0hJGxM7X0VnYxzXk14ehDrBuW1Xzib8kskB7jPzcVw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>新建文件内容分别添加 8080！！！和 8081！！！</p>\n<p><img src=\"/post/nginx/image-20220510221556062.png\" alt=\"image-20220510221556062\"></p>\n<p>响应如下图：</p>\n<p><img src=\"/post/nginx/image-20220510221610368.png\" alt=\"image-20220510221610368\"></p>\n<p>具体配置如下：</p>\n<p><img src=\"/post/nginx/image-20220510221622879.png\" alt=\"image-20220510221622879\"></p>\n<p>重新加载 Nginx：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.&#x2F;nginx -s reload<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n\n\n<p>访问：</p>\n<p><img src=\"/post/nginx/image-20220510221633899.png\" alt=\"image-20220510221633899\"></p>\n<p>实现了同一个端口代理，通过 edu 和 vod 路径的切换显示不同的页面。</p>\n<p><strong>反向代理小结</strong></p>\n<p><strong>第一个例子：</strong>浏览器访问 <a href=\"http://www.123.com,由/\">www.123.com，由</a> host 文件解析出服务器 ip 地址<br>192.168.25.132 <a href=\"http://www.123.com./\">www.123.com。</a></p>\n<p>然后默认访问 80 端口，而通过 Nginx 监听 80 端口代理到本地的 8080 端口上，从而实现了访问 <a href=\"http://www.123.com,最终转发到/\">www.123.com，最终转发到</a> tomcat 8080 上去。</p>\n<p>第二个例子：</p>\n<ul>\n<li>访问 <a href=\"http://192.168.25.132:9001/edu/\">http://192.168.25.132:9001/edu/</a> 直接跳转到 192.168.25.132:8080</li>\n<li>访问 <a href=\"http://192.168.25.132:9001/vod/\">http://192.168.25.132:9001/vod/</a> 直接跳转到 192.168.25.132:8081</li>\n</ul>\n<p>实际上就是通过 Nginx 监听 9001 端口，然后通过正则表达式选择转发到 8080 还是 8081 的 Tomcat 上去。</p>\n<p><strong>07</strong></p>\n<p><strong>负载均衡实战</strong></p>\n<p>①修改 nginx.conf，如下图：</p>\n<p><img src=\"/post/nginx/image-20220510221646888.png\" alt=\"image-20220510221646888\"></p>\n<p>②重启 Nginx：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.&#x2F;nginx -s reload<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<p>③在 8081 的 Tomcat 的 webapps 文件夹下新建 edu 文件夹和 a.html 文件，填写内容为 8081！！！！</p>\n<p>④在地址栏回车，就会分发到不同的 Tomcat 服务器上：</p>\n<p><img src=\"/post/nginx/image-20220510221703167.png\" alt=\"image-20220510221703167\"></p>\n<p>负载均衡方式如下：</p>\n<ul>\n<li>轮询（默认）。</li>\n<li>weight，代表权，权越高优先级越高。</li>\n<li>fair，按后端服务器的响应时间来分配请求，相应时间短的优先分配。</li>\n<li>ip_hash，每个请求按照访问 ip 的 hash 结果分配，这样每一个访客固定的访问一个后端服务器，可以解决 Session 的问题。</li>\n<li><img src=\"/post/nginx/image-20220510221714686.png\" alt=\"image-20220510221714686\"></li>\n</ul>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"08-动静分离实战\"><a href=\"#08-动静分离实战\" class=\"headerlink\" title=\"08****动静分离实战\"></a><strong>08****动静分离实战</strong></h2><h2 id=\"什么是动静分离？把动态请求和静态请求分开，不是讲动态页面和静态页面物理分离，可以理解为-Nginx-处理静态页面，Tomcat-处理动态页面。\"><a href=\"#什么是动静分离？把动态请求和静态请求分开，不是讲动态页面和静态页面物理分离，可以理解为-Nginx-处理静态页面，Tomcat-处理动态页面。\" class=\"headerlink\" title=\"什么是动静分离？把动态请求和静态请求分开，不是讲动态页面和静态页面物理分离，可以理解为 Nginx 处理静态页面，Tomcat 处理动态页面。\"></a>什么是动静分离？把动态请求和静态请求分开，不是讲动态页面和静态页面物理分离，可以理解为 Nginx 处理静态页面，Tomcat 处理动态页面。</h2><p>动静分离大致分为两种：</p>\n<ul>\n<li>纯粹将静态文件独立成单独域名放在独立的服务器上，也是目前主流方案。</li>\n<li>将动态跟静态文件混合在一起发布，通过 Nginx 分开。</li>\n</ul>\n<h4 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a></h4><h4 id=\"动静分离图析：\"><a href=\"#动静分离图析：\" class=\"headerlink\" title=\"动静分离图析：\"></a>动静分离图析：</h4><p><img src=\"/post/nginx/image-20220510221731812.png\" alt=\"image-20220510221731812\"></p>\n<p>实战准备，准备静态文件：</p>\n<p><img src=\"/post/nginx/image-20220510221740236.png\" alt=\"image-20220510221740236\"></p>\n<p>配置 Nginx，如下图：</p>\n<p><img src=\"/post/nginx/image-20220510221752155.png\" alt=\"image-20220510221752155\"></p>\n<p>Nginx 高可用</p>\n<p>如果 Nginx 出现问题：</p>\n<p><img src=\"/post/nginx/image-20220510221801356.png\" alt=\"image-20220510221801356\"></p>\n<p>解决办法：</p>\n<p><img src=\"/post/nginx/image-20220510221809656.png\" alt=\"image-20220510221809656\"></p>\n<p>前期准备：</p>\n<ul>\n<li><strong>两台 Nginx 服务器</strong></li>\n<li><strong>安装 Keepalived</strong></li>\n<li><strong>虚拟 ip</strong></li>\n</ul>\n<h2 id=\"安装-Keepalived：\"><a href=\"#安装-Keepalived：\" class=\"headerlink\" title=\"安装 Keepalived：\"></a>安装 Keepalived：</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">[root@192 usr]# yum install keepalived -y\n[root@192 usr]# rpm -q -a keepalived\nkeepalived-1.3.5-16.el7.x86_64<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>修改配置文件：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">[root@192 keepalived]# cd &#x2F;etc&#x2F;keepalived\n[root@192 keepalived]# vi keepalived.conf<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n\n\n<p>分别将如下配置文件复制粘贴，覆盖掉 keepalived.conf，虚拟 ip 为 192.168.25.50。</p>\n<p>对应主机 ip 需要修改的是：</p>\n<ul>\n<li>smtp_server 192.168.25.147（主）smtp_server 192.168.25.147（备）</li>\n<li>state MASTER（主） state BACKUP（备）</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">global_defs &#123;\n   notification_email &#123;\n     acassen@firewall.loc\n     failover@firewall.loc\n     sysadmin@firewall.loc\n   &#125;\n   notification_email_from Alexandre.Cassen@firewall.loc\n   smtp_server 192.168.25.147\n   smtp_connect_timeout 30\n   router_id LVS_DEVEL # 访问的主机地址\n&#125;\n\nvrrp_script chk_nginx &#123;\n  script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot;  # 检测文件的地址\n  interval 2   # 检测脚本执行的间隔\n  weight 2   # 权重\n&#125;\n\nvrrp_instance VI_1 &#123;\n    state BACKUP    # 主机MASTER、备机BACKUP    \n    interface ens33   # 网卡\n    virtual_router_id 51 # 同一组需一致\n    priority 90  # 访问优先级，主机值较大，备机较小\n    advert_int 1\n    authentication &#123;\n        auth_type PASS\n        auth_pass 1111\n    &#125;\n    virtual_ipaddress &#123;\n        192.168.25.50  # 虚拟ip\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>启动代码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">[root@192 sbin]# systemctl start keepalived.service\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<p><img src=\"/post/nginx/image-20220510221822971.png\" alt=\"image-20220510221822971\"></p>\n<p>访问虚拟 ip 成功：</p>\n<p><img src=\"/post/nginx/image-20220510221831063.png\" alt=\"image-20220510221831063\"></p>\n<p>关闭主机 147 的 Nginx 和 Keepalived，发现仍然可以访问。</p>\n<p>原理解析</p>\n<p><img src=\"/post/nginx/image-20220510221838933.png\" alt=\"image-20220510221838933\"></p>\n<p>如下图，就是启动了一个 master，一个 worker，master 是管理员，worker是具体工作的进程。</p>\n<p><img src=\"/post/nginx/image-20220510221847130.png\" alt=\"image-20220510221847130\"></p>\n<p>worker 如何工作？如下图：</p>\n<p><img src=\"/post/nginx/image-20220510221856852.png\" alt=\"image-20220510221856852\"></p>\n<p>小结</p>\n<p>worker 数应该和 CPU 数相等；一个 master 多个 worker 可以使用热部署，同时 worker 是独立的，一个挂了不会影响其他的。</p>\n","text":" Nginx 是一个高性能的 HTTP 和反向代理服务器，特点是占用内存少，并发能力强，事实上 Nginx 的并发能力确实在同类型的网页服务器中表现较好。 Nginx 专为性能优化而开发，性能是其最重要的要求，十分注重效率，有报告 Nginx 能支持高达 50000 个并发连接数...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":4,"path":"api/categories/JAVA.json"}],"tags":[{"name":"JAVA","slug":"JAVA","count":5,"path":"api/tags/JAVA.json"},{"name":"Nginx","slug":"Nginx","count":1,"path":"api/tags/Nginx.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%91%A0%E5%85%A8%E5%B1%80%E5%9D%97\"><span class=\"toc-text\">①全局块</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%91%A1events-%E5%9D%97\"><span class=\"toc-text\">②events 块</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%91%A2HTTP-%E5%9D%97\"><span class=\"toc-text\">③HTTP 块</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E2%91%A0%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">①配置反向代理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#-1\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#-2\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#08-%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E5%AE%9E%E6%88%98\"><span class=\"toc-text\">08****动静分离实战</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%EF%BC%9F%E6%8A%8A%E5%8A%A8%E6%80%81%E8%AF%B7%E6%B1%82%E5%92%8C%E9%9D%99%E6%80%81%E8%AF%B7%E6%B1%82%E5%88%86%E5%BC%80%EF%BC%8C%E4%B8%8D%E6%98%AF%E8%AE%B2%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%92%8C%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E7%89%A9%E7%90%86%E5%88%86%E7%A6%BB%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%90%86%E8%A7%A3%E4%B8%BA-Nginx-%E5%A4%84%E7%90%86%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%EF%BC%8CTomcat-%E5%A4%84%E7%90%86%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E3%80%82\"><span class=\"toc-text\">什么是动静分离？把动态请求和静态请求分开，不是讲动态页面和静态页面物理分离，可以理解为 Nginx 处理静态页面，Tomcat 处理动态页面。</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#-3\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E5%9B%BE%E6%9E%90%EF%BC%9A\"><span class=\"toc-text\">动静分离图析：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85-Keepalived%EF%BC%9A\"><span class=\"toc-text\">安装 Keepalived：</span></a>","author":{"name":"JIACHEN","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/AgentJIACHEN","twitter":"https://space.bilibili.com/59563009","stackoverflow":"https://stackoverflow.com/users/19074815/agentjiachen","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"MYSQL优化面试","uid":"8c8767142f7e95355e375b07bd636def","slug":"SQL","date":"2022-05-14T12:18:53.378Z","updated":"2022-05-17T13:03:04.993Z","comments":true,"path":"api/articles/SQL.json","keywords":null,"cover":[],"text":"MySQL架构流程 经历了四层 1 Connector JDBC odbc 2 Server (Query Cache &#x2F; Buffer, Parser, Optimizer…) 3 Storage (InnoDB MyISAM Memory) 4File (Row D...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":4,"path":"api/categories/JAVA.json"}],"tags":[{"name":"JAVA","slug":"JAVA","count":5,"path":"api/tags/JAVA.json"},{"name":"MYSQL","slug":"MYSQL","count":1,"path":"api/tags/MYSQL.json"}],"author":{"name":"JIACHEN","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/AgentJIACHEN","twitter":"https://space.bilibili.com/59563009","stackoverflow":"https://stackoverflow.com/users/19074815/agentjiachen","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Spring Cloud 学习笔记（1 / 3）","uid":"f10986d12ebf2b7b240f2a2d5f137570","slug":"spring-boot","date":"2022-05-08T06:46:00.597Z","updated":"2022-05-14T12:28:00.541Z","comments":true,"path":"api/articles/spring-boot.json","keywords":null,"cover":null,"text":"零基础微服务架构理论入门什么是微服务In short, the microservice architectural style is an approach to developing a single application as a suite of small servi...","link":"","photos":[],"count_time":{"symbolsCount":"98k","symbolsTime":"1:29"},"categories":[{"name":"JAVA","slug":"JAVA","count":4,"path":"api/categories/JAVA.json"}],"tags":[{"name":"JAVA","slug":"JAVA","count":5,"path":"api/tags/JAVA.json"},{"name":"Spring Cloud","slug":"Spring-Cloud","count":1,"path":"api/tags/Spring-Cloud.json"}],"author":{"name":"JIACHEN","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/AgentJIACHEN","twitter":"https://space.bilibili.com/59563009","stackoverflow":"https://stackoverflow.com/users/19074815/agentjiachen","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}